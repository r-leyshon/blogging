[
  {
    "objectID": "blogs/01-state-of-pyshiny.html",
    "href": "blogs/01-state-of-pyshiny.html",
    "title": "The State of Python Shiny.",
    "section": "",
    "text": "DALL.E prompt: python logo golden Sparkling glittery bokeh bright.\n\n\nPython Shiny celebrates its first year anniversary on PyPi in July 2023. In case that needs further qualification, this is the Python-native implementation of the beloved RShiny dashboarding package that has been available in the R programming framework for over a decade now. Python Shiny has benefited from the experience that the developers at Posit have gained in building its more mature, R-flavoured sibling.\nPython Shiny has experienced what I would describe as an accelerated evolution and has the potential to become a front runner in production-grade applications. Mainly because it adheres to an evaluation strategy which is a bit ‘un-pythonic’. Shiny introduces dashboarding with lazy evaluation, meaning that elements of your code will only be evaluated when there is a need to do so. This is not always a great idea, particularly for standard scripting purposes. But it does make event-driven applications more efficient and scalable. More on Posit’s take on the USP of Python Shiny here.\nLet’s consider the following example in Python:\n\n# In Python\ntry:\n  def failing_print(param_a=\"Am I lazy?\", param_b=absolutely_not):\n    print(param_a)\nexcept NameError:\n  print(\"Python would not allow me to define this function.\")\n\nPython would not allow me to define this function.\n\n\nStrict (also known as eager) evaluation in Python has triggered an error. I’ve had to catch the error above with the try/except clause in order to render this website. Even though failing_print() never calls on param_b, Python checks that the default value of that parameter exists on definition of the function.\nLet us now compare the situation in R.\n\n# In R\npassing_print &lt;- function(param_a = \"Am I lazy?\", param_b = yes_you_are){\n  print(param_a)\n}\nprint(paste(\"Does `yes_you_are` exist? : \", exists(\"yes_you_are\")))\n\n[1] \"Does `yes_you_are` exist? :  FALSE\"\n\npassing_print()\n\n[1] \"Am I lazy?\"\n\n\nNo exception was raised although the value yes_you_are has not been defined.\nLazy evaluation in Python Shiny minimises the work the application needs to undertake. Values in the app backend will only be re-evaluated as they are needed and contrasts with more pythonic approaches to dashboarding, such as the case with the streamlit package."
  },
  {
    "objectID": "blogs/01-state-of-pyshiny.html#python-for-shiny-is-now-a-thing",
    "href": "blogs/01-state-of-pyshiny.html#python-for-shiny-is-now-a-thing",
    "title": "The State of Python Shiny.",
    "section": "",
    "text": "DALL.E prompt: python logo golden Sparkling glittery bokeh bright.\n\n\nPython Shiny celebrates its first year anniversary on PyPi in July 2023. In case that needs further qualification, this is the Python-native implementation of the beloved RShiny dashboarding package that has been available in the R programming framework for over a decade now. Python Shiny has benefited from the experience that the developers at Posit have gained in building its more mature, R-flavoured sibling.\nPython Shiny has experienced what I would describe as an accelerated evolution and has the potential to become a front runner in production-grade applications. Mainly because it adheres to an evaluation strategy which is a bit ‘un-pythonic’. Shiny introduces dashboarding with lazy evaluation, meaning that elements of your code will only be evaluated when there is a need to do so. This is not always a great idea, particularly for standard scripting purposes. But it does make event-driven applications more efficient and scalable. More on Posit’s take on the USP of Python Shiny here.\nLet’s consider the following example in Python:\n\n# In Python\ntry:\n  def failing_print(param_a=\"Am I lazy?\", param_b=absolutely_not):\n    print(param_a)\nexcept NameError:\n  print(\"Python would not allow me to define this function.\")\n\nPython would not allow me to define this function.\n\n\nStrict (also known as eager) evaluation in Python has triggered an error. I’ve had to catch the error above with the try/except clause in order to render this website. Even though failing_print() never calls on param_b, Python checks that the default value of that parameter exists on definition of the function.\nLet us now compare the situation in R.\n\n# In R\npassing_print &lt;- function(param_a = \"Am I lazy?\", param_b = yes_you_are){\n  print(param_a)\n}\nprint(paste(\"Does `yes_you_are` exist? : \", exists(\"yes_you_are\")))\n\n[1] \"Does `yes_you_are` exist? :  FALSE\"\n\npassing_print()\n\n[1] \"Am I lazy?\"\n\n\nNo exception was raised although the value yes_you_are has not been defined.\nLazy evaluation in Python Shiny minimises the work the application needs to undertake. Values in the app backend will only be re-evaluated as they are needed and contrasts with more pythonic approaches to dashboarding, such as the case with the streamlit package."
  },
  {
    "objectID": "blogs/01-state-of-pyshiny.html#an-example-python-shiny-app.",
    "href": "blogs/01-state-of-pyshiny.html#an-example-python-shiny-app.",
    "title": "The State of Python Shiny.",
    "section": "An Example Python Shiny App.",
    "text": "An Example Python Shiny App.\nThis application is written in Python and served with a free shinyapps.io account. I made the app to explore the quality of the spatial data available within OpenStreetMap (OSM) data for certain urban areas. OSM is an open-source, community-maintained source of transport network data. The files also contain other spatial features, such as land use polygons. The quality of this data varies by location, as you may find in the app.\nThe application is pretty straightforward. It uses pandas to read in some pre-prepared data tables from a data folder. These files were prepared with a python package called pyrosm. Pyrosm is a useful application for ingesting, assessing & visualising OSM data. Selecting a city from the dropdowns then clicking the “Go” button will read the correct table from this little database, then using matplotlib, it visualises the selected spatial features. The app also presents some simple summary statistics in tables at the bottom of the page.\nThe preparation of the data files is not strictly necessary. You can serve an app and have it make external connections to data services to ingest data. In this instance, I chose to pre-process the data as it helped to improve the performance of the app. Even so, selecting London or Leeds can result in some wait times, so please be aware of this. Options for improving the performance further could include parallel processing, though that is not implemented here and is beyond the scope of this little example.\nIf you’d like to take a look at the application code and have a GitHub account, you can access it here."
  },
  {
    "objectID": "blogs/01-state-of-pyshiny.html#so-what-does-a-shiny-project-look-like",
    "href": "blogs/01-state-of-pyshiny.html#so-what-does-a-shiny-project-look-like",
    "title": "The State of Python Shiny.",
    "section": "So What Does a Shiny Project Look Like?",
    "text": "So What Does a Shiny Project Look Like?\n\nOrganising a Shiny Project.\nBelow is a directory tree diagram of the example Shiny application presented above. It shows the file structure in the various folders.\n.\n├── 01-update-db.py\n├── app.py\n├── config\n│   └── 01-update-db.toml\n├── data\n│   ├── leeds-landuse-2023-06-19.arrow\n│   ├── leeds-natural-2023-06-19.arrow\n│   ├── leeds-net-driving-2023-06-19.arrow\n│   ├── london-landuse-2023-06-19.arrow\n│   ├── london-natural-2023-06-19.arrow\n│   ├── london-net-driving-2023-06-19.arrow\n│   ├── marseille-landuse-2023-06-19.arrow\n│   ├── marseille-natural-2023-06-19.arrow\n│   ├── marseille-net-driving-2023-06-19.arrow\n│   ├── newport-landuse-2023-06-19.arrow\n│   ├── newport-natural-2023-06-19.arrow\n│   └── newport-net-driving-2023-06-19.arrow\n├── requirements.txt\n└── rsconnect-python\n    └── pyrosm-cities-app.json\nThe Shiny code that generates the application is in app.py. The data folder is where you put any data files you’d like to work with. Here I’m working with the .arrow format (More on that here). However, this folder could be used to store csvs, images, a GeoJSON database, whatever your application needs.\nThe file 01-update-db.py and the contents of the config folder are related. The python script is used to update the database in the data folder. This part of the workflow can be quite time consuming, particularly extracting the transport network from dense areas such as Greater London. In order to improve the performance of the app, I chose to pre-prepare this data and limit the number of areas to my specific use-case. A previous iteration of this dashboard simply sent requests using the python pyrosm package to get data for any valid area name. The TOML file in the config folder simply stores some parameters used to configure 01-update-db.py, such as named areas of interest, bounding box coordinates in order to crop the maps, that sort of thing. The requirements.txt file is super important. Not only will it help others to re-run your dashboard with the required package dependencies made explicit, this is also a file that hosting services such as shinyapps.io will use to recreate your development environment. More on that later.\n\n\n\n\n\n\nTip\n\n\n\nEnsuring that you have ‘pinned’ each package version in your requirements file will make publishing to a hosting service such as shinyapps.io a lot easier. It can be frustrating to push your locally working application up to a remote service, waiting for a potentially lengthy deployment routine to complete only to see that your app breaks as you’re working on a different version of numpy than the one available by default in the remote server.\n\n\nFinally, the rsconnect-python directory is not something that would appear in your Shiny project until you deploy it to a remote-hosting service like shinyapps.io. It contains some metadata about your application which the remote service will use to set up your app properly.\n\n\nA Closer Look at app.py.\nAs stated earlier, this is where your app code goes. But before diving straight into some code, let’s try to get a feel for how the reactivity works.\n\n\n\n\n\nflowchart TD\n  user[\"User\"]\n  subgraph Application\n  server[\"Server\n  - Executes python code.\n  - Processes data.\n  - Translates outputs into HTML.\n  \"]\n  ui[\"User Interface\n  - Displays input widgets.\n  - Displays rendered server outputs.\n  - Can be adjusted with HTML & CSS.\"]\n  db[(\"Data\")]\n  end\n  user --&gt;|Input Values| ui &lt;--&gt;|Dynamic Values| server\n  db --&gt;|Read| server\n\nlinkStyle default stroke-width:1px,color:blue;\n\n\n\n\n\n\n\n\nEach Shiny application comes in two distinct sections. The user interface is the frontend of the application, where a person engages with elements of a web page in order to control visuals, filter tables and so on. The web page translates Python code into HyperText Markup Language (HTML). HTML can be interpreted by a web browser in order to present the user with a structured web page. But in order to present an attractive web page, this HTML foundation needs to be styled. So Cascading Style Sheets (CSS) are used to add decoration to the foundation established by HTML.\n\n\nServer-Side Shenanigans.\nHaving an attractive web page that does not do something when you click around on it, enter your credit card details or click ‘decline’ on cookie consent notices would be rather pointless. This is where a web developer would use the language of the browser to work with data behind that pretty frontend. That language is JavaScript and it’s remarkably versatile and intimidating to many data-types.\nSo to make a functioning app, you need to learn 3 distinct languages. For this reason, packages such as Shiny, Dash and Streamlit have become very popular with analysts working within open-source programming frameworks such as Python and R. They allow the creation of applications while adhering to the syntax that an analyst would be more familiar with. Abstracting all that front-end know-how behind some very straightforward Python code allows the analyst to focus their efforts on the parts of their job that they excel in - gaining insight from data.\nThere would be little value in emulating the excellent Posit documentation on getting started with Python Shiny. To do that, I suggest using their docs. In combination with the examples provided, a comprehensive introduction to Shiny is readily available. In the next section, I will focus on introducing a minimal application and then expanding on some of the more subtle considerations in the reactive flow of the backend. I’ll choose to focus on things where I’ve needed to learn by trial and error, or by searching the Stack Overflow boards through some of the inevitable roadblocks a person encounters when programming dashboards. I’ll throw in some common ‘gotchas’ for good measure.\nThe fastest way to get up and running with Python Shiny would be to play with the interactive code snippets that Posit makes available on their overview documentation. They host live Shiny sessions with the interactive app and backend code side-by-side. This is a great place to try things out and feel free to copy code from the examples I provide here."
  },
  {
    "objectID": "blogs/01-state-of-pyshiny.html#python-shiny-ecosystem.",
    "href": "blogs/01-state-of-pyshiny.html#python-shiny-ecosystem.",
    "title": "The State of Python Shiny.",
    "section": "Python Shiny Ecosystem.",
    "text": "Python Shiny Ecosystem.\nThe success of Python Shiny will be down to the adoption & support of the open-source community. This was easier to achieve 10 years ago in the R framework as Shiny had no real competitors at that time. This is not the case in the modern-day Python framework. Even with its particular USP in comparison to Streamlit & Dash, programmers and analysts are creatures of habit. Considering the new player on the block as an alternative to what you already know requires a considerable argument. There will always be overhead in developing familiarity with a new solution’s particular quirks. That said, some of the community-developed packages in the more mature RShiny make building apps at scale very manageable. This final section of this blog takes a look at what Python Shiny bolt-ons we can already play with and a more wistful look over the programming divide at RShiny, considering some of the amazing packages that make me hopeful for the potential future of Python Shiny.\n\nWhat We Already Have.\n\nCompatibility With Jupyter Widgets.\nJupyter Widgets is a well-known add-in for Jupyter Notebooks, allowing for interactive widgets to be displayed and used in Notebooks. This allows for some interesting mini-dashboard opportunities to be served directly within the notebook itself, alongside the code. Having this compatibility from the start is great. While it does introduce a little duplication (Python Shiny has many of its own equivalent ui input widgets), the particular look and range of these widgets will be appealing to many seasoned Python devs. Many of the Jupyter Widget aficionados would have previously developed the capability in specifying callback logic, to be able to capture the user’s interactions with elements of the widget. For example, select a category in a table and use that active selection to filter a chart, the sort of thing that tends to be more prevalent in Business Insight software. Achieving this sort of interaction in Shiny definitely falls under ‘advanced use’. In R, the package crosstalk has significantly lowered the bar in achieving this. Hopefully a dedicated Python Shiny module or package makes its way to PyPi soon.\n\n\nDeploying An App With rsconnect-python.\nThis package is a useful command line interface (CLI) tool that allows you to build application manifests from your Shiny project and deploy them to services such as shinyapps.io. Once you’re ready to share an app with the wider community, check out the docs.\n\n\nModular Dashboards (Shiny Modules).\nThis aspect of Shiny dashboarding is a bit meta. Essentially, when you (or your organisation) gets to a point that they have enough dashboards to be concerned with thinking about consistency and efficiency, take a read through the Python Shiny Modules docs. This is a way of reusing elements of your dashboard, much in the same way in which you reuse code by writing a function. Maybe your organisation has really committed to Shiny and has developed a beautifully-styled interface with house branding, or some interface component such as an Email field with some complex regular expression checking the validity of the Email address. There really is no need to copy-paste that code when you want to use it again. Package the element up as a Shiny Module and you can roll out this feature across multiple dashboards, secure in the knowledge that the quality of this module has already been agreed. Responsibility successfully deferred!\n\n\n\n\n\n\nCode reuse is the Holy Grail of Software Engineering — Douglas Crockford\n\n\n\nThe fact that Python Shiny devs have prioritised modular dashboarding so early is great. It illustrates a commitment to reproducibility that is rightly lauded within the open source community. Just to note that the ability to do this in RShiny took approximately 3 years. Python users are quite spoiled to be able to make use of this feature from the outset.\n\n\n\nWhat I Really Want.\nWhile I feel generally positive about the future of Python Shiny, I do look across the gulf that exists between the Python and R frameworks with hungry eyes. Particularly at the rich, community-driven plethora of RShiny add-ins that make Shiny the undeniable dashboarding front-runner in that framework. Here is my wish-list of Python Shiny helper tools, ranked order (opinionated warning).\n\n1. Reactlog.\n\n\n\nThere’s no 2 ways about it, debugging apps is a royal pain. One of my go to helpers in times of need is Posit’s own reactlog package. Reactlog is such an understated tool, yet it has been crucial to me in understanding what’s going on under the hood of my apps. So much so, that I now feel hopelessly exposed when writing apps in Python without it to lean on.\n\n\n\nThis package allows you to launch an app, showing you useful insights about the performance and reactive flow of your app. It’s an app inception. It can be used in a variety of modes, you can record yourself clicking away on your app and then pause the interface to inspect variable statuses. Reactlog visualises the dependency graph of variables in your server and really is an indispensable debugging tool.\n\n\n2. Shinytest.\nUnit tests for your RShiny app anyone? Authored by the ubiquitous Hadley Wickham, shinytest allows you to make assertions about the behaviour of your application. In combination with the ability to design Shiny modules, this is a key piece of the RShiny toolkit allowing for the design of stable, production-ready Shiny components.\n\n\n3. DT Data Tables.\nAnother one of Posit’s own packages, DT helps to create beautiful, customisable and interactive data tables for the presentation of tables. Not just for RShiny applications, DT is also widely used in Rmarkdown reports. A dedicated Python Shiny solution would be most welcome.\n\n\n4. Shinyhelper.\nThe shinyhelper package developed by Chris Mason-Thom is an excellent solution for those involved applications that need a little more guidance for the user.\n\n\n\nShinyhelper allows the developer to include markdown files with extensive instructions, images and gif animations of how to use your application. These documents will be hidden from the screen until the user chooses to click on the help icons that shinyhelper provides. These help icons can be easily styled and positioned around any element within your ui. Once clicked, they will launch modal windows with your beautifully formatted instructions, allowing a wealth of guidance to be included within your app without causing excessive clutter.\nTry clicking through the different helper symbols in the demo RShiny application below."
  },
  {
    "objectID": "blogs/01-state-of-pyshiny.html#in-review.",
    "href": "blogs/01-state-of-pyshiny.html#in-review.",
    "title": "The State of Python Shiny.",
    "section": "In Review.",
    "text": "In Review.\nPython Shiny is a promising addition to the Python programming framework. It has a USP, and Posit have the know-how to apply the learning from their past development of RShiny to help ensure it has a bright future. It is also worth noting that Posit have recently put a lot of effort into developing Quarto, which you may think of as like Rmarkdown but with native Python, R and Julia support. The reason why this is important is that often, interactive widgets and solutions designed for use in notebooks or markdown documents take little refactoring to get them running in Shiny apps. Or conversely, there are ways to convert rmarkdown docs into Shiny or Shiny-like applications. Understanding the synergies between these tools and how they have influenced the evolution of RShiny may give some insight into how we may expect Python Shiny & Quarto to develop in the years ahead.\nThe Python community is well-served by dashboarding solutions which will affect its wider adoption. If you are newer to dashboarding, or if you are looking for a solution that perhaps scales better than some of the other options available in the Python framework, then consider Python Shiny. It’s already pretty great and will only get better as the community warms to this new tool in the Python toolkit."
  },
  {
    "objectID": "blogs/index.html",
    "href": "blogs/index.html",
    "title": "Blogs",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nThe State of Python Shiny.\n\n\n15 min\n\n\n\nExplanation\n\n\n\nAn overview of the progress of Python Shiny, and where it could possibly go.\n\n\n\nRich Leyshon.\n\n\nAug 29, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLet’s Build a Basic Python Shiny App.\n\n\n21 min\n\n\n\nTutorial\n\n\n\nAn interactive tutorial allowing newcomers to Shiny to build a basic application.\n\n\n\nRich Leyshon.\n\n\nAug 12, 2023\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "blogs/02-getting-started-pyshiny.html",
    "href": "blogs/02-getting-started-pyshiny.html",
    "title": "Let’s Build a Basic Python Shiny App.",
    "section": "",
    "text": "Source: https://www.wallpaperflare.com/. Creative Commons License.\n\n\nThis tutorial is intended for those who are already familiar with Python, but may be less familiar with dashboarding and Shiny in Python. It may also be of interest to those who are well-versed in RShiny and would like to see how it has been implemented in Python.\nThis is a light-weight, introductory Python Shiny tutorial. No installation of software is required, other than a web-browser (which you must already have) and a willingness to experiment. We will use the shinylive service to display the application that we write and steadily add to a basic app, discussing some of the concepts as we go. Finally, let’s regroup and reflect on some coping techniques for when you begin writing your own Python Shiny apps.\nThis tutorial will not attempt to reproduce any of Posit’s documentation, which is rather excellent so please check that out. Also, if you would prefer a conceptual treatment of Python Shiny, please see my blog on The Current Stateof Python Shiny.\n\n\n\n\n\n\nHow to…\n\n\n\nFeel free to tinker with the code in the following example apps and then press play in the top-right hand corner of the console interface. Don’t worry - you won’t break anything important. To reset the code, simply refresh your web page.\nIf the app doesn’t launch, you’ll see some spinning grey hexagons that never go away . This is likely to be a problem with permissions in your browser. But you can click on the collapsible code block below the app windows and copy the code to an app.py file on your computer. If you have python and python shiny installed, you should be good to go.\n\n\n\n\nBelow is a really minimal app that doesn’t do very much at all. The python code is presented on the left. The interactive app is presented on the right. You can type into the app’s text field, and that’s about it for now.\n\n\n\n\n\nShow the code\n#1 Import modules to help us build our app\nfrom shiny import ui, App\n\n#^putting things above the app means they can be shared between your ui and server\n\napp_ui = ui.page_fluid(\n  #2 all of the elements you wish to show your user should go within the ui\n    ui.input_text(\n        id=\"name_entry\",\n        label=\"Please enter your name\",\n        placeholder=\"Your name here\"\n        )\n)\n\ndef server(input, output, session):\n  #3 this is where your app logic should go. So far, not much...\n    return None\n  \n# Finally - this bit packages up our ui and server. Super important - it must\n# be named `app`.\n\n\nYou’ll see that the code defines an app_ui object, which is a Shiny ui instance. Within that ui.page_fluid() function, we can specify all the elements of the app that we would like to present to our users.\n\n\n\n\n\n\nOn Users…\n\n\n\nThere are only two industries that call their customers “users”: illegal drugs and software – Edward Tufte\n\n\nSo far, only one simple ui element has been defined. The humble text input ui.input_text() which allows our users to place their own text into a text field.\nNotice that in Python, all the inputs begin with input.... There’s ui.input_text() as we’ve seen, but there’s lots more. ui.input_date(), ui.input_file() and ui.input_slider to name a few. This consistent syntax approach is a subtle improvement over RShiny and makes it so much easier to work with the vast array of widgets without having to remember them all. If you’re working in a modern editor such as Visual Studio Code, simply typing ui.input will remind you of all the options available to you. For those not working in a nice GUI like VSCode, a Shiny cheatsheet may be useful, though note that at the time of writing I could only find R-flavoured ones…\nAll ui input elements start with the same 2 arguments, id and label:\n\nid: The internal name of the input. What does that mean? Call it what you like. Whatever you choose, be aware that when you want to use the values from the text input to do something in the server, it’s this name that you will need to reference.\nlabel: A short piece of text that prompts your user to do something. This will be displayed in your ui above the input element.\n\n\n\n\nUnfortunately, so far our app doesn’t actually do much. Typing into the empty text field yields no result. That’s because right now, our server function simply returns None. Let’s resolve this.\n\n\n\n\n\nShow the code\n#1 update the import statement to include `render` module\nfrom shiny import ui, App, render\n\napp_ui = ui.page_fluid(\n    ui.input_text(\n        id=\"name_entry\",\n        label=\"Please enter your name\",\n        placeholder=\"Your name here\"\n        ),\n    #2 Include a ui output element. This will show the calculations\n    # made in the server back to the user.\n    ui.output_text_verbatim(\"greeting\"),\n)\n\ndef server(input, output, session):\n    #3 Update the server with a function that handles the text response.\n    @output # use the output decorator to mark this function\n    @render.text # also need to ensure we use the correct render decorator\n    def greeting():\n        \"\"\"\n        This function will take the output of the ui.input_text() element,\n        format the string in a polite sentence and format it as an HTML\n        output for the ui to show.\n        \"\"\"\n        return f\"Hi {input.name_entry()}, welcome to Python Shiny.\"\n\napp = App(app_ui, server)\n\n\nThere’s quite a lot going on in the above code chunk. Let’s start with the decorators @output & @render.text:\n\n@output: Any function marked with this decorator will have its returned value made available to the user interface. Notice that in the line ui.output_text_verbatim(\"greeting\") we are able to call on the values of the server’s greeting() function that we marked as an @output.\n@render.text: This tells Shiny what type of output to handle. Is it text, a chart (@render.plot) or something more fancy, like dynamically rendered ui (@render.ui). These output types all have their corresponding output functions to use in the ui. Here we called ui.output_text_verbatim().\nCalling the wrong ui-side function may not result in an error, but can have unexpected results, such as your text disappearing from your app. Keep an eye out for that if things aren’t working - are you using the correct combination of render in the server with output_... in the ui?\n\nDid you notice anything off-putting about the above code? Yes, too many comments but please indulge me. Functions in the server and ui are passing values back and forth. That can be a bit overwhelming to get your head around when you’re new to what’s known as ‘event-driven programming’. All that means is that the program needs to respond to some action taken by the user. The syntax in which you reference the functions is a bit inconsistent to my mind. Let’s take a closer look:\nIf I mark some function make_plot() in the server as an @output and then wish to call on its value within the ui, I need to use ui.output_plot(\"make_plot\"). Notice the lack of brackets following the function name \"make_plot\". Getting this wrong will result in a ValueError. Forgetting to wrap the function reference in a string will result in a NameError.\nNow in the other direction, perhaps we have a numeric input passing integer values from the user to the server. We’ll give the slider widget the id=\"int_slider\". Now when we want to use the value of this slider on the server-side, we use a different syntax:\ndef print_selection():\n    n = int_slider()\n    return f\"You chose {n}!\"\nNotice this time, we include brackets after our call to the widget id: n = int_slider(). Weird, right? Getting this wrong may result in unexpected behaviours. Keep an eye out for this. Also, wrapping server id references in speech marks results in unexpected behaviours, but not necessarily errors.\nIf I haven’t lost you yet, well done! Debugging applications can be a very frustrating process - part intuition earned from hours of Shiny debugging, part Stack Overflow and part coping mechanisms. I’ll cover some of those in the Tips section.\n\n\nTry modifying the app provided in the previous examples to repeat the greeting a number of times specified by the user.\n\n\n\n\n\n\nHints. Click to expand if needed.\n\n\n\n\n\n\nYou will need to include a UI input that will collect numbers from the user.\nUpdate the greeting() function to return multiples of the greeting string.\nExplore the other text output functions to avoid the message being truncated.\nIf you’re stuck, click on “Show the code” to see a solution.\n\n\n\n\n\n\n\n\n\nShow the code\nfrom shiny import ui, App, render\n\napp_ui = ui.page_fluid(\n    ui.input_text(\n        id=\"name_entry\",\n        label=\"Please enter your name\",\n        placeholder=\"Your name here\"\n        ),\n    # 1 update the UI with a way of taking numbers from the user. Here I use a\n    # slider, but a numeric input or even radio buttons would also work.\n    ui.input_slider(\n        id=\"n_greetings\",\n        label=\"number of greetings\", value=1, min=1, max=10, step=1),\n\n    #2 Change to output_text instead of output_text_verbatim, which uses strict\n    # rules for word wrapping and would hide most of a long greeting.\n    ui.output_text(\"greeting\"),\n    ui.tags.br()\n)\n\ndef server(input, output, session):\n    @output\n    @render.text\n    def greeting():\n        \"\"\"\n        This function will take the output of the ui.input_text() element,\n        format the string in a polite sentence and format it as an HTML\n        output for the ui to show.\n        \"\"\"\n        # multiply the greeting string by the number of times the user asked\n        return f\"Hi {input.name_entry()}, welcome to Python Shiny.\" * input.n_greetings()\n\napp = App(app_ui, server)\n\n\n\n\n\n\nOne final adjustment to this app. When you’re typing a name into the text input field, there’s a bit of a race going on. Can you type faster than the server can render the text? This may not be what you want. In fact, you may require a bunch of selections to be made prior to calculating anything in the server. We can use methods to interrupt and isolate elements of the server. In effect, we can tell any of our server functions to hang fire until a certain condition is met. In this example, we’ll try out perhaps the simplest way of achieving this, enter the ui.input_action_button().\n\n\n\n\n\nShow the code\n#1 Import the reactive module from Shiny\nfrom shiny import ui, render, App, reactive\n\napp_ui = ui.page_fluid(\n    ui.input_text(\n        id=\"name_entry\",\n        label=\"Please enter your name\",\n        placeholder=\"Your name here\"\n        ),\n    #2 add an action button to the ui, much like we did with the text input\n    ui.input_action_button(id=\"go_button\", label=\"Click to run...\"),\n    # add some visual separation to the text output\n    ui.tags.br(),\n    ui.tags.br(),\n\n    ui.output_text_verbatim(\"greeting\"),\n)\n\ndef server(input, output, session):\n    #3 add an additional mark below the others\n    @output\n    @render.text\n    @reactive.event(input.go_button)\n    def greeting():\n        return f\"Hi {input.name_entry()}, welcome to Python Shiny.\"\n\n# This is a Shiny.App object. It must be named `app`.\napp = App(app_ui, server)\n\n\nYou should now see that an input button has appeared and the sentence won’t get printed out until you press it.\nAlso notice that the inconsistency in how to refer to functions on the other side of the ui:server divide rears its head once more. All in the server, when we want to use the values returned by the text input, we use the syntax input.name_entry(). When we want to use the action button in the reactive decorator, we have to use input.go_button - no parenthesis! The docs describe this as when you need to access the returned value versus when you need to call the function. This does make sense but can introduce some cognitive conflict while you are working with Shiny. I hope by version 1.0 the development team can find a way to simplify things.\nI also included some visual separation between elements in the ui by using ui.tags.br(). If you know a little HTML, you may get excited at that. You can access all the typical HTML tags in this way:\n\n\n\n\n\nShow the code\nfrom shiny import ui, App, render\n\napp_ui = ui.page_fluid(\n    ui.tags.h1(\"A level 1 heading\"),\n    ui.tags.h2(\"A level 2 heading\"),\n    ui.tags.br(),\n    ui.tags.p(\"Some text \", ui.tags.strong(\"in bold...\"))\n\n)\n\ndef server(input, output, session):\n    return None\n\napp = App(app_ui, server)\n\n\n\n\nDo you know enough markdown syntax to convert the ui below from HTML tags into markdown? This will greatly simplify the code. You will need to use ui.markdown(\"\"\"some multiline markdown\"\"\") to achieve that.\n\n\n\n\n\n\nHints. Click to expand if needed.\n\n\n\n\n\n\nYou can use this markdown cheatsheet to help.\nIf you’re stuck, click on “Show the code” to see an example solution.\n\n\n\n\n\n\n\n\n\nShow the code\n#1 Import the reactive module from Shiny\nfrom shiny import ui, render, App, reactive\n\napp_ui = ui.page_fluid(\n\n    ui.markdown(\n        \"\"\"\n        # Hello Python Shiny!\n        This **simple application** will print you a greeting.\n\n        1. Enter your name\n        2. Click run\n\n        Please visit [some website](https://datasciencecampus.github.io/)\n        for more information\n        ***\n        \"\"\"),\n    \n    ui.input_text(\n        id=\"name_entry\",\n        label=\"Please enter your name\",\n        placeholder=\"Your name here\"\n        ),\n    #2 add an action button to the ui, much like we did with the text input\n    ui.input_action_button(id=\"go_button\", label=\"Click to run...\"),\n    # add some visual separation to the text output\n    ui.tags.br(),\n    ui.tags.br(),\n\n    ui.output_text_verbatim(\"greeting\"),\n)\n\ndef server(input, output, session):\n    #3 add an additional mark below the others\n    @output\n    @render.text\n    @reactive.event(input.go_button)\n    def greeting():\n        return f\"Hi {input.name_entry()}, welcome to Python Shiny.\"\n\n# This is a Shiny.App object. It must be named `app`.\napp = App(app_ui, server)\n\n\nSo there you have it. A very basic application that can be used to print out some simple messages to your user. This is of course a trivial app in order to keep things basic for the purposes of this blog. If you’d like to investigate what’s possible with Shiny, I’d suggest taking a peek through the Posit docs examples and the Python Shiny gallery. In the next section I’ll go over some tips that may help with common pitfalls I’ve encountered while working in Shiny."
  },
  {
    "objectID": "blogs/02-getting-started-pyshiny.html#getting-to-grips-with-python-shiny.",
    "href": "blogs/02-getting-started-pyshiny.html#getting-to-grips-with-python-shiny.",
    "title": "Let’s Build a Basic Python Shiny App.",
    "section": "",
    "text": "Source: https://www.wallpaperflare.com/. Creative Commons License.\n\n\nThis tutorial is intended for those who are already familiar with Python, but may be less familiar with dashboarding and Shiny in Python. It may also be of interest to those who are well-versed in RShiny and would like to see how it has been implemented in Python.\nThis is a light-weight, introductory Python Shiny tutorial. No installation of software is required, other than a web-browser (which you must already have) and a willingness to experiment. We will use the shinylive service to display the application that we write and steadily add to a basic app, discussing some of the concepts as we go. Finally, let’s regroup and reflect on some coping techniques for when you begin writing your own Python Shiny apps.\nThis tutorial will not attempt to reproduce any of Posit’s documentation, which is rather excellent so please check that out. Also, if you would prefer a conceptual treatment of Python Shiny, please see my blog on The Current Stateof Python Shiny.\n\n\n\n\n\n\nHow to…\n\n\n\nFeel free to tinker with the code in the following example apps and then press play in the top-right hand corner of the console interface. Don’t worry - you won’t break anything important. To reset the code, simply refresh your web page.\nIf the app doesn’t launch, you’ll see some spinning grey hexagons that never go away . This is likely to be a problem with permissions in your browser. But you can click on the collapsible code block below the app windows and copy the code to an app.py file on your computer. If you have python and python shiny installed, you should be good to go.\n\n\n\n\nBelow is a really minimal app that doesn’t do very much at all. The python code is presented on the left. The interactive app is presented on the right. You can type into the app’s text field, and that’s about it for now.\n\n\n\n\n\nShow the code\n#1 Import modules to help us build our app\nfrom shiny import ui, App\n\n#^putting things above the app means they can be shared between your ui and server\n\napp_ui = ui.page_fluid(\n  #2 all of the elements you wish to show your user should go within the ui\n    ui.input_text(\n        id=\"name_entry\",\n        label=\"Please enter your name\",\n        placeholder=\"Your name here\"\n        )\n)\n\ndef server(input, output, session):\n  #3 this is where your app logic should go. So far, not much...\n    return None\n  \n# Finally - this bit packages up our ui and server. Super important - it must\n# be named `app`.\n\n\nYou’ll see that the code defines an app_ui object, which is a Shiny ui instance. Within that ui.page_fluid() function, we can specify all the elements of the app that we would like to present to our users.\n\n\n\n\n\n\nOn Users…\n\n\n\nThere are only two industries that call their customers “users”: illegal drugs and software – Edward Tufte\n\n\nSo far, only one simple ui element has been defined. The humble text input ui.input_text() which allows our users to place their own text into a text field.\nNotice that in Python, all the inputs begin with input.... There’s ui.input_text() as we’ve seen, but there’s lots more. ui.input_date(), ui.input_file() and ui.input_slider to name a few. This consistent syntax approach is a subtle improvement over RShiny and makes it so much easier to work with the vast array of widgets without having to remember them all. If you’re working in a modern editor such as Visual Studio Code, simply typing ui.input will remind you of all the options available to you. For those not working in a nice GUI like VSCode, a Shiny cheatsheet may be useful, though note that at the time of writing I could only find R-flavoured ones…\nAll ui input elements start with the same 2 arguments, id and label:\n\nid: The internal name of the input. What does that mean? Call it what you like. Whatever you choose, be aware that when you want to use the values from the text input to do something in the server, it’s this name that you will need to reference.\nlabel: A short piece of text that prompts your user to do something. This will be displayed in your ui above the input element.\n\n\n\n\nUnfortunately, so far our app doesn’t actually do much. Typing into the empty text field yields no result. That’s because right now, our server function simply returns None. Let’s resolve this.\n\n\n\n\n\nShow the code\n#1 update the import statement to include `render` module\nfrom shiny import ui, App, render\n\napp_ui = ui.page_fluid(\n    ui.input_text(\n        id=\"name_entry\",\n        label=\"Please enter your name\",\n        placeholder=\"Your name here\"\n        ),\n    #2 Include a ui output element. This will show the calculations\n    # made in the server back to the user.\n    ui.output_text_verbatim(\"greeting\"),\n)\n\ndef server(input, output, session):\n    #3 Update the server with a function that handles the text response.\n    @output # use the output decorator to mark this function\n    @render.text # also need to ensure we use the correct render decorator\n    def greeting():\n        \"\"\"\n        This function will take the output of the ui.input_text() element,\n        format the string in a polite sentence and format it as an HTML\n        output for the ui to show.\n        \"\"\"\n        return f\"Hi {input.name_entry()}, welcome to Python Shiny.\"\n\napp = App(app_ui, server)\n\n\nThere’s quite a lot going on in the above code chunk. Let’s start with the decorators @output & @render.text:\n\n@output: Any function marked with this decorator will have its returned value made available to the user interface. Notice that in the line ui.output_text_verbatim(\"greeting\") we are able to call on the values of the server’s greeting() function that we marked as an @output.\n@render.text: This tells Shiny what type of output to handle. Is it text, a chart (@render.plot) or something more fancy, like dynamically rendered ui (@render.ui). These output types all have their corresponding output functions to use in the ui. Here we called ui.output_text_verbatim().\nCalling the wrong ui-side function may not result in an error, but can have unexpected results, such as your text disappearing from your app. Keep an eye out for that if things aren’t working - are you using the correct combination of render in the server with output_... in the ui?\n\nDid you notice anything off-putting about the above code? Yes, too many comments but please indulge me. Functions in the server and ui are passing values back and forth. That can be a bit overwhelming to get your head around when you’re new to what’s known as ‘event-driven programming’. All that means is that the program needs to respond to some action taken by the user. The syntax in which you reference the functions is a bit inconsistent to my mind. Let’s take a closer look:\nIf I mark some function make_plot() in the server as an @output and then wish to call on its value within the ui, I need to use ui.output_plot(\"make_plot\"). Notice the lack of brackets following the function name \"make_plot\". Getting this wrong will result in a ValueError. Forgetting to wrap the function reference in a string will result in a NameError.\nNow in the other direction, perhaps we have a numeric input passing integer values from the user to the server. We’ll give the slider widget the id=\"int_slider\". Now when we want to use the value of this slider on the server-side, we use a different syntax:\ndef print_selection():\n    n = int_slider()\n    return f\"You chose {n}!\"\nNotice this time, we include brackets after our call to the widget id: n = int_slider(). Weird, right? Getting this wrong may result in unexpected behaviours. Keep an eye out for this. Also, wrapping server id references in speech marks results in unexpected behaviours, but not necessarily errors.\nIf I haven’t lost you yet, well done! Debugging applications can be a very frustrating process - part intuition earned from hours of Shiny debugging, part Stack Overflow and part coping mechanisms. I’ll cover some of those in the Tips section.\n\n\nTry modifying the app provided in the previous examples to repeat the greeting a number of times specified by the user.\n\n\n\n\n\n\nHints. Click to expand if needed.\n\n\n\n\n\n\nYou will need to include a UI input that will collect numbers from the user.\nUpdate the greeting() function to return multiples of the greeting string.\nExplore the other text output functions to avoid the message being truncated.\nIf you’re stuck, click on “Show the code” to see a solution.\n\n\n\n\n\n\n\n\n\nShow the code\nfrom shiny import ui, App, render\n\napp_ui = ui.page_fluid(\n    ui.input_text(\n        id=\"name_entry\",\n        label=\"Please enter your name\",\n        placeholder=\"Your name here\"\n        ),\n    # 1 update the UI with a way of taking numbers from the user. Here I use a\n    # slider, but a numeric input or even radio buttons would also work.\n    ui.input_slider(\n        id=\"n_greetings\",\n        label=\"number of greetings\", value=1, min=1, max=10, step=1),\n\n    #2 Change to output_text instead of output_text_verbatim, which uses strict\n    # rules for word wrapping and would hide most of a long greeting.\n    ui.output_text(\"greeting\"),\n    ui.tags.br()\n)\n\ndef server(input, output, session):\n    @output\n    @render.text\n    def greeting():\n        \"\"\"\n        This function will take the output of the ui.input_text() element,\n        format the string in a polite sentence and format it as an HTML\n        output for the ui to show.\n        \"\"\"\n        # multiply the greeting string by the number of times the user asked\n        return f\"Hi {input.name_entry()}, welcome to Python Shiny.\" * input.n_greetings()\n\napp = App(app_ui, server)\n\n\n\n\n\n\nOne final adjustment to this app. When you’re typing a name into the text input field, there’s a bit of a race going on. Can you type faster than the server can render the text? This may not be what you want. In fact, you may require a bunch of selections to be made prior to calculating anything in the server. We can use methods to interrupt and isolate elements of the server. In effect, we can tell any of our server functions to hang fire until a certain condition is met. In this example, we’ll try out perhaps the simplest way of achieving this, enter the ui.input_action_button().\n\n\n\n\n\nShow the code\n#1 Import the reactive module from Shiny\nfrom shiny import ui, render, App, reactive\n\napp_ui = ui.page_fluid(\n    ui.input_text(\n        id=\"name_entry\",\n        label=\"Please enter your name\",\n        placeholder=\"Your name here\"\n        ),\n    #2 add an action button to the ui, much like we did with the text input\n    ui.input_action_button(id=\"go_button\", label=\"Click to run...\"),\n    # add some visual separation to the text output\n    ui.tags.br(),\n    ui.tags.br(),\n\n    ui.output_text_verbatim(\"greeting\"),\n)\n\ndef server(input, output, session):\n    #3 add an additional mark below the others\n    @output\n    @render.text\n    @reactive.event(input.go_button)\n    def greeting():\n        return f\"Hi {input.name_entry()}, welcome to Python Shiny.\"\n\n# This is a Shiny.App object. It must be named `app`.\napp = App(app_ui, server)\n\n\nYou should now see that an input button has appeared and the sentence won’t get printed out until you press it.\nAlso notice that the inconsistency in how to refer to functions on the other side of the ui:server divide rears its head once more. All in the server, when we want to use the values returned by the text input, we use the syntax input.name_entry(). When we want to use the action button in the reactive decorator, we have to use input.go_button - no parenthesis! The docs describe this as when you need to access the returned value versus when you need to call the function. This does make sense but can introduce some cognitive conflict while you are working with Shiny. I hope by version 1.0 the development team can find a way to simplify things.\nI also included some visual separation between elements in the ui by using ui.tags.br(). If you know a little HTML, you may get excited at that. You can access all the typical HTML tags in this way:\n\n\n\n\n\nShow the code\nfrom shiny import ui, App, render\n\napp_ui = ui.page_fluid(\n    ui.tags.h1(\"A level 1 heading\"),\n    ui.tags.h2(\"A level 2 heading\"),\n    ui.tags.br(),\n    ui.tags.p(\"Some text \", ui.tags.strong(\"in bold...\"))\n\n)\n\ndef server(input, output, session):\n    return None\n\napp = App(app_ui, server)\n\n\n\n\nDo you know enough markdown syntax to convert the ui below from HTML tags into markdown? This will greatly simplify the code. You will need to use ui.markdown(\"\"\"some multiline markdown\"\"\") to achieve that.\n\n\n\n\n\n\nHints. Click to expand if needed.\n\n\n\n\n\n\nYou can use this markdown cheatsheet to help.\nIf you’re stuck, click on “Show the code” to see an example solution.\n\n\n\n\n\n\n\n\n\nShow the code\n#1 Import the reactive module from Shiny\nfrom shiny import ui, render, App, reactive\n\napp_ui = ui.page_fluid(\n\n    ui.markdown(\n        \"\"\"\n        # Hello Python Shiny!\n        This **simple application** will print you a greeting.\n\n        1. Enter your name\n        2. Click run\n\n        Please visit [some website](https://datasciencecampus.github.io/)\n        for more information\n        ***\n        \"\"\"),\n    \n    ui.input_text(\n        id=\"name_entry\",\n        label=\"Please enter your name\",\n        placeholder=\"Your name here\"\n        ),\n    #2 add an action button to the ui, much like we did with the text input\n    ui.input_action_button(id=\"go_button\", label=\"Click to run...\"),\n    # add some visual separation to the text output\n    ui.tags.br(),\n    ui.tags.br(),\n\n    ui.output_text_verbatim(\"greeting\"),\n)\n\ndef server(input, output, session):\n    #3 add an additional mark below the others\n    @output\n    @render.text\n    @reactive.event(input.go_button)\n    def greeting():\n        return f\"Hi {input.name_entry()}, welcome to Python Shiny.\"\n\n# This is a Shiny.App object. It must be named `app`.\napp = App(app_ui, server)\n\n\nSo there you have it. A very basic application that can be used to print out some simple messages to your user. This is of course a trivial app in order to keep things basic for the purposes of this blog. If you’d like to investigate what’s possible with Shiny, I’d suggest taking a peek through the Posit docs examples and the Python Shiny gallery. In the next section I’ll go over some tips that may help with common pitfalls I’ve encountered while working in Shiny."
  },
  {
    "objectID": "blogs/02-getting-started-pyshiny.html#tips.",
    "href": "blogs/02-getting-started-pyshiny.html#tips.",
    "title": "Let’s Build a Basic Python Shiny App.",
    "section": "Tips.",
    "text": "Tips.\n\nShiny for Python VSCode Extension.\nThe Shiny for Python extension is a convenient way to launch Python Shiny apps. It adds a ‘Run Shiny App’ button to the VS Code interface, allowing for options to serve the app locally within a dedicated VS Code viewer window, or alternatively launch the app directly within your default web browser.\nIn order to run your application with this extension, you must ensure your app file is saved as app.py, otherwise the run button will not recognise that the currently selected document is a Shiny app.\n\n\nHeader Accessibility Adjustment.\nA big shoutout to Utah State University for making their fantastic suite of web accessibility-checking tools open source. These tools make checking the accessibility of your web products much easier. Simply visit the Web Accessibility Evaluation Tool (WAVE) and enter a url under “Web page address:” and press return. The site will launch a helpful overlay on top of your specified url, highlighting accessibility alerts, warnings and features. There is also a sidebar helpfully explaining why the various alerts are important and what can be done to resolve them.\nUnless you have managed to host a Shiny application on a service such as shinyapps.io, unfortunately you won’t have a url to pass to WAVE. Working locally on your machine, your locally hosted app interface will launch with a url like: http://localhost:… There is another way to use WAVE to check localhost sites. Using the WAVE browser extensions will allow you to launch the WAVE tool within any of your browser windows. This would allow you to run these checks locally on your machine while also ensuring that your app looks good on Chrome, Firefox or Edge. When checking basic Python Shiny apps for accessibility, one of the common accessibility errors you will encounter will be:\n\n\n\n\n\n\nLanguage missing or invalid!\n\n\n\nThe language of the document is not identified or a lang attribute value is invalid.\n\n\nThis means a screen reader may not detect the language of the website content and may not work properly. The ideal scenario would be that Shiny would ask you to specify the language of the application that you are working in at the point where you create the application. It’s a straightforward fix though. We can include some tags at the top of our ui that will update the web page content with the required information:\n\n\n\n\n\nShow the code\nfrom shiny import ui, render, App, reactive\n\napp_ui = ui.page_fluid(\n    # Add a header and specify the language and title.\n    ui.tags.header(ui.tags.html(lang=\"en\"), ui.tags.title(\"A Really Basic App\")),\n\n    ui.input_text(\n        id=\"name_entry\",\n        label=\"Please enter your name\",\n        placeholder=\"Your name here\"\n        ),\n    ui.input_action_button(id=\"go_button\", label=\"Click to run...\"),\n    ui.tags.br(),\n    ui.tags.br(),\n\n    ui.output_text_verbatim(\"greeting\"),\n)\n\ndef server(input, output, session):\n    @output\n    @render.text\n    @reactive.event(input.go_button)\n    def greeting():\n        return f\"Hi {input.name_entry()}, welcome to Python Shiny.\"\n\napp = App(app_ui, server)\n\n\n\n\nMissing Commas.\nOne of the more frustrating aspects of debugging Shiny applications, particularly as the application grows, is that a single misplaced comma can completely break your application. The thing to look out for here is when you run your app and you get the unexpected SyntaxError: invalid syntax error. I recall this being a real headache when I was learning RShiny, so much so that I would leave a little comment after each comma reminding me of which element of the code was being closed within the preceding bracket.\nThe Python errors are really helpful. They not only point to a problem with the syntax, but they identify the line number in the app where the first instance of this issue was encountered.\n\n\nDebugging Errors.\nAt times it can be unclear why errors are being raised and it becomes important to investigate intermediate values that are being calculated in the server. Your usual python debugging tools may not work with Python Shiny. Shiny is event-driven and the reactive flow and order of the object definitions in your scripts are treated a bit differently. Without a tool like R’s Reactlog package, this is currently quite tricky to do in Python. The main coping mechanism available at the moment is to include some text outputs in the ui, paired with render text functions in the server. You can go ahead and use these elements to helpfully print out intermediate values such as DataFrame column names, data types etc and then comment them out when they’re no longer needed. Examining these intermediate values from within your ui is often the way to go when you can’t understand the root cause of your problem.\n\n\n\n\n\n\nMake a Reprex!\n\n\n\nOne more approach to consider is to try to isolate your problem.\n\n\nSometimes it can be hard to build a mental picture of all the moving elements under the hood in your server, and how they may be unexpectedly interacting with each other. The problem you’re encountering may be due to these complex interactions in your server. Simply commenting out the code not directly related to the issue you are experiencing helps to triangulate the source of the issue within your reactive model. This is also the first step towards producing a reprex - a reproducible example. These should be as minimal as possible and are very helpful to start getting to the root of a programming problem.\n\n\nSpecifying Working Directory.\nThis is more of a consideration for deployment to a service such as shinyapps.io than something you tend to encounter while learning the ropes. And you likely won’t encounter this issue if your app.py file is located in the top level of your project folder (also known as the project root). If your app is not in the root of the project folder, you may wish to include this snippet of code before you define your Shiny ui:\nos.chdir(os.path.dirname(os.path.realpath(__file__)))\nThis ensures that the working directory is set to that of the app.py file when it runs. If you encounter pandas errors complaining about FileExistsError when you deploy your app to shinyapps.io but not when you locally run your application, this may be the fix you need. Also something to consider if your app is styled correctly locally but not when you deploy. Potentially a relative path to a dedicated stylesheet has broken.\nOne more thing on deploying your app - if you do intend to host your app for others to use, I cannot emphasise this enough:\n\n\n\n\n\n\nDeploy Your App Early!\n\n\n\n\n\n\nDeployment of applications is not a straight forward, half an hour job. There are often inconsistencies to iron out between the environment you developed the app in and the server that will be running the remote app for your users. Deploy your app early when it is basic and you can catch these inconsistencies as you go. Or don’t and ignore the pile of technical debt your project is accruing. These are your choices."
  },
  {
    "objectID": "blogs/02-getting-started-pyshiny.html#in-review.",
    "href": "blogs/02-getting-started-pyshiny.html#in-review.",
    "title": "Let’s Build a Basic Python Shiny App.",
    "section": "In Review.",
    "text": "In Review.\nWe have written a very basic application that is not much use beyond a basic tutorial. Although we have successfully demonstrated how to have the ui and server elements of a Shiny application talk to one another. We’ve captured dynamic inputs provided by the user and presented them back within the interface. And we have been able to pause the server execution until the user asks for a response. That’s not a bad start at all. But so much more than this can be achieved in Python Shiny. A good place to go for inspiration is the Posit Example Gallery. And if you’d like to understand a little more about how Python Shiny fits into the Python dashboarding toolkit, please check out my other blog on The Current State of Python Shiny.\nHappy dashboarding!"
  },
  {
    "objectID": "music-reviews/index.html",
    "href": "music-reviews/index.html",
    "title": "Music Reviews (Pending)",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "book-reviews/01-deep-work.html",
    "href": "book-reviews/01-deep-work.html",
    "title": "Deep Work.",
    "section": "",
    "text": "Fanal Forest, Madeira. Wikimedia Creative Commons."
  },
  {
    "objectID": "book-reviews/01-deep-work.html#introduction",
    "href": "book-reviews/01-deep-work.html#introduction",
    "title": "Deep Work.",
    "section": "Introduction",
    "text": "Introduction\nAt the date of writing this review, Deep Work scores an average of 4.19 / 5.00 across over 141k ratings on goodreads. Also nominated by the same website for Best Nonfiction, 2016. Awarded gongs for best book best seller in business & leadership by Amazon & the Wall Street Journal.\nThis book comes personally recommended to me by a close colleague and was read on holidays during some much needed down time in the Summer of 2023."
  },
  {
    "objectID": "book-reviews/01-deep-work.html#summary",
    "href": "book-reviews/01-deep-work.html#summary",
    "title": "Deep Work.",
    "section": "Summary",
    "text": "Summary"
  },
  {
    "objectID": "book-reviews/01-deep-work.html#analysis-and-evaluation",
    "href": "book-reviews/01-deep-work.html#analysis-and-evaluation",
    "title": "Deep Work.",
    "section": "Analysis and Evaluation",
    "text": "Analysis and Evaluation"
  },
  {
    "objectID": "book-reviews/01-deep-work.html#personal-reflection",
    "href": "book-reviews/01-deep-work.html#personal-reflection",
    "title": "Deep Work.",
    "section": "Personal Reflection",
    "text": "Personal Reflection"
  },
  {
    "objectID": "book-reviews/01-deep-work.html#comparisons",
    "href": "book-reviews/01-deep-work.html#comparisons",
    "title": "Deep Work.",
    "section": "Comparisons",
    "text": "Comparisons"
  },
  {
    "objectID": "book-reviews/01-deep-work.html#recommendation",
    "href": "book-reviews/01-deep-work.html#recommendation",
    "title": "Deep Work.",
    "section": "Recommendation",
    "text": "Recommendation"
  },
  {
    "objectID": "book-reviews/01-deep-work.html#conclusion",
    "href": "book-reviews/01-deep-work.html#conclusion",
    "title": "Deep Work.",
    "section": "Conclusion",
    "text": "Conclusion"
  },
  {
    "objectID": "book-reviews/index.html",
    "href": "book-reviews/index.html",
    "title": "Book Reviews",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nDeep Work.\n\n\n1 min\n\n\n\nSelf-Help\n\n\nProductivity\n\n\nBusiness\n\n\nPsychology\n\n\nPhilosophy\n\n\n\nA review of Cal Newport’s much lauded productivity how to guide.\n\n\n\nRich Leyshon.\n\n\nAug 29, 2023\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Another Nerd Blog.",
    "section": "",
    "text": "A site to store blogs about programming concepts, software development and data science. Generally things that future me will be thankful that I’ve recorded these things somewhere."
  },
  {
    "objectID": "index.html#intro",
    "href": "index.html#intro",
    "title": "Another Nerd Blog.",
    "section": "",
    "text": "A site to store blogs about programming concepts, software development and data science. Generally things that future me will be thankful that I’ve recorded these things somewhere."
  },
  {
    "objectID": "index.html#site-overview",
    "href": "index.html#site-overview",
    "title": "Another Nerd Blog.",
    "section": "Site Overview",
    "text": "Site Overview\n\nBlogs : Explanations, tutorials, how-to guides. All blogs are regarding technical subjects and are categorised according to the excellent diataxis framework.\n\n\n\n\n\n© Daniele Procida.\n\n\n\nMusic Reviews : I listen to strictly non-verbal music when programming. This was a habit that I developed while working within a busy office environment. Instrumental music of several genres has helped me efficiently establish a state of mental flow required for deep concentration. I’ll include reviews of some of my favourite albums here, categorised by genre.\nBook Reviews : Much of my casual reading is non-fiction tangential to programming. I’ll review material here that I have found to be supportive of my work in various aspects, categorised by genre."
  },
  {
    "objectID": "index.html#about-me",
    "href": "index.html#about-me",
    "title": "Another Nerd Blog.",
    "section": "About Me",
    "text": "About Me\n\nI am a Senior Data Scientist at the Office for National Statistics Data Science Campus. I enjoy programming & automation and tend to work to the standards outlined in Quality Assurance of Code for Analysis & Research. For more detail regarding my professional experience, please follow this link to my resumé. And to collaborate with me, here’s my GitHub profile."
  }
]