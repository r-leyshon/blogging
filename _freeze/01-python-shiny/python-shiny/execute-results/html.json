{
  "hash": "06994a2f9a6b822a7da7ffd7631b72af",
  "result": {
    "markdown": "---\ntitle: \"Python for Shiny\"\nauthor: \"Rich Leyshon.\"\ntoc: true\nformat:\n  html:\n    mermaid:\n      theme: default\n---\n\n## Python for Shiny is now a thing...\n\n<figure class=center>\n  <img src=/./www/01-python-shiny/shiny-python.png alt=\"AI-generated drawing of a shiny python.\">\n  <figcaption>[DALL.E prompt](https://huggingface.co/spaces/dalle-mini/dalle-mini): python logo golden Sparkling glittery bokeh bright.</figcaption>\n</figure>\n\n[Python Shiny](https://pypi.org/project/shiny/) celebrates its first year\nanniversary on PyPi in July 2023. In case that needs further qualification, this\nis the Python-native implementation of the beloved RShiny dashboarding package\nthat has been available in the R programming framework for over a decade now. \nPython Shiny has benefited from the experience that the developers at\n[Posit](https://posit.co/) have gained in building its more mature,\nR-flavoured sibling.\n\nPython Shiny has experienced what I would describe as an accelerated evolution\nand has the potential to become a front runner in production-grade\napplications. Mainly because it adheres to an evaluation strategy which is a bit\n'un-pythonic'. Shiny introduces dashboarding with lazy evaluation, meaning that\nelements of your code will only be evaluated when there is a need to do so. This\nis not always a great idea, particularly for standard scripting purposes. But it\ndoes make event-drive applications more efficient and scalable. More on\n[Posit's take on the USP of Python Shiny here](https://posit.co/blog/why-shiny-for-python/).\n\nLet's consider the following example in Python:\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# In Python\ntry:\n  def failing_print(param_a=\"Am I lazy?\", param_b=absolutely_not):\n    print(param_a)\nexcept NameError:\n  print(\"Python woud not allow me to define this function.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPython woud not allow me to define this function.\n```\n:::\n:::\n\n\nStrict (also known as eager) evaluation in Python has triggered an error. I've\nhad to catch the error above with the try/except clause in order to render this\nwebsite. Even though `failing_print()` never calls on `param_b`, Python checks\nthat the default value of that parameter exists on definition of the function.\n\nLet us now compare to the situation in R.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# In R\npassing_print <- function(param_a = \"Am I lazy?\", param_b = yes_you_are){\n  print(param_a)\n}\nprint(paste(\"Does `yes_you_are` exist? : \", exists(\"yes_you_are\")))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Does `yes_you_are` exist? :  FALSE\"\n```\n:::\n\n```{.r .cell-code}\npassing_print()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Am I lazy?\"\n```\n:::\n:::\n\n\nNo exception was raised although the value `yes_you_are` has not been defined.\n\nLazy evaluation in Python Shiny minimises the work the application needs to\nundertake. Values in the app backend will only be re-evaluated as they are\nneeded and contrasts with more pythonic approaches to dashboarding, such as the\ncase with the [streamlit package](https://streamlit.io/).\n\n<br>\n\n***\n## An Example Python Shiny App\n\nThis application is written in Python and served with a free [shinyapps.io](https://www.shinyapps.io/)\naccount. I made the app to explore the quality of the spatial data available\nwithin [Open Street Map](https://www.openstreetmap.org/) (OSM) data for certain\nurban areas. Open Street Map is an open-source, community-maintained source of\ntransport network data. The files also contain other spatial features, such as\nlanduse polygons. The quality of this data varies by location, as you may find\nin the app. \n\nThe application is pretty straight forward. It uses pandas to read in some\npre-prepared data tables from a data folder. These files were prepared with\na python package called [pyrosm](https://pyrosm.readthedocs.io/en/latest/).\nPyrosm is a useful application for ingesting, assessing & visualising OSM data.\nSelecting a city from the dropdowns then clicking the \"Go\" button will read the\ncorrect table from this little database, then using matplotlib, it visualises\nthe selected spatial features. The app also presents some simple summary\nstatistics in tables at the bottom of the page. \n\nThe preparation of the data files is not strictly necessary. You can serve an \napp and have it make external connections to data services to ingest data. In\nthis instance, I chose to pre-process the data as it helped to improve the\nperformance of the app. Even so, selecting London or Leeds can result in some\nwait times, so please be aware of this. Options for improving the performance \nfurther could include parallel processing, though that is not implemented here\nand is beyond the scope of this little example.\n\nIf you'd like to take a look at the application code and have a GitHub account,\n[you can access it here](https://github.com/r-leyshon/pyrosm-experiments/blob/main/pyrosm-cities-app/app.py).\n\n<div class=centerdiv>\n  <iframe src=\"https://richleysh84.shinyapps.io/pyrosm-cities-app/\" title=\"Python Shiny Open Street Map Application\" style=\"border:0.3em solid lightgray\" align=center></iframe>\n<div>\n\n\n***\n\n\n## So what does a Shiny project look like?\n\n\n<div class=\"center_diagram\">\n\n\n```{mermaid}\n%%linkStyle default stroke: blue\n\nflowchart TD\n  user[\"User\"]\n  subgraph Application\n  server[\"Server\n  - Executes python code.\n  - Processes data.\n  - Translates outputs into HTML.\n  \"]\n  ui[\"User Interface\n  - Displays input widgets.\n  - Displays rendered server outputs.\n  - Can be adjusted with HTML & CSS.\"]\n  db[(\"Data\")]\n  end\n  user -->|Input Values| ui <-->|Dynamic Values| server\n  db -->|Read| server\n\nlinkStyle default stroke-width:1px,color:blue;\n\n```\n\n\n</div>\n<br>\n\nEach Shiny application comes in two distinct sections. The user interface is the frontend of the application, where a person engages with elements of a web page in order to control visuals, filter tables and so on. The web page translates Python code into HyperText Markup Language (HTML). HTML can be interpreted by a web browser in order to present the user with a structured web page. But in order to present an attractive webpage, this HTML foundation needs to be styled. So Cascading Style Sheets (CSS) are used to add decoration to the foundation established by HTML.\n\nHaving an attractive webpage that does not do something when you click around on it, enter your credit card details or click 'decline' on cookie consent notices would be rather pointless. This is where a web developer would use the language of the browser to work with data hehind that pretty frontend. That language is JavaScript and it's remarkably versatile and intimidating to many data-types. \n\nSo to make a functioning app, you need to learn 3 distinct languages. For this reason, packages such as Shiny, Dash and Streamlit have become very popular with analysts working within open-source programming frameworks such as Python and R. They allow the creation of applications while adhering to the syntax that an analyst would be more familiar with. Abstracting all that front-end know-how behind some very straight-forward Python code allows the analyst to focus their efforts on the parts of their job that they excel in - gaining insight from data.\n\nThere would be little value in emulating the excellent Posit documentation on getting started with Python Shiny. To do that, I suggest [using their docs](https://shiny.posit.co/py/). In combination with the examples provided, a comprehensive introduction to Shiny is readily available. In the next section, I will focus on introducing a minimal application and then expanding on some of the more subtle considerations in the reactive flow of the backend. I'll choose to focus on things where I've needed to learn by trial and error, or by searching the Stack Overflow boards through some of the inevitable roadblocks a person encounters when programming dashboards. I'll throw in some common 'gotchas' for good measure. \n\n### Basic Frontend\n\n### Basic Backend\n\n### Tips\n\n***\n\n## A Year's Progress\n\n\n### Reactivity\n\n\n### Modular Dashboard\n\n***\n\n## The Shiny Ecosystem\n\nA nostalgic look at RShiny ecosystem.\n\n### Python Shiny Add-ins\n\n### Python Shiny Wishlist\n\n### Shinyhelper\n\n#### Shinytest\n\n#### DT tables\n\n#### Golem\n\n#### Reactlog\n\n***\n\n## In Review\n\nFinal thoughts & sign off\n",
    "supporting": [
      "python-shiny_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}