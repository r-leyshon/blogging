{
  "hash": "1cb869361ae029613b20de1fc2edf305",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Pytest Fixtures in Plain English\nauthor: Rich Leyshon\ndate: March 24 2024\ndescription: Plain English discussion of pytest fixtures.\ncategories:\n  - Explanation\n  - pytest\n  - Unit tests\n  - fixtures\n  - pytest-in-plain-english\nimage: 'https://images.pixexid.com/sculptural-simplicity-monochrome-background-highlighting-the-beauty-of-minimali-jmhkipzb.jpeg?h=699&amp;q=70'\nimage-alt: 'Sculptural simplicity, monochrome background highlighting the beauty of minimalist sculptures by [Ralph](https://pixexid.com/profile/cjxrsxsl7000008s6h21jecoe)'\ntoc: true\n---\n\n<figure class=center>\n  <img class=\"shaded_box\" width=400px src=\"https://images.pixexid.com/sculptural-simplicity-monochrome-background-highlighting-the-beauty-of-minimali-jmhkipzb.jpeg\"></img>\n  <figcaption style=\"text-align:center;\">Creative commons license by [Ralph](https://pixexid.com/profile/cjxrsxsl7000008s6h21jecoe)</figcaption>\n</figure>\n\n## Introduction\n\n`pytest` is a testing package for the python framework. It is broadly used to\nquality assure code logic. This article discusses using test data as fixtures\nwith `pytest` and is the first in a series of blogs called\n[pytest in plain English](/../docs/index.html#category=pytest-in-plain-english),\nfavouring accessible language and simple examples to explain the more intricate\nfeatures of the `pytest` package.\n\nfile:///Users/richardleyshon/Documents/blogging/index.html#category=pytest-in-plain-english\nfile:///Users/richardleyshon/Documents/blogging/docs/index.html#category=pytest-in-plain-english\n\nFor a wealth of documentation, guides and how-tos, please consult the\n<a href=\"https://docs.pytest.org/en/8.0.x/\" target=\"_blank\">Pytest documentation</a>.\n\n:::{.callout collapse=\"true\"}\n\n### A Note on the Purpose (Click to expand)\n\nThis article intends to discuss clearly. It doesn't aim to be clever or\nimpressive. Its aim is to extend the audience's understanding of the more\nintricate features of `pytest` by describing their utility with simple code\nexamples.  \n\n:::\n\n### Intended Audience\n\nProgrammers with a working knowledge of python and some familiarity with\n`pytest` and packaging. The type of programmer who has wondered about how to\noptimise their test code.\n\n### What You'll Need:\n\n- [ ] Preferred python environment manager (eg `conda`)\n- [ ] `pip install pytest==8.1.1`\n- [ ] Git\n- [ ] GitHub account\n- [ ] Command line access\n\n### Preparation\n\nThis blog is accompanied by code in\n[this repository](https://github.com/r-leyshon/pytest-fiddly-examples). The\nmain branch provides a template with the minimum structure and requirements\nexpected to run a `pytest` suite. The repo branches contain the code used in\nthe examples of the following sections.\n\nFeel free to fork or clone the repo and checkout to the example branches as\nneeded.\n\nThe example code that accompanies this section is available in the fixtures\nbranch of the \n[example code repo](https://github.com/r-leyshon/pytest-fiddly-examples/tree/fixtures).\n\n## What are fixtures?\n\nData. Well, data provided specifically for testing purposes. This is the\nessential definition for a fixture. One could argue the case that fixtures are\nmore than this. Fixtures could be environment variables, class instances,\nconnection to a server or whatever dependencies your code needs to run.\n\nI would agree that fixtures are not just data. But that all fixtures return\ndata of some sort, regardless of the system under test.\n\n## When would you use fixtures?\n\nIt's a bad idea to commit data to a git version-controlled repository, right?\nAgreed. Though fixtures are rarely 'real' data. The data used for testing\npurposes should be minimal and are usually synthetic. \n\n**Minimal fixtures** conform to the schema of the actual data under test.\nThese fixtures will be as small as possible while capturing all known important\ncases. Keeping the data small maintains a performant test suite and avoids\nproblems associated with large files and git version control.\n\nIf you have ever encountered a problem in a system that was caused by a\nproblematic record in the data, the aspect of that record that broke your\nsystem should absolutely make it into the next version of your minimal test\nfixture. Writing a test that checks that the codebase can handle such problem\nrecords is known as 'regression testing' - safeguarding against old bugs\nresurfacing when code is refactored or new features are implemented. This\nscenario commonly occurs when a developer unwittingly violates Chesterton's\nPrinciple.\n\n\n<iframe src=\"https://www.youtube.com/embed/qPGbl2gxGqI\" class=\"shaded-box\" title=\"Chesterton's Fence by Sprouts\" style=\"display: block; width: 600px; height: 338px\" frameborder=\"0\">\n</iframe>\n\nMany thanks to my colleague Mat for pointing me towards this useful analogy. A\nconsiderate developer would probably include a comment in their code about a\nspecific problem that they've handled (like erecting a sign next to\nChesterton's fence). An experienced developer would do the same, and also write\na regression test to ensure the problem doesn't re-emerge in the future\n(monitoring the fence with CCTV...). Discovering these problem cases and\nemploying defensive strategies avoids future pain for yourself and colleagues.\n\nAs you can imagine, covering all the important cases and keeping the fixture\nminimal are a compromise. At the outset of the work, it may not be obvious what\nproblematic cases may arise. Packages such as\n[`hypothesis`](https://hypothesis.readthedocs.io/en/latest/) allow you to\ngenerate awkward cases. Non-utf-8 strings anyone? Hypothesis can generate\nthese test cases for you - *ÄƒÑ£ð” Õ®á»Å¿Ä£ÈŸáŽ¥ð’‹Ç©Ä¾á¸¿êž‘È¯ð˜±ð‘žð—‹ð˜´È¶ðž„ðœˆÏˆð’™ð˜†ðš£*.\n\n**Non-disclosive fixtures** are those that do not expose personally\nidentifiable or commercially-sensitive information. If you are working with\nthis sort of data, it is necessary to produce toy test fixtures that mimic the\nschema of the real data. Names and addresses can be de-identified to random\nalphanumeric strings. Location data can be adjusted with noise. The use of\ndummy variables or categories can mitigate the risk of disclosure by\ndifferencing.\n\nBy adequately anonymising data and testing problem cases, the programmer\nexhibit their duty to upholding organisational duty to the General Data\nProtection Regulation, specifically to the duties to accurately store, process,\nretain and erase personally-identifiable information.\n\nIn cases where system integrates with data available in the public domain, it\nis may be permissable to include a small sample of the data as a test fixture.\nEnsure the license that the data is distributed under is compatible with your\ncode's license. If the license is compatible, I recommend including a reference\nto the fixture, its source and license within a LICENSE.note file. This\npractice is enforced by Comprehensive R Archive Network. You can read more about\nthis in the\n[R Packages documentation](https://r-pkgs.org/license.html#sec-how-to-include).\n\n## Scoping fixtures\n\nPytest fixtures have different scopes, meaning that they will be prepared\ndifferently dependent on the scope you specify. The avalable scopes are as\nfollows. \n\n| Scope Name  | Teardown after each |\n| ----------- | ------------------- |\n| function    | test function       |\n| class       | test class          |\n| module      | test module         |\n| session     | pytest session      |\n\nNote that the default scope for any fixtures that you define will be\n'function'. A function-scoped fixture will be set up for every test function\nthat requires it. Once the function has executed, the fixture will then be\ntorn down and all changes to this fixture will be lost. This default behaviour\nencourages isolation in your test suite. Meaning that the tests have no\ndependencies upon each other. The test functions could be run in any order\nwithout affecting the results of the test. Function-scoped fixtures are the\nshortest-lived fixtures. Moving down the table, the persistence of the fixtures\nincreases, so that changes to a session-scoped fixture persist for the entire\ntest execution direction, only being torn down once pytest has executed all\ntests.\n\n### Scoping for performance\n***\n\n> performance vs isolation\n\nBy definition, a unit test is completely isolated. However, there may be a few\ncases where this would be less desirable. Slow test suites may introduce\nexcessive friction to the software development process. Persistent fixtures can\nbe used to improve the performance of a test suite. \n\nFor example, here we define some expensive class:\n\n```{.python filename=expensive.py}\n\"\"\"A module containing an expensive class definition.\"\"\"\nimport time\nfrom typing import Union\n\n\nclass ExpensiveDoodah:\n    \"\"\"A toy class that represents some costly operation.\n\n    This class will sleep for the specified number of seconds on instantiation.\n\n    Parameters\n    ----------\n    sleep_time : Union[int, float]\n        Number of seconds to wait on init.\n\n    \"\"\"\n    def __init__(self, sleep_time: Union[int, float] = 2):\n        print(f\"Sleeping for {sleep_time} seconds\")\n        time.sleep(sleep_time)\n        return None\n\n```\n\nThis class will be used to demonstrate the effect of scoping with some costly\noperation. This example could represent reading in a bulky xlsx file, for\ninstance.\n\nTo test `ExpensiveDoodah`, I will define a function-scoped fixture. To do this,\nwe use pytest's fixture decorator to return the class instance with a specified\nsleep time of 2 seconds.\n\n```{.python filename=test_expensive.py}\nimport pytest\n\nfrom example_pkg.expensive import ExpensiveDoodah\n\n\n@pytest.fixture(scope=\"function\")\ndef module_doodah():\n    \"\"\"Function-scoped ExpensiveDoodah.\"\"\"\n    return ExpensiveDoodah(2)\n\n```\nNow we extend our test module to include a test class with 3 separate test\nfunctions, all making assertions about the `ExpensiveDoodah`. The assertions\nwill all be the same for this simple example, that `ExpensiveDoodah` executes\nwithout raising any error conditions. Notice we must pass the name of the\nfixture in each test function's signature.\n\n```{.python filename=test_expensive.py}\n\"\"\"Tests for expensive.py using function-scoped fixture.\"\"\"\nfrom contextlib import nullcontext as does_not_raise\nimport pytest\n\nfrom example_pkg.expensive import ExpensiveDoodah\n\n\n@pytest.fixture(scope=\"function\")\ndef doodah_fixture():\n    \"\"\"Function-scoped ExpensiveDoodah.\"\"\"\n    return ExpensiveDoodah(2)\n\n\nclass TestA:\n    \"\"\"A test class.\"\"\"\n\n    def test_1(self, doodah_fixture):\n        \"\"\"Test 1.\"\"\"\n        with does_not_raise():\n            doodah_fixture\n\n    def test_2(self, doodah_fixture):\n        \"\"\"Test 2.\"\"\"\n        with does_not_raise():\n            doodah_fixture\n\n    def test_3(self, doodah_fixture):\n        \"\"\"Test 3.\"\"\"\n        with does_not_raise():\n            doodah_fixture\n\n```\n\nThe result of running this test module can be seen below:\n\n```\ncollected 3 items\n\n./tests/test_expensive_function_scoped.py ...    [100%]\n\n============================ 3 passed in 6.04s ================================\n\n```\n\nNotice that the test module took just over 6 seconds to execute because the\nfunction-scoped fixture was set up once for each test function.\n\nIf instead we had defined `doodah_fixture` with a different scope, it would\nreduce the time for the test suite to complete.\n\n```{.python filename=test_expensive.py}\n@pytest.fixture(scope=\"module\")\ndef doodah_fixture():\n    \"\"\"Module-scoped ExpensiveDoodah.\"\"\"\n    return ExpensiveDoodah(2)\n\n```\n\n```\ncollected 3 items\n\n./tests/test_expensive_function_scoped.py ...    [100%]\n\n============================ 3 passed in 2.02s ================================\n\n```\n\nThe scoping feature of pytest fixtures can be used to optimise a test-suite and\navoid lengthy delays while waiting for your test suites to execute. However,\nany changes to the fixture contents will persist until the fixture is next torn\ndown. Keeping track of the states of differently-scoped fixtures in a complex\ntest suite can be tricky and reduces segmentation overall. Bear this in mind\nwhen considering which scope best suits your needs.\n\n### Scope persistence\n***\n\n> function < class < module < session\n\nUsing scopes other than 'function' can be useful for end-to-end testing.\nPerhaps you have a complex analytical pipeline and need to check that the\nvarious components work well **together**, rather than in isolation as with a\nunit test. This sort of test can be extremely useful for developers in a rush.\nYou can test that the so called 'promise' of the codebase is as expected, even\nthough the implementation may change.\n\nThe analogy here would be that the success criteria of a SatNav is that it gets\nyou to your desired destination whatever the suggested route you selected.\nChecking that you used the fastest or most fuel efficient option is probably a\ngood idea. But if you don't have time, you'll just have to take the hit if you\nencounter a toll road. It's still worth checking that the postcode you hastily\ninput to the satnav is the correct one.\n\n<iframe src=\"https://www.google.com/maps/embed?pb=!1m26!1m12!1m3!1d19867.3453412218!2d-0.12357612910538017!3d51.50554381133014!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!4m11!3e0!4m3!3m2!1d51.5020874!2d-0.0776174!4m5!1s0x48760520cd5b5eb5%3A0xa26abf514d902a7!2sBuckingham%20Palace%2C%20London!3m2!1d51.501363999999995!2d-0.14189!5e0!3m2!1sen!2suk!4v1711782045831!5m2!1sen!2suk\" allowfullscreen=\"\" loading=\"lazy\" referrerpolicy=\"no-referrer-when-downgrade\" class=\"shaded-box\" title=\"Google Maps displaying multiple routes to Buckingham Palace. (c) Google.\" style=\"display: block; width: 600px; height: 338px\">\n</iframe>\n\nPerhaps your success criteria is that you need to write a dataframe to file. \nA great end-to-end test would check that the dataframe produced has the\nexpected number of rows, or even has rows! Of course it's also a good idea to\ncheck the dataframe conforms to the expected table schema, too: number of\ncolumns, names of columns, order and data types. This sort of check is often\noverlooked in favour of pressing on with development. If you've ever\nencountered a situation where you've updated a codebase and later realised you\nnow have empty tables (I certainly have), this sort of test would be really\nhandy, immediately alerting you to this fact and helping you efficiently locate\nthe source of the bug.\n\nIn this part, I will explore the scoping of fixtures with dataframes. Again,\nI'll use a toy example to demonstrate scope behaviour. Being a child of the\n'90s (mostly), I'll use a scenario from my childhood. Scooby Doo is still a\nthing, right?\n\n#### Define Data\n\n**Enter: The Mystery Machine**\n\n<img src=/./www/11-fiddly-bits-of-pytest/mm.jpg alt=\"Scooby Doo & the gang in the Mystery Machine\" class=center>\n</img>\n\nThe scenario: The passengers of the Mystery Machine van all have the munchies.\nThey stop at a 'drive thru' to get some takeaway. We have a table with a record\nfor each character. We have data about the characters' names, their favourite\nfood, whether they have 'the munchies', and the contents of their stomach.\n\n::: {#4c1da54d .cell execution_count=1}\n``` {.python .cell-code}\nimport pandas as pd\nmystery_machine = pd.DataFrame(\n        {\n            \"name\": [\"Daphne\", \"Fred\", \"Scooby Doo\", \"Shaggy\", \"Velma\"],\n            \"fave_food\": [\n                \"carrots\",\n                \"beans\",\n                \"scooby snacks\",\n                \"burgers\",\n                \"hot dogs\",\n            ],\n            \"has_munchies\": [True] * 5, # everyone's hungry\n            \"stomach_contents\": [\"empty\"] * 5, # all have empty stomachs\n        }\n    )\nmystery_machine\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>name</th>\n      <th>fave_food</th>\n      <th>has_munchies</th>\n      <th>stomach_contents</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>Daphne</td>\n      <td>carrots</td>\n      <td>True</td>\n      <td>empty</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>Fred</td>\n      <td>beans</td>\n      <td>True</td>\n      <td>empty</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>Scooby Doo</td>\n      <td>scooby snacks</td>\n      <td>True</td>\n      <td>empty</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>Shaggy</td>\n      <td>burgers</td>\n      <td>True</td>\n      <td>empty</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>Velma</td>\n      <td>hot dogs</td>\n      <td>True</td>\n      <td>empty</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nTo use this simple dataframe as a fixture, I could go ahead and define it with\n`@pytest.fixture()` directly within a test file. But if I would like to share\nit across several test modules, then there are 2 options:\n\n1. Write the dataframe to disk as csv (or whatever format you prefer) and save\nin the `./tests/data/` folder. At the start of your test modules you can read\nthe data from disk and use it for testing. In this approach you'll likely\ndefine the data as a test fixture in each of the test modules that need to work\nwith it.\n2. Define the fixtures within a special python file called `conftest.py`, which\nmust be located at the root of your project. This file is used to configure\nyour tests. `pytest` will look in this file for any required fixture\ndefinitions when executing your test suite. If it finds a fixture with the same\nname as that required by a test, the fixture code may be run. \n\n:::{.callout-caution}\nWait! Did you just say '**may** be run'?\n:::\n\nDepending on the scope of your fixture, `pytest` may not need to execute the\ncode for each test. If you've defined a session-scoped fixture, it's going to\npersist for the duration of the entire test suite execution. Imagine test\nnumber 1 and 10 both require the same test fixture. The fixture definition only\ngets executed the first time a test requires it.\n\n#### Define fixtures\n\nFor our example, we will create a `conftest.py` file and define some fixtures\nwith differing scopes.\n\n```{.python filename=conftest.py}\n\"\"\"Demonstrate scoping fixtures.\"\"\"\nimport pandas as pd\nimport pytest\n\n\n@pytest.fixture(scope=\"session\")\ndef _mystery_machine():\n    \"\"\"Session-scoped fixture returning pandas dataframe.\"\"\"\n    return pd.DataFrame(\n        {\n            \"name\": [\"Daphne\", \"Fred\", \"Scooby Doo\", \"Shaggy\", \"Velma\"],\n            \"fave_food\": [\n                \"carrots\",\n                \"beans\",\n                \"scooby snacks\",\n                \"burgers\",\n                \"hot dogs\",\n            ],\n            \"has_munchies\": [True] * 5,\n            \"stomach_contents\": [\"empty\"] * 5,\n        }\n    )\n\n\n@pytest.fixture(scope=\"session\")\ndef _mm_session_scoped(_mystery_machine):\n    \"\"\"Session-scoped fixture returning the _mystery_machine dataframe.\"\"\"\n    return _mystery_machine.copy(deep=True)\n\n\n@pytest.fixture(scope=\"module\")\ndef _mm_module_scoped(_mystery_machine):\n    \"\"\"Module-scoped _mystery_machine dataframe.\"\"\"\n    return _mystery_machine.copy(deep=True)\n\n\n@pytest.fixture(scope=\"class\")\ndef _mm_class_scoped(_mystery_machine):\n    \"\"\"Class-scoped _mystery_machine dataframe.\"\"\"\n    return _mystery_machine.copy(deep=True)\n\n\n@pytest.fixture(scope=\"function\")\ndef _mm_function_scoped(_mystery_machine):\n    \"\"\"Function-scoped _mystery_machine dataframe.\"\"\"\n    return _mystery_machine.copy(deep=True)\n\n```\n\nFixtures can reference each other, if they're scoped correctly. More on this in\n[the next section](#troubleshooting-fixture-scopes). This is useful for my toy\nexample as I intend the source functions to update the dataframes directly, if\nI wasn't careful about deep copying the fixtures, my functions would update the\noriginal `_mystery_machine` fixture's table. Those changes would then be\nsubsequently passed to the other fixtures, meaning I couldn't clearly\ndemonstrate how the different scopes persist.\n\n#### Define the source functions\n\nNow let's create a function that will feed characters their favourite food if\nthey have the munchies. \n\nNote that it is commonplace to copy a pandas DataFrame so that any operations\ncarried out by the function are confined to the function's scope. To\ndemonstrate changes to the fixtures I will instead choose to edit the dataframe\ninplace.\n\n```{.python filename=feed_characters.py}\n\"\"\"Helping learners understand how to work with pytest fixtures.\"\"\"\nimport pandas as pd\n\n\ndef serve_food(df: pd.DataFrame) -> pd.DataFrame:\n    \"\"\"Serve characters their desired food.\n\n    Iterates over a df, feeding characters if they have 'the munchies' with\n    their fave_food. If the character is not Scooby Doo or Shaggy, then update\n    their has_munchies status to False. The input df is modified inplace.\n\n    Parameters\n    ----------\n    df : pd.DataFrame\n        A dataframe with the following columns: \"name\": str, \"fave_food\": str,\n        \"has_munchies\": bool, \"stomach_contents\": str.\n\n    Returns\n    -------\n    pd.DataFrame\n        Updated dataframe with new statuses for stomach_contents and\n        has_munchies.\n\n    \"\"\"\n    for ind, row in df.iterrows():\n        if row[\"has_munchies\"]:\n            # if character is hungry then feed them\n            food = row[\"fave_food\"]\n            character = row[\"name\"]\n            print(f\"Feeding {food} to {character}.\")\n            df.loc[ind, [\"stomach_contents\"]] = food\n            if character not in [\"Scooby Doo\", \"Shaggy\"]:\n                # Scooby & Shaggy are always hungry\n                df.loc[ind, \"has_munchies\"] = False\n        else:\n            # if not hungry then do not adjust\n            pass\n    return df\n\n```\n\n## Troubleshooting Fixture Scopes\n\n\n\n<p id=fin><i>fin!</i></p>\n\n",
    "supporting": [
      "11-fiddly-bits-of-pytest_files/figure-html"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}