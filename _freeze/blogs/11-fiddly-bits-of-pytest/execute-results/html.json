{
  "hash": "c7af69b7f9e8f6d77a61f5556854b601",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Pytest Fixtures in Plain English\nauthor: Rich Leyshon\ndate: April 07 2024\ndescription: Plain English Discussion of Pytest Fixtures.\ncategories:\n  - Explanation\n  - pytest\n  - Unit tests\n  - fixtures\n  - pytest-in-plain-english\nimage: 'https://images.pixexid.com/sculptural-simplicity-monochrome-background-highlighting-the-beauty-of-minimali-jmhkipzb.jpeg?h=699&amp;q=70'\nimage-alt: 'Sculptural simplicity, monochrome background highlighting the beauty of minimalist sculptures by [Ralph](https://pixexid.com/profile/cjxrsxsl7000008s6h21jecoe)'\ntoc: true\n---\n\n<figure class=center>\n  <img class=\"shaded_box\" width=400px src=\"https://images.pixexid.com/sculptural-simplicity-monochrome-background-highlighting-the-beauty-of-minimali-jmhkipzb.jpeg\"></img>\n  <figcaption style=\"text-align:center;\">Creative commons license by [Ralph](https://pixexid.com/profile/cjxrsxsl7000008s6h21jecoe)</figcaption>\n</figure>\n\n## Introduction\n\n`pytest` is a testing package for the python framework. It is broadly used to\nquality assure code logic. This article discusses using test data as fixtures\nwith `pytest` and is the first in a series of blogs called\n[pytest in plain English](/../index.html#category=pytest-in-plain-english),\nfavouring accessible language and simple examples to explain the more intricate\nfeatures of the `pytest` package.\n\nFor a wealth of documentation, guides and how-tos, please consult the\n<a href=\"https://docs.pytest.org/en/8.0.x/\" target=\"_blank\">pytest documentation</a>.\n\n:::{.callout collapse=\"true\"}\n\n### A Note on the Purpose (Click to expand)\n\nThis article intends to discuss clearly. It doesn't aim to be clever or\nimpressive. Its aim is to extend the audience's understanding of the more\nintricate features of `pytest` by describing their utility with simple code\nexamples.  \n\n:::\n\n### Intended Audience\n\nProgrammers with a working knowledge of python and some familiarity with\n`pytest` and packaging. The type of programmer who has wondered about how to\noptimise their test code.\n\n### What You'll Need:\n\n- [ ] Preferred python environment manager (eg `conda`)\n- [ ] `pip install pytest==8.1.1`\n- [ ] Git\n- [ ] GitHub account\n- [ ] Command line access\n\n### Preparation\n\nThis blog is accompanied by code in\n[this repository](https://github.com/r-leyshon/pytest-fiddly-examples). The\nmain branch provides a template with the minimum structure and requirements\nexpected to run a `pytest` suite. The repo branches contain the code used in\nthe examples of the following sections.\n\nFeel free to fork or clone the repo and checkout to the example branches as\nneeded.\n\nThe example code that accompanies this article is available in the\n[fixtures branch](https://github.com/r-leyshon/pytest-fiddly-examples/tree/fixtures)\nof the example code repo.\n\n## What are fixtures?\n\nData. Well, data provided specifically for testing purposes. This is the\nessential definition for a fixture. One could argue the case that fixtures are\nmore than this. Fixtures could be environment variables, class instances,\nconnection to a server or whatever dependencies your code needs to run.\n\nI would agree that fixtures are not just data. But that all fixtures return\ndata of some sort, regardless of the system under test.\n\n## When would you use fixtures?\n\nIt's a bad idea to commit data to a git repository, right? Agreed. Though\nfixtures are rarely 'real' data. The data used for testing purposes should be\nminimal and are usually synthetic. \n\n**Minimal fixtures** conform to the schema of the actual data that the system\nrequires. These fixtures will be as small as possible while capturing all known\nimportant cases. Keeping the data small maintains a performant test suite and\navoids problems associated with large files and git version control.\n\nIf you have ever encountered a problem in a system that was caused by a\nproblematic record in the data, the aspect of that record that broke your\nsystem should absolutely make it into the next version of your minimal test\nfixture. Writing a test that checks that the codebase can handle such problem\nrecords is known as 'regression testing' - safeguarding against old bugs\nresurfacing when code is refactored or new features are implemented. This\nscenario commonly occurs when a developer unwittingly violates Chesterton's\nPrinciple.\n\n\n<iframe src=\"https://www.youtube.com/embed/qPGbl2gxGqI\" class=\"shaded_box\" title=\"Chesterton's Fence by Sprouts\" style=\"display: block; width: 600px; height: 338px\" frameborder=\"0\">\n</iframe>\n\nMany thanks to my colleague Mat for pointing me towards this useful analogy. A\nconsiderate developer would probably include a comment in their code about a\nspecific problem that they've handled (like erecting a sign next to\nChesterton's fence). An experienced developer would do the same, and also write\na regression test to ensure the problem doesn't re-emerge in the future\n(monitoring the fence with CCTV...). Discovering these problem cases and\nemploying defensive strategies avoids future pain for yourself and colleagues.\n\nAs you can imagine, covering all the important cases while keeping the fixture\nminimal is a compromise. At the outset of the work, it may not be obvious what\nproblematic cases may arise. Packages such as\n[`hypothesis`](https://hypothesis.readthedocs.io/en/latest/) allow you to\ngenerate awkward cases. Non-utf-8 strings anyone? Hypothesis can generate\nthese test cases for you, along with many more interesting edge-cases -\n*ÄƒÑ£ð” Õ®á»Å¿Ä£ÈŸáŽ¥ð’‹Ç©Ä¾á¸¿êž‘È¯ð˜±ð‘žð—‹ð˜´È¶ðž„ðœˆÏˆð’™ð˜†ðš£* (Non-utf8 strings often cause problems for web apps). \n\n**Non-disclosive fixtures** are those that do not expose personally\nidentifiable or commercially-sensitive information. If you are working with\nthis sort of data, it is necessary to produce toy test fixtures that mimic the\nschema of the real data. Names and addresses can be de-identified to random\nalphanumeric strings. Location data can be adjusted with noise. The use of\ndummy variables or categories can mitigate the risk of disclosure by\ndifferencing.\n\nBy adequately anonymising data and testing problem cases, the programmer\nexhibits upholds duties under the General Data Protection Regulation:\n\n> accurately store, process, retain and erase personally-identifiable information.\n\nIn cases where the system integrates with data available in the public domain,\nit is may be permissible to include a small sample of the data as a test\nfixture. Ensure the license that the data is distributed under is compatible\nwith your code's license. If the license is compatible, I recommend including a\nreference to the fixture, its source and license within a LICENSE.note file.\nThis practice is enforced by Comprehensive R Archive Network. You can read more\nabout this in the\n[R Packages documentation](https://r-pkgs.org/license.html#sec-how-to-include).\n\n## Scoping fixtures\n\n`pytest` fixtures have different scopes, meaning that they will be prepared\ndifferently dependent on the scope you specify. The available scopes are as\nfollows: \n\n| Scope Name  | Teardown after each |\n| ----------- | ------------------- |\n| function    | test function       |\n| class       | test class          |\n| module      | test module         |\n| package     | package under test  |\n| session     | `pytest` session    |\n\nNote that the default scope for any fixtures that you define will be\n'function'. A function-scoped fixture will be set up for every test function\nthat requires it. Once the function has executed, the fixture will then be\ntorn down and all changes to this fixture will be lost. This default behaviour\nencourages isolation in your test suite. Meaning that the tests have no\ndependencies upon each other. The test functions could be run in any order\nwithout affecting the results of the test. Function-scoped fixtures are the\nshortest-lived fixtures. Moving down the table above, the persistence of the\nfixtures increases. Changes to a session-scoped fixture persist for the entire\ntest execution duration, only being torn down once `pytest` has executed all\ntests.\n\n### Scoping for performance\n***\n\n> performance vs isolation\n\nBy definition, a unit test is completely isolated, meaning that it will have no\ndependencies other than the code it needs to test. However, there may be a few\ncases where this would be less desirable. Slow test suites may introduce\nexcessive friction to the software development process. Persistent fixtures can\nbe used to improve the performance of a test suite. \n\nFor example, here we define some expensive class:\n\n```{.python filename=expensive.py}\n\"\"\"A module containing an expensive class definition.\"\"\"\nimport time\nfrom typing import Union\n\n\nclass ExpensiveDoodah:\n    \"\"\"A toy class that represents some costly operation.\n\n    This class will sleep for the specified number of seconds on instantiation.\n\n    Parameters\n    ----------\n    sleep_time : Union[int, float]\n        Number of seconds to wait on init.\n\n    \"\"\"\n    def __init__(self, sleep_time: Union[int, float] = 2):\n        print(f\"Sleeping for {sleep_time} seconds\")\n        time.sleep(sleep_time)\n        return None\n\n```\n\nThis class will be used to demonstrate the effect of scoping with some costly\noperation. This example could represent reading in a bulky xlsx file or\nquerying a large database.\n\nTo serve `ExpensiveDoodah` to our tests, I will define a function-scoped\nfixture. To do this, we use a `pytest` fixture decorator to return the class\ninstance with a specified sleep time of 2 seconds.\n\n```{.python filename=test_expensive.py}\nimport pytest\n\nfrom example_pkg.expensive import ExpensiveDoodah\n\n\n@pytest.fixture(scope=\"function\")\ndef module_doodah():\n    \"\"\"Function-scoped ExpensiveDoodah.\"\"\"\n    return ExpensiveDoodah(2)\n\n```\nNow to test `ExpensiveDoodah` we extend our test module to include a test class\nwith 3 separate test functions. The assertions will all be the same for this\nsimple example - that `ExpensiveDoodah` executes without raising any error\nconditions. Notice we must pass the name of the fixture in each test function's\nsignature.\n\n```{.python filename=test_expensive.py}\n\"\"\"Tests for expensive.py using function-scoped fixture.\"\"\"\nfrom contextlib import nullcontext as does_not_raise\nimport pytest\n\nfrom example_pkg.expensive import ExpensiveDoodah\n\n\n@pytest.fixture(scope=\"function\")\ndef doodah_fixture():\n    \"\"\"Function-scoped ExpensiveDoodah.\"\"\"\n    return ExpensiveDoodah(2)\n\n\nclass TestA:\n    \"\"\"A test class.\"\"\"\n\n    def test_1(self, doodah_fixture):\n        \"\"\"Test 1.\"\"\"\n        with does_not_raise():\n            doodah_fixture\n\n    def test_2(self, doodah_fixture):\n        \"\"\"Test 2.\"\"\"\n        with does_not_raise():\n            doodah_fixture\n\n    def test_3(self, doodah_fixture):\n        \"\"\"Test 3.\"\"\"\n        with does_not_raise():\n            doodah_fixture\n\n```\n\nThe result of running this test module can be seen below:\n\n```\ncollected 3 items\n\n./tests/test_expensive_function_scoped.py ...    [100%]\n\n============================ 3 passed in 6.04s ================================\n\n```\n\nNotice that the test module took just over 6 seconds to execute because the\nfunction-scoped fixture was set up once for each test function.\n\nIf instead we had defined `doodah_fixture` with a different scope, it would\nreduce the time for the test suite to complete by approximately two thirds.\nThis is the sort of benefit that can be gained from considerate use of `pytest`\nfixtures.\n\n```{.python filename=test_expensive.py}\n@pytest.fixture(scope=\"module\")\ndef doodah_fixture():\n    \"\"\"Module-scoped ExpensiveDoodah.\"\"\"\n    return ExpensiveDoodah(2)\n\n```\n\n```\ncollected 3 items\n\n./tests/test_expensive_function_scoped.py ...    [100%]\n\n============================ 3 passed in 2.02s ================================\n\n```\n\nThe scoping feature of `pytest` fixtures can be used to optimise a test-suite\nand avoid lengthy delays while waiting for your test suites to execute.\nHowever, any changes to the fixture contents will persist until the fixture is\nnext torn down. Keeping track of the states of differently-scoped fixtures in a\ncomplex test suite can be tricky and reduces segmentation overall. Bear this in\nmind when considering which scope best suits your needs.\n\n### Scope persistence\n***\n\n> function < class < module < package < session\n\nUsing scopes other than 'function' can be useful for end-to-end testing.\nPerhaps you have a complex analytical pipeline and need to check that the\nvarious components work well **together**, rather than in isolation as with a\nunit test. This sort of test can be extremely useful for developers in a rush.\nYou can test that the so called 'promise' of the codebase is as expected, even\nthough the implementation may change.\n\nThe analogy here would be that the success criteria of a SatNav is that it gets\nyou to your desired destination whatever the suggested route you selected.\nChecking that you used the fastest or most fuel efficient option is probably a\ngood idea. But if you don't have time, you'll just have to take the hit if you\nencounter a toll road. Though it's still worth checking that the postcode you\nhastily input to the satnav is the correct one.\n\n<iframe src=\"https://www.google.com/maps/embed?pb=!1m26!1m12!1m3!1d19867.3453412218!2d-0.12357612910538017!3d51.50554381133014!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!4m11!3e0!4m3!3m2!1d51.5020874!2d-0.0776174!4m5!1s0x48760520cd5b5eb5%3A0xa26abf514d902a7!2sBuckingham%20Palace%2C%20London!3m2!1d51.501363999999995!2d-0.14189!5e0!3m2!1sen!2suk!4v1711782045831!5m2!1sen!2suk\" allowfullscreen=\"\" loading=\"lazy\" referrerpolicy=\"no-referrer-when-downgrade\" class=\"shaded_box\" title=\"Google Maps displaying multiple routes to Buckingham Palace. (c) Google.\" style=\"display: block; width: 600px; height: 338px\">\n</iframe>\n<br>\nPerhaps your success criteria is that you need to write a DataFrame to file. \nA great end-to-end test would check that the DataFrame produced has the\nexpected number of rows, or even has rows! Of course it's also a good idea to\ncheck the DataFrame conforms to the expected table schema, too: number of\ncolumns, names of columns, order and data types. This sort of check is often\noverlooked in favour of pressing on with development. If you've ever\nencountered a situation where you've updated a codebase and later realised you\nnow have empty tables (I certainly have), this sort of test would be really\nhandy, immediately alerting you to this fact and helping you efficiently locate\nthe source of the bug.\n\n#### Define Data\n\nIn this part, I will explore the scoping of fixtures with DataFrames. Again,\nI'll use a toy example to demonstrate scope behaviour. Being a child of the\n'90s (mostly), I'll use a scenario from my childhood. Scooby Doo is still a\nthing, right?\n\n**Enter: The Mystery Machine**\n\n<img src=/./www/11-fiddly-bits-of-pytest/mm.jpg alt=\"Scooby Doo & the gang in the Mystery Machine\" class=center>\n</img>\n\nThe scenario: The passengers of the Mystery Machine van all have the munchies.\nThey stop at a 'drive thru' to get some takeaway. We have a table with a record\nfor each character. We have columns with data about the characters' names,\ntheir favourite food, whether they have 'the munchies', and the contents of\ntheir stomach.\n\n::: {#7ed99bb4 .cell execution_count=1}\n``` {.python .cell-code}\nimport pandas as pd\nmystery_machine = pd.DataFrame(\n        {\n            \"name\": [\"Daphne\", \"Fred\", \"Scooby Doo\", \"Shaggy\", \"Velma\"],\n            \"fave_food\": [\n                \"carrots\",\n                \"beans\",\n                \"scooby snacks\",\n                \"burgers\",\n                \"hot dogs\",\n            ],\n            \"has_munchies\": [True] * 5, # everyone's hungry\n            \"stomach_contents\": [\"empty\"] * 5, # all have empty stomachs\n        }\n    )\nmystery_machine\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>name</th>\n      <th>fave_food</th>\n      <th>has_munchies</th>\n      <th>stomach_contents</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>Daphne</td>\n      <td>carrots</td>\n      <td>True</td>\n      <td>empty</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>Fred</td>\n      <td>beans</td>\n      <td>True</td>\n      <td>empty</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>Scooby Doo</td>\n      <td>scooby snacks</td>\n      <td>True</td>\n      <td>empty</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>Shaggy</td>\n      <td>burgers</td>\n      <td>True</td>\n      <td>empty</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>Velma</td>\n      <td>hot dogs</td>\n      <td>True</td>\n      <td>empty</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nTo use this simple DataFrame as a fixture, I could go ahead and define it with\n`@pytest.fixture()` directly within a test file. But if I would like to share\nit across several test modules\n([as implemented later](#fixtures-across-multiple-test-modules)), then there\nare 2 options:\n\n1. Write the DataFrame to disk as csv (or whatever format you prefer) and save\nin a `./tests/data/` folder. At the start of your test modules you can read the\ndata from disk and use it for testing. In this approach you'll likely define\nthe data as a test fixture in each of the test modules that need to work with\nit.\n2. Define the fixtures within a special python file called `conftest.py`, which\nmust be located at the root of your project. This file is used to configure\nyour tests. `pytest` will look in this file for any required fixture\ndefinitions when executing your test suite. If it finds a fixture with the same\nname as that required by a test, the fixture code may be run. \n\n:::{.callout-caution}\nWait! Did you just say '**may** be run'?\n:::\n\nDepending on the scope of your fixture, `pytest` may not need to execute the\ncode for each test. For example, let's say we're working with a session-scoped\nfixture. This type of fixture will persist for the duration of the entire test\nsuite execution. Imagine test number 1 and 10 both require this test fixture.\nThe fixture definition only gets executed the first time a test requires it.\nThis test fixture will be set up as test 1 executes and will persist until\ntear down occurs at the end of the `pytest` session. Test 10 will therefore use\nthe same instance of this fixture as test 1 used, meaning any changes to the\nfixture may be carried forward.\n\n#### Define fixtures\n\nFor our example, we will create a `conftest.py` file and define some fixtures\nwith differing scopes.\n\n```{.python filename=conftest.py}\n\"\"\"Demonstrate scoping fixtures.\"\"\"\nimport pandas as pd\nimport pytest\n\n\n@pytest.fixture(scope=\"session\")\ndef _mystery_machine():\n    \"\"\"Session-scoped fixture returning pandas DataFrame.\"\"\"\n    return pd.DataFrame(\n        {\n            \"name\": [\"Daphne\", \"Fred\", \"Scooby Doo\", \"Shaggy\", \"Velma\"],\n            \"fave_food\": [\n                \"carrots\",\n                \"beans\",\n                \"scooby snacks\",\n                \"burgers\",\n                \"hot dogs\",\n            ],\n            \"has_munchies\": [True] * 5,\n            \"stomach_contents\": [\"empty\"] * 5,\n        }\n    )\n\n\n@pytest.fixture(scope=\"session\")\ndef _mm_session_scoped(_mystery_machine):\n    \"\"\"Session-scoped fixture returning the _mystery_machine DataFrame.\"\"\"\n    return _mystery_machine.copy(deep=True)\n\n\n@pytest.fixture(scope=\"module\")\ndef _mm_module_scoped(_mystery_machine):\n    \"\"\"Module-scoped _mystery_machine DataFrame.\"\"\"\n    return _mystery_machine.copy(deep=True)\n\n\n@pytest.fixture(scope=\"class\")\ndef _mm_class_scoped(_mystery_machine):\n    \"\"\"Class-scoped _mystery_machine DataFrame.\"\"\"\n    return _mystery_machine.copy(deep=True)\n\n\n@pytest.fixture(scope=\"function\")\ndef _mm_function_scoped(_mystery_machine):\n    \"\"\"Function-scoped _mystery_machine DataFrame.\"\"\"\n    return _mystery_machine.copy(deep=True)\n\n```\n\nFixtures can reference each other, if they're scoped correctly. More on this in\n[the next section](#scopemismatch-error). This is useful for my toy example as\nI intend the source functions to update the DataFrames directly, if I wasn't\ncareful about deep copying the fixtures, my functions would update the original\n`_mystery_machine` fixture's table. Those changes would then be subsequently\npassed to the other fixtures, meaning I couldn't clearly demonstrate how the\ndifferent scopes persist.\n\n#### Define the source functions\n\nNow, let's create a function that will feed characters their favourite food if\nthey have the munchies. \n\n```{.python filename=feed_characters.py}\n\"\"\"Helping learners understand how to work with pytest fixtures.\"\"\"\nimport pandas as pd\n\n\ndef serve_food(df: pd.DataFrame) -> pd.DataFrame:\n    \"\"\"Serve characters their desired food.\n\n    Iterates over a df, feeding characters if they have 'the munchies' with\n    their fave_food. If the character is not Scooby Doo or Shaggy, then update\n    their has_munchies status to False. The input df is modified inplace.\n\n    Parameters\n    ----------\n    df : pd.DataFrame\n        A DataFrame with the following columns: \"name\": str, \"fave_food\": str,\n        \"has_munchies\": bool, \"stomach_contents\": str.\n\n    Returns\n    -------\n    pd.DataFrame\n        Updated DataFrame with new statuses for stomach_contents and\n        has_munchies.\n\n    \"\"\"\n    for ind, row in df.iterrows():\n        if row[\"has_munchies\"]:\n            # if character is hungry then feed them\n            food = row[\"fave_food\"]\n            character = row[\"name\"]\n            print(f\"Feeding {food} to {character}.\")\n            df.loc[ind, [\"stomach_contents\"]] = food\n            if character not in [\"Scooby Doo\", \"Shaggy\"]:\n                # Scooby & Shaggy are always hungry\n                df.loc[ind, \"has_munchies\"] = False\n        else:\n            # if not hungry then do not adjust\n            pass\n    return df\n\n```\n\nNote that it is commonplace to copy a pandas DataFrame so that any operations\ncarried out by the function are confined to the function's scope. To\ndemonstrate changes to the fixtures I will instead choose to edit the DataFrame\ninplace.\n\n#### Fixtures Within a Single Test Module\n\nNow to write some tests. To use the fixtures we defined earlier, we simply \ndeclare that a test function requires the fixture. `pytest` will notice this \ndependency on collection, check the fixture scope and execute the fixture code \nif appropriate. The following test `test_scopes_before_action` checks that the\n`mystery_machine` fixtures all have the expected `has_munchies` column values\nat the outset of the test module, i.e. everybody is hungry before our source\nfunction takes some action. This type of test doesn't check behaviour of any\nsource code and therefore would be unnecessary for quality assurance purposes.\nBut I include it here to demonstrate the simple use of fixtures and prove to\nthe reader the state of the DataFrame fixtures prior to any source code\nintervention.\n\n:::{.callout-tip collapse=\"true\"}\n\n##### **Testing `pandas` DataFrames**\n\nYou may notice that the assert statements in the tests below requires pulling \ncolumn values out and casting to lists. The `pandas` package has its own\ntesting module that is super useful for testing all aspects of DataFrames.\nCheck out the\n[`pandas` testing documentation](https://pandas.pydata.org/docs/reference/testing.html)\nfor more on how to write robust tests for pandas DataFrames and Series.\n\n:::\n\n```{.python filename=\"test_feed_characters.py\"}\n\"\"\"Testing pandas operations with test fixtures.\"\"\"\nfrom example_pkg.feed_characters import serve_food\n\n\ndef test_scopes_before_action(\n    _mm_session_scoped,\n    _mm_module_scoped,\n    _mm_class_scoped,\n    _mm_function_scoped,\n):\n    \"\"\"Assert that all characters have the munchies at the outset.\"\"\"\n    assert list(_mm_session_scoped[\"has_munchies\"].values) == [True] * 5, (\n        \"The session-scoped DataFrame 'has_munchies' column was not as \",\n        \"expected before any action was taken.\",\n    )\n    assert list(_mm_module_scoped[\"has_munchies\"].values) == [True] * 5, (\n        \"The module-scoped DataFrame 'has_munchies' column was not as \",\n        \"expected before any action was taken.\",\n    )\n    assert list(_mm_class_scoped[\"has_munchies\"].values) == [True] * 5, (\n        \"The class-scoped DataFrame 'has_munchies' column was not as \",\n        \"expected before any action was taken.\",\n    )\n    assert list(_mm_function_scoped[\"has_munchies\"].values) == [True] * 5, (\n        \"The function-scoped DataFrame 'has_munchies' column was not as \",\n        \"expected before any action was taken.\",\n    )\n\n```\n\nNow to test the `serve_food()` function operates as expected. We can define\na test class that will house all tests for `serve_food()`. Within that class\nlet's define our first test that simply checks that the value of the\n`has_munchies` column has been updated as we would expect after using the\n`serve_food()` function.\n\n```{.python filename=\"test_feed_characters.py\"}\nclass TestServeFood:\n    \"\"\"Tests that serve_food() updates the 'has_munchies' column.\"\"\"\n\n    def test_serve_food_updates_df(\n        self,\n        _mm_session_scoped,\n        _mm_module_scoped,\n        _mm_class_scoped,\n        _mm_function_scoped,\n    ):\n        \"\"\"Test serve_food updates the has_munchies columns as expected.\n\n        This function will update each fixture in the same way, providing each\n        character with their favourite_food and updating the contents of their\n        stomach. The column we will assert against will be has_munchies, which\n        should be updated to False after feeding in all cases except for Scooby\n        Doo and Shaggy, who always have the munchies.\n        \"\"\"\n        # first lets check that the session-scoped dataframe gets updates\n        assert list(serve_food(_mm_session_scoped)[\"has_munchies\"].values) == [\n            False,\n            False,\n            True,\n            True,\n            False,\n        ], (\n            \"The `serve_food()` has not updated the session-scoped df\",\n            \" 'has_munchies' column as expected.\",\n        )\n        # next check the same for the module-scoped fixture\n        assert list(serve_food(_mm_module_scoped)[\"has_munchies\"].values) == [\n            False,\n            False,\n            True,\n            True,\n            False,\n        ], (\n            \"The `serve_food()` has not updated the module-scoped df\",\n            \" 'has_munchies' column as expected.\",\n        )\n        # Next check class-scoped fixture updates\n        assert list(serve_food(_mm_class_scoped)[\"has_munchies\"].values) == [\n            False,\n            False,\n            True,\n            True,\n            False,\n        ], (\n            \"The `serve_food()` has not updated the class-scoped df\",\n            \" 'has_munchies' column as expected.\",\n        )\n        # Finally check the function-scoped df does the same...\n        assert list(\n            serve_food(_mm_function_scoped)[\"has_munchies\"].values\n        ) == [\n            False,\n            False,\n            True,\n            True,\n            False,\n        ], (\n            \"The `serve_food()` has not updated the function-scoped df\",\n            \" 'has_munchies' column as expected.\",\n        )\n\n```\n\nNotice that the test makes exactly the same assertion for every differently\nscoped fixture? In every instance, we have fed the characters in the mystery\nmachine DataFrame and therefore everyone's `has_munchies` status (apart from\nScooby Doo and Shaggy's) gets updated to `False`.\n\n:::{.callout-tip collapse=\"true\"}\n\n##### **Parametrized Tests**\n\nWriting the test out this way makes things explicit and easy to follow.\nHowever, you could make this test smaller by using a neat feature of the\n`pytest` package called **parametrized** tests. This is basically like applying\nconditions to your tests in a `for` loop. Perhaps you have a bunch of\nconditions to check, multiple DataFrames or whatever. These can be\nprogrammatically served with\n[parametrized tests](https://docs.pytest.org/en/7.1.x/how-to/parametrize.html).\nWhile outside of the scope of this article, I intend to write a blog on this in\nthe future.\n:::\n\nNext, we can add to the test class, including a new test that checks the state\nof the fixtures. At this point, we will start to see some differences due to\nscoping. The new `test_expected_states_within_same_class()` will assert that\nthe changes to the fixtures brought about in the previous test\n`test_serve_food_updates_df()` will persist, except for the the case of\n`_mm_function_scoped` which will go through teardown at the end of every test\nfunction.\n\n```{.python filename=\"test_feed_characters.py\"}\nclass TestServeFood:\n    \"\"\"Tests that serve_food() updates the 'has_munchies' column.\"\"\"\n    # ... (test_serve_food_updates_df)\n\n    def test_expected_states_within_same_class(\n        self,\n        _mm_session_scoped,\n        _mm_module_scoped,\n        _mm_class_scoped,\n        _mm_function_scoped,\n    ):\n        \"\"\"Test to ensure fixture states are as expected.\"\"\"\n        # Firstly, session-scoped changes should persist, only Scooby Doo &\n        # Shaggy should still have the munchies...\n        assert list(_mm_session_scoped[\"has_munchies\"].values) == [\n            False,\n            False,\n            True,\n            True,\n            False,\n        ], (\n            \"The changes to the session-scoped df 'has_munchies' column have\",\n            \" not persisted as expected.\",\n        )\n        # Secondly, module-scoped changes should persist, as was the case for\n        # the session-scope test above\n        assert list(_mm_module_scoped[\"has_munchies\"].values) == [\n            False,\n            False,\n            True,\n            True,\n            False,\n        ], (\n            \"The changes to the module-scoped df 'has_munchies' column have\",\n            \" not persisted as expected.\",\n        )\n        # Next, class-scoped changes should persist just the same\n        assert list(_mm_class_scoped[\"has_munchies\"].values) == [\n            False,\n            False,\n            True,\n            True,\n            False,\n        ], (\n            \"The changes to the class-scoped df 'has_munchies' column have\",\n            \" not persisted as expected.\",\n        )\n        # Finally, demonstrate that function-scoped fixture starts from scratch\n        # Therefore all characters should have the munchies all over again.\n        assert (\n            list(_mm_function_scoped[\"has_munchies\"].values) == [True] * 5\n        ), (\n            \"The function_scoped df 'has_munchies' column is not as expected.\",\n        )\n\n```\n\nIn the above test, we assert that the function-scoped fixture values have\nthe original fixture's values. The function-scoped fixture goes through set-up\nagain as `test_expected_states_within_same_class` is executed, ensuring a\n'fresh', unchanged version of the fixture DataFrame is provided. \n\nWithin the same test module, we can add some other test class and make\nassertions about the fixtures. This new test will check whether the\n`stomach_contents` column of the module and class-scoped fixtures have been\nupdated. Recall that the characters start out with `\"empty\"` stomach contents.\n\n```{.python filename=\"test_feed_characters.py\"}\n\n# ... (TestServeFood)\n    # (test_serve_food_updates_df)\n    # (test_expected_states_within_same_class) ...\n\nclass TestSomeOtherTestClass:\n    \"\"\"Demonstrate persistence of changes to class-scoped fixture.\"\"\"\n\n    def test_whether_changes_to_stomach_contents_persist(\n        self, _mm_class_scoped, _mm_module_scoped\n    ):\n        \"\"\"Check the stomach_contents column.\"\"\"\n        assert list(_mm_module_scoped[\"stomach_contents\"].values) == [\n            \"carrots\",\n            \"beans\",\n            \"scooby snacks\",\n            \"burgers\",\n            \"hot dogs\",\n        ], \"Changes to module-scoped fixture have not propagated as expected.\"\n        assert (\n            list(_mm_class_scoped[\"stomach_contents\"].values) == [\"empty\"] * 5\n        ), \"Values in class-scoped fixture are not as expected\"\n```\n\nIn this example, it is demonstrated that changes to the class-scoped fixture \nhave been discarded. As `test_whether_changes_to_stomach_contents_persist()`\nexists within a new class called `TestSomeOtherTestClass`, the code for\n`_mm_class_scoped` has been executed again, providing the original DataFrame\nvalues.\n\n##### **Balancing Isolation & Persistence**\n***\n\nWhile the persistence of fixtures may be useful for end to end tests, this\napproach reduces isolation in the test suite. Be aware that this may introduce\na bit of friction to your `pytest` development process. For example, it can be\ncommonplace to develop a new test and to check that it passes by invoking\n`pytest` with the keyword `-k` flag to run that single test\n(or subset of tests) only. This approach is useful if you have a costly test\nsuite and you just want to examine changes in a single unit.\n\nAt the current state of the test module, executing the entire test module by\nrunning `pytest ./tests/test_feed_characters.py` will pass. However, running\n`pytest -k \"TestSomeOtherTestClass\"` will fail. This is because the assertions\nin `TestSomeOtherTestClass` rely on code being executed within the preceding\ntest class. Tests in `TestSomeOtherTestClass` rely on changes elsewhere in your\ntest suite and by definition are no longer unit tests. For those developers who\nwork with [pytest-randomly](https://pypi.org/project/pytest-randomly/) to help\nsniff out poorly-isolated tests, this approach could cause a bit of a headache.\n\nA good compromise would be to ensure that the use of fixture scopes other than\n`function` are isolated and clearly documented within a test suite. Thoughtful\ngrouping of integration tests within test modules or classes can limit grief \nfor collaborating developers. Even better would be to\n[mark tests](https://docs.pytest.org/en/latest/how-to/mark.html) according to\ntheir scoped dependencies. This approach allows tests to be grouped and\nexecuted separately, though the implementation of this is beyond the scope of\nthis article. \n\n#### Fixtures Across Multiple Test Modules\n\nFinally in this section, we will explore fixture behaviour across more than one\ntest module. Below I define a new source module with a function used to update\nthe `mystery_machine` DataFrame. This function will update the `fave_food`\ncolumn for a character if it has already eaten. This is meant to represent a\ncharacter's preference for a dessert following a main course. Once more, this\nfunction will not deep copy the input DataFrame but will allow inplace\nadjustment.\n\n<img class=\"center shaded_box\" alt=\"Delicious ice cream\" title=\"Delicious ice cream by Prompart https://pixexid.com/profile/@prompart\" src=\"https://images.pixexid.com/delicious-ice-cream-ibt3ypxn.jpeg?h=700&amp;q=70\">\n\n```{.python filename=\"update_food.py\"}\n\"\"\"Helping learners understand how to work with pytest fixtures.\"\"\"\nimport pandas as pd\n\n\ndef fancy_dessert(\n    df: pd.DataFrame,\n    fave_desserts: dict = {\n        \"Daphne\": \"brownie\",\n        \"Fred\": \"ice cream\",\n        \"Scooby Doo\": \"apple crumble\",\n        \"Shaggy\": \"pudding\",\n        \"Velma\": \"banana bread\",\n    },\n) -> pd.DataFrame:\n    \"\"\"Update a characters favourite_food to a dessert if they have eaten.\n\n    Iterates over a df, updating the fave_food value for a character if the\n    stomach_contents are not 'empty'.\n\n    Parameters\n    ----------\n    df : pd.DataFrame\n        A dataframe with the following columns: \"name\": str, \"fave_food\": str,\n        \"has_munchies\": bool, \"stomach_contents\": str.\n    fave_desserts : dict, optional\n        A mapping of \"name\" to a replacement favourite_food, by default\n        { \"Daphne\": \"brownie\", \"Fred\": \"ice cream\",\n        \"Scooby Doo\": \"apple crumble\", \"Shaggy\": \"pudding\",\n        \"Velma\": \"banana bread\", }\n\n    Returns\n    -------\n    pd.DataFrame\n        Dataframe with updated fave_food values.\n\n    \"\"\"\n    for ind, row in df.iterrows():\n        if row[\"stomach_contents\"] != \"empty\":\n            # character has eaten, now they should prefer a dessert\n            character = row[\"name\"]\n            dessert = fave_desserts[character]\n            print(f\"{character} now wants {dessert}.\")\n            df.loc[ind, \"fave_food\"] = dessert\n        else:\n            # if not eaten, do not adjust\n            pass\n    return df\n\n```\nNote that the condition required for `fancy_dessert()` to take action is that\nthe contents of the character's `stomach_contents` should be not equal to\n\"empty\". Now to test this new src module, we create a new test module. We will\nrun assertions of the `fave_food` columns against the differently-scoped\nfixtures. \n\n```{.python filename=\"test_update_food.py\"}\n\"\"\"Testing pandas operations with test fixtures.\"\"\"\nfrom example_pkg.update_food import fancy_dessert\n\n\nclass TestFancyDessert:\n    \"\"\"Tests for fancy_dessert().\"\"\"\n\n    def test_fancy_dessert_updates_fixtures_as_expected(\n        self,\n        _mm_session_scoped,\n        _mm_module_scoped,\n        _mm_class_scoped,\n        _mm_function_scoped,\n    ):\n        \"\"\"Test fancy_dessert() changes favourite_food values to dessert.\n\n        These assertions depend on the current state of the scoped fixtures. If\n        changes performed in\n        test_feed_characters::TestServeFood::test_serve_food_updates_df()\n        persist, then characters will not have empty stomach_contents,\n        resulting in a switch of their favourite_food to dessert.\n        \"\"\"\n        # first, check update_food() with the session-scoped fixture.\n        assert list(fancy_dessert(_mm_session_scoped)[\"fave_food\"].values) == [\n            \"brownie\",\n            \"ice cream\",\n            \"apple crumble\",\n            \"pudding\",\n            \"banana bread\",\n        ], (\n            \"The changes to the session-scoped df 'stomach_contents' column\",\n            \" have not persisted as expected.\",\n        )\n        # next, check update_food() with the module-scoped fixture.\n        assert list(fancy_dessert(_mm_module_scoped)[\"fave_food\"].values) == [\n            \"carrots\",\n            \"beans\",\n            \"scooby snacks\",\n            \"burgers\",\n            \"hot dogs\",\n        ], (\n            \"The module-scoped df 'stomach_contents' column was not as\",\n            \" expected\",\n        )\n        # now, check update_food() with the class-scoped fixture. Note that we\n        # are now making assertions about changes from a different class.\n        assert list(fancy_dessert(_mm_class_scoped)[\"fave_food\"].values) == [\n            \"carrots\",\n            \"beans\",\n            \"scooby snacks\",\n            \"burgers\",\n            \"hot dogs\",\n        ], (\n            \"The class-scoped df 'stomach_contents' column was not as\",\n            \" expected\",\n        )\n        # Finally, check update_food() with the function-scoped fixture. As\n        # in TestServeFood::test_expected_states_within_same_class(), the\n        # function-scoped fixture starts from scratch.\n        assert list(\n            fancy_dessert(_mm_function_scoped)[\"fave_food\"].values\n        ) == [\"carrots\", \"beans\", \"scooby snacks\", \"burgers\", \"hot dogs\"], (\n            \"The function-scoped df 'stomach_contents' column was not as\",\n            \" expected\",\n        )\n\n```\nNote that the only fixture expected to have been adjusted by `update_food()` is\n`_mm_session_scoped`. When running the `pytest` command, changes from executing\nthe first test module `test_feed_characters.py` propagate for this fixture\nonly. All other fixture scopes used  will go through teardown and then setup\nonce more on execution of the second test module.\n\nThis arrangement is highly dependent on the order of which the test modules are\ncollected. `pytest` collects tests in alphabetical ordering by default, and as\nsuch `test_update_food.py` can be expected to be executed after\n`test_feed_characters.py`. This test module is highly dependent upon the order\nof the `pytest` execution. This makes the tests less portable and means that\nrunning the test module  with `pytest tests/test_update_food.py` in isolation\nwould fail. I would once more suggest using\n[`pytest` marks](https://docs.pytest.org/en/latest/how-to/mark.html) to group\nthese types of tests and execute them separately to the rest of the test suite.\n\n## `ScopeMismatch` Error\n\nWhen working with `pytest` fixtures, occasionally you will encounter a\n`ScopeMismatch` exception. This may happen when attempting to use certain\n`pytest` plug-ins or perhaps if trying to use temporary directory fixtures like\n`tmp_path` with fixtures that are scoped differently to function-scope.\nOccasionally, you may encounter this exception when attempting to reference\nyour own fixture in other fixtures, as was done with the\n[`mystery_machine` fixture above](#define-fixtures). \n\nThe reason for `ScopeMismatch` is straightforward. Fixture scopes have a\nhierarchy, based on their persistence:\n\n> function < class < module < package < session\n\nFixtures with a greater scope in the hierarchy are not permitted to reference\nthose lower in the hierarchy. The way I remember this rule is that:\n\n> Fixtures must only reference equal or greater scopes.\n\nIt is unclear why this rule has been implemented other than to reduce\ncomplexity (which is reason enough in my book). There was talk about\nimplementing `scope=\"any\"` some time ago, but it looks like this idea was\nabandoned. To reproduce the error:\n\n```{.python filename=\"test_bad_scoping.py\"}\n\"\"\"Demomstrate ScopeMismatch error.\"\"\"\n\nimport pytest\n\n@pytest.fixture(scope=\"function\")\ndef _fix_a():\n    return 1\n\n@pytest.fixture(scope=\"class\")\ndef _fix_b(_fix_a):\n    return _fix_a + _fix_a\n\n\ndef test__fix_b_return_val(_fix_b):\n    assert _fix_b == 2\n\n```\nExecuting this test module results in:\n```\n================================= ERRORS ======================================\n________________ ERROR at setup of test__fix_b_return_val _____________________\nScopeMismatch: You tried to access the function scoped fixture _fix_a with a\nclass scoped request object, involved factories:\ntests/test_bad_scoping.py:9:  def _fix_b(_fix_a)\ntests/test_bad_scoping.py:5:  def _fix_a()\n========================== short test summary info ============================\nERROR tests/test_bad_scoping.py::test__fix_b_return_val - Failed:\nScopeMismatch: You tried to access the function scoped fixture _fix_a with a\nclass scoped request object, involved factories:\n=========================== 1 error in 0.01s ==================================\n```\n\nThis error can be avoided by adjusting the fixture scopes to adhere to the\nhierarchy rule, so updating `_fix_a` to use a class scope or greater would\nresult in a passing test.\n\n## Summary\n\nHopefully by now you feel comfortable in when and how to use fixtures for\n`pytest`. We've covered quite a bit, including:\n\n* What fixtures are\n* Use-cases\n* Where to store them\n* How to reference them\n* How to scope them\n* How changes to fixtures persist or not\n* Handling scope errors \n\nIf you spot an error with this article, or have  suggested improvement then\nfeel free to\n[raise an issue on GitHub](https://github.com/r-leyshon/blogging/issues).  \n\nHappy testing!\n\n## Acknowledgements\n\nTo past and present colleagues who have helped to discuss pros and cons,\nestablishing practice and firming-up some opinions. Particularly:\n\n* Clara\n* Dan C\n* Dan S\n* Edward\n* Ethan\n* Henry\n* Ian\n* Iva\n* Jay\n* Mark\n* Martin R\n* Martin W\n* Mat\n* Sergio\n\n<p id=fin><i>fin!</i></p>\n\n",
    "supporting": [
      "11-fiddly-bits-of-pytest_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}