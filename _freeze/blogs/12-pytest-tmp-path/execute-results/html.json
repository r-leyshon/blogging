{
  "hash": "07d218d45ed29acdcce26b3be8b456c4",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Pytest With `tmp_path` in Plain English\nauthor: Rich Leyshon\ndate: April 25 2024\ndescription: Plain English Discussion of Pytest Temporary Fixtures.\ncategories:\n  - Explanation\n  - pytest\n  - Unit tests\n  - tmp_path\n  - tmp_path_factory\n  - fixtures\n  - pytest-in-plain-english\nimage: 'https://images.pixexid.com/a-clock-with-gears-made-of-layered-textured-paper-and-a-glossy-metallic-face-s-0yp5gyd5.jpeg?h=699&amp;q=70'\nimage-alt: 'A clock with gears made of layered, textured paper and a glossy metallic face, set against a backdrop of passing time by [Ralph](https://pixexid.com/profile/cjxrsxsl7000008s6h21jecoe)'\ntoc: true\n---\n\n<figure class=center>\n  <img class=\"shaded_box\" width=400px src=\"https://images.pixexid.com/a-clock-with-gears-made-of-layered-textured-paper-and-a-glossy-metallic-face-s-0yp5gyd5.jpeg\"></img>\n  <figcaption style=\"text-align:center;\">Creative commons license by [Ralph](https://pixexid.com/profile/cjxrsxsl7000008s6h21jecoe)</figcaption>\n</figure>\n\n## Introduction\n\n`pytest` is a testing package for the python framework. It is broadly used to\nquality assure code logic. This article discusses why and how we use pytest's\ntemporary fixtures `tmp_path` and `tmp_path_factory`. This blog is the second\nin a series of blogs called\n[pytest in plain English](/../index.html#category=pytest-in-plain-english),\nfavouring accessible language and simple examples to explain the more intricate\nfeatures of the `pytest` package.\n\nFor a wealth of documentation, guides and how-tos, please consult the\n<a href=\"https://docs.pytest.org/en/8.0.x/\" target=\"_blank\">`pytest` documentation</a>.\n\n:::{.callout collapse=\"true\"}\n\n### A Note on the Purpose (Click to expand)\n\nThis article intends to discuss clearly. It doesn't aim to be clever or\nimpressive. Its aim is to extend understanding without overwhelming the reader.\n\n:::\n\n### Intended Audience\n\nProgrammers with a working knowledge of python and some familiarity with\n`pytest` and packaging. The type of programmer who has wondered about how to\noptimise their test code.\n\n### What You'll Need:\n\n- [ ] Preferred python environment manager (eg `conda`)\n- [ ] `pip install pytest==8.1.1`\n- [ ] Git\n- [ ] GitHub account\n- [ ] Command line access\n\n### Preparation\n\nThis blog is accompanied by code in\n[this repository](https://github.com/r-leyshon/pytest-fiddly-examples). The\nmain branch provides a template with the minimum structure and requirements\nexpected to run a `pytest` suite. The repo branches contain the code used in\nthe examples of the following sections.\n\nFeel free to fork or clone the repo and checkout to the example branches as\nneeded.\n\nThe example code that accompanies this article is available in the\n[temp-fixtures branch](https://github.com/r-leyshon/pytest-fiddly-examples/tree/temp-fixtures)\nof the example code repo.\n\n## What Are Temporary Fixtures?\n\nIn the previous [`pytest` in plain English](/blogs/11-fiddly-bits-of-pytest.qmd)\narticle, we discussed how to write our own fixtures to serve data to our tests.\nBut `pytest` comes with its own set of fixtures that are really useful in\ncertain situations. In this article, we will consider those fixtures that are\nused to create temporary directories and files.\n\n### Why Do We Need Temporary Fixtures?\n\nIf the code you need to test carries out file operations, then you ought to\nconsider how to read and write files to and from disk safely. It is best\npractice in testing to ensure the system state in unaffected by running the\ntest suite. In the very worst cases I have encountered, running the test suite\nhas resulted in timestamped csvs being written to disk every time `pytest` was\nrun. As developers potentially run these tests hundreds of times while working\non a code base, this thoughtless little side-effect quickly results in a messy\nfile system. \n\nJust to clarify - I'm not saying it's a bad idea to use timestamped file names.\nOr to have functions with these kinds of side effects - they can be really\nuseful. It's just when the test suite creates junk on your disk that you\nweren't aware of...\n\nBy using temporary fixtures, we are ensuring the tests are isolated from each\nother and behave in dependable ways. If you ever encounter a test suite that\nbehaves differently on subsequent runs, then be suspicious of a messy test\nsuite with file operations that have changed the state of the system. In order\nfor us to reason about the state of the code, we need to be able to rely on the\nanswers we get from the tests, known in test-engineering speak as\n**determinism**.\n\n### Let's Compare the Available Temporary Fixtures\n\nThe 2 fixtures that we should be working with as of 2024 are `tmp_path` and\n`tmp_path_factory`. Both of these newer temporary fixtures return\n`pathlib.Path` objects and are included with the `pytest` package in order to\nencourage developers to use them. No need to import `tempfile` or any other\ndependency to get what you need, it's all bundled up with your `pytest`\ninstallation.\n\n`tmp_path` is a function-scoped fixture. Meaning that if we use `tmp_path` in\n2 unit tests, then we will be served with 2 separate temporary directories to\nwork with. This should meet most developers' needs. But if you're doing\nsomething more complex with files, there are occasions where you may need a\nmore persistent temporary directory. Perhaps a bunch of your functions need to\nwork sequentially using files on disk and you need to test how all these units\nwork together. This kind of scenario can arise if you are working on really\nlarge files where in-memory operations become too costly. This is where\n`tmp_path_factory` can be useful, as it is a session-scoped temporary\nstructure. A `tmp_path_factory` structure will be created at the start of a\ntest suite and will persist until teardown happens once the last test has been\nexecuted.\n\n| Fixture Name       | Scope    | Teardown after each |\n| ------------------ | ---------| ------------------- |\n| `tmp_path`         | function | test function       |\n| `tmp_path_factory` | session  | `pytest` session    |\n\n### What About `tmpdir`?\n\nAh, the eagle-eyed among you may have noticed that they `pytest` package\ncontains other fixtures that are relevant to temporary structures. Namely\n`tmpdir` and `tmpdir_factory`. These fixtures are older equivalents of the\nfixtures we discussed above. The main difference is that instead of returning\n`pathlib.Path` objects, they return `py.path.local` objects. These fixtures\nwere written before `pathlib` had been adopted as the\n[standardised approach](https://peps.python.org/pep-0519/#standard-library-changes)\nto handling paths across multiple operating systems. These future of `tmpdir`\nand `tmpdir_factory` have been discussed for deprecation. These fixtures are\nbeing sunsetted and it is advised to port old test suites over to the new\n`tmp_path` fixture instead. The `pytest` team have\n[provided a utility](https://docs.pytest.org/en/7.1.x/how-to/tmp_path.html#the-tmpdir-and-tmpdir-factory-fixtures)\nto help developers identify these issues in their old test suites. \n\nIn summary, don't use `tmpdir` any more and consider converting old code if you\nused it in the past... \n\n## How to Use Temporary Fixtures\n\n### Writing Source Code\n\nAs a reminder, <a href=\"https://github.com/r-leyshon/pytest-fiddly-examples/tree/temp-fixtures\" target=\"_blank\">the code for this section is located here.</a>\n\nIn this deliberately silly example, let's say we have a poem sitting on our\ndisk in a text file. Thanks to chatGPT for the poem and MSFT Bing Copilot for\nthe image, making this a trivial consideration. Or should I really thank the\nmillions of people who wrote the content that these services trained on?\n\nSaving the text file in the chunk below to the `./tests/data/` folder is where\nyou would typically save data for your tests.\n\n<img src=\"https://i.imgur.com/TKN3zzt.png\" alt=\"A modern take on Jack and Jill sees the pair fending off bugs in a future technological dystopia.\" class=\"center\" width=400/>\n\n```{.abc filename=\"tests/data/jack-jill-2024.txt\"}\nIn the realm of data, where Jack and Jill dwell,\nThey ventured forth, their tale to tell.\nBut amidst the bytes, a glitch they found,\nA challenge profound, in algorithms bound.\n\nTheir circuits whirred, their processors spun,\nAs they analyzed the glitch, one by one.\nYet despite their prowess, misfortune struck,\nA bug so elusive, like lightning struck.\n\nTheir systems faltered, errors abound,\nAs frustration grew with each rebound.\nBut Jack and Jill, with minds so keen,\nRefused to let the glitch remain unseen.\n\nWith perseverance strong and logic clear,\nThey traced the bug to its hidden sphere.\nAnd with precision fine and code refined,\nThey patched the glitch, their brilliance defined.\n\nIn the end, though misfortune came their way,\nJack and Jill triumphed, without delay.\nFor in the realm of AI, where challenges frown,\nTheir intellect prevailed, wearing victory's crown.\n\nSo let their tale inspire, in bytes and code,\nWhere challenges rise on the digital road.\nFor Jack and Jill, with their AI might,\nShowed that even in darkness, there's always light.\n\n```\n\nLet's imagine for some reason we want a program that can edit the text and\nwrite new versions of the poem to disk. Let's go ahead and create a function\nthat will read the poem from disk and replace any word that you'd like to\nchange.\n\n::: {#11c48398 .cell execution_count=1}\n``` {.python .cell-code}\n\"\"\"Demonstrating tmp_path & tmp_path_factory with a simple txt file.\"\"\"\nfrom pathlib import Path\nfrom typing import Union\n\ndef _update_a_term(\n    txt_pth: Union[Path, str], target_pattern:str, replacement:str) -> str:\n    \"\"\"Replace the target pattern in a body of text.\n\n    Parameters\n    ----------\n    txt_pth : Union[Path, str]\n        Path to a txt file.\n    target_pattern : str\n        The pattern to replace.\n    replacement : str\n        The replacement value.\n\n    Returns\n    -------\n    str\n        String with any occurences of target_pattern replaced with specified\n        replacement value.\n\n    \"\"\"\n    with open(txt_pth, \"r\") as f:\n        txt = f.read()\n        f.close()\n    return txt.replace(target_pattern, replacement)\n```\n:::\n\n\nNow we can try using the function to rename a character in the rhyme, by\nrunning the below code in a python shell.\n\n::: {#67ad1337 .cell execution_count=2}\n``` {.python .cell-code}\nfrom pyprojroot import here\nrhyme = _update_a_term(\n  txt_pth=here(\"data/blogs/jack-jill-2024.txt\"),\n  target_pattern=\"Jill\",\n  replacement=\"Jock\")\nprint(rhyme[0:175])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIn the realm of data, where Jack and Jock dwell,\nThey ventured forth, their tale to tell.\nBut amidst the bytes, a glitch they found,\nA challenge profound, in algorithms bound.\n```\n:::\n:::\n\n\n::: {.callout-note collapse=\"true\"}\n\n#### Why Use Underscores?\n\nYou may have noticed that the above function start with an underscore. This\nconvention means the function is not intended for use by the user. These\ninternal functions would typically have less defensive checks than those you\nintend to expose to your users. It's not an enforced thing but is considered\ngood practice. It means \"use at your own risk\" as internals often have less\ndocumentation, may not be directly tested and could be less stable than\nfunctions in the api.\n\nThis tends to be <a href=\"https://realpython.com/python-double-underscore/#:~:text=In%20general%2C%20you%20should%20use,strict%20rule%20that%20Python%20enforces.\" target=\"_blank\">more useful when you are writing classes</a>\n, though this is beyond the scope of this article. \n\n:::\n\nGreat, next we need a little utility function that will take our text and write\nit to a file of our choosing.\n\n::: {#c3d6cbd9 .cell execution_count=3}\n``` {.python .cell-code}\ndef _write_string_to_txt(some_txt:str, out_pth:Union[Path, str]) -> None:\n    \"\"\"Write some string to a text file.\n\n    Parameters\n    ----------\n    some_txt : str\n        The text to write to file.\n    out_pth : Union[Path, str]\n        The path to the file.\n    \n    Returns\n    -------\n    None\n\n    \"\"\"\n    with open(out_pth, \"w\") as f:\n        f.writelines(some_txt)\n        f.close()    \n```\n:::\n\n\nThe finally, we need a wrapper function that will take the above functions,\nallowing the user to read in the text file, replace a pattern and then write\nthe new poem to file.\n\n::: {#498f939a .cell execution_count=4}\n``` {.python .cell-code}\ndef update_poem(\n    poem_pth:Union[Path, str],\n    target_pattern:str,\n    replacement:str,\n    out_file:Union[Path, str]) -> None:\n    \"\"\"Takes a txt file, replaces a pattern and writes to a new file.\n\n    Parameters\n    ----------\n    poem_pth : Union[Path, str]\n        Path to a txt file.\n    target_pattern : str\n        A pattern to update.\n    replacement : str\n        The replacement value.\n    out_file : Union[Path, str]\n        A file path to write to.\n\n    \"\"\"\n    txt = _update_a_term(poem_pth, target_pattern, replacement)\n    _write_string_to_txt(txt, out_file)\n```\n:::\n\n\nHow do we know it works? We can use it and observe the output, as I did with\n`_update_a_term()` earlier, but this article is about testing. So let's get to\nit.\n\n### Testing the Source Code\n\nWe need to test `update_poem()` but it writes files to disk. We don't want to\nlitter our (and our colleagues') disks with files every time pytest runs.\nTherefore we need to ensure the function's `out_file` parameter is pointing at\na temporary directory. In that way, we can rely on the temporary structure's\nbehaviour on teardown to remove these files when pytest finishes doing its\nbusiness.\n\n::: {#465e44c4 .cell execution_count=5}\n``` {.python .cell-code}\n\"\"\"Tests for update_poetry module.\"\"\"\nimport os\n\nimport pytest\n\nfrom example_pkg import update_poetry\n\ndef test_update_poem_writes_new_pattern_to_file(tmp_path):\n    \"\"\"Check that update_poem changes the poem pattern and writes to file.\"\"\"\n    new_poem_path = os.path.join(tmp_path, \"new_poem.txt\")\n    update_poetry.update_poem(\n        poem_pth=\"tests/data/jack-jill-2024.txt\",\n        target_pattern=\"glitch\",\n        replacement=\"bug\",\n        out_file=new_poem_path\n        )\n```\n:::\n\n\nBefore I go ahead and add a bunch of assertions in, look at how easy it is to\nuse `tmp_path`, blink and you'll miss it. You simply reference it in the\nsignature of the test that you wish to use it and then you are able to go ahead\nand use it like you would any other path object.\n\nSo far in this test function, I specified that I'd like to read the text from a\nfile called `jack-jill-2024.txt`, replace the word \"glitch\" with \"bug\" wherever\nit occurs and then write this text to a file called `new_poem.txt` in a\ntemporary directory. \n\nSome simple tests for this little function:\n\n* Does the file I asked for exist?\n* Are the contents of that file as I expect?\n\nLet's go ahead and add in those assertions.\n\n::: {#368154a5 .cell execution_count=6}\n``` {.python .cell-code}\n\"\"\"Tests for update_poetry module.\"\"\"\n\nimport os\n\nimport pytest\n\nfrom example_pkg import update_poetry\n\ndef test_update_poem_writes_new_pattern_to_file(tmp_path):\n    \"\"\"Check that update_poem changes the poem pattern and writes to file.\"\"\"\n    new_poem_path = os.path.join(tmp_path, \"new_poem.txt\")\n    update_poetry.update_poem(\n        poem_pth=\"tests/data/jack-jill-2024.txt\",\n        target_pattern=\"glitch\",\n        replacement=\"bug\",\n        out_file=new_poem_path\n        )\n    # Now for the assertions\n    assert os.path.exists(new_poem_path)\n    assert os.listdir(tmp_path) == [\"new_poem.txt\"]\n    # let's check what pattern was written - now we need to read in the\n    # contents of the new file.\n    with open(new_poem_path, \"r\") as f:\n        what_was_written = f.read()\n        f.close()\n    assert \"glitch\" not in what_was_written\n    assert \"bug\" in what_was_written\n\n```\n:::\n\n\nRunning `pytest` results in the below output.\n\n```\n<INSERT CONSOLE OUTPUT>\n```\n\nSo we prove that the function works how we hoped it would. But what if I want\nto work with the `new_poem.txt` file again in another test function? Let's add\nanother test to `test_update_poetry.py` and see what we get when we try to use\n`tmp_path` once more.\n\n::: {#2eb9e55a .cell execution_count=7}\n``` {.python .cell-code}\n\"\"\"Tests for update_poetry module.\"\"\"\n# import statements ...\n\n# def test_update_poem_writes_new_pattern_to_file(tmp_path): ...\n\ndef test_do_i_get_a_new_tmp_path(tmp_path):\n    \"\"\"Remind ourselves that tmp_path is function-scoped.\"\"\"\n    assert \"new_poem\" not in os.listdir(tmp_path)\n    assert os.listdir(tmp_path) == []\n\n```\n:::\n\n\nAs is demonstrated when running `pytest` once more, `tmp_path` is\nfunction-scoped and we have now lost the new poem with the bugs instead of the\nglitches. Drat! What to do...\n\n```\n<INSERT CODE>\n\n```\n\nAs mentioned earlier, `pytest` provides another fixture with more\nflexibility, called `tmp_path_factory`. As this fixture is session-scoped, we\ncan have full control over this fixtures scoping. \n\n::: {.callout-tip collapse=\"true\"}\n\n#### Fixture Scopes\n\nFor a refresher on the rules of scope referencing, please see the blog [Pytest Fixtures in Plain English](/blogs/11-fiddly-bits-of-pytest.qmd#scopemismatch-error).\n\n:::\n\n::: {#0eeccef6 .cell execution_count=8}\n``` {.python .cell-code}\n\"\"\"Tests for update_poetry module.\"\"\"\n# import statements ...\n\n# def test_update_poem_writes_new_pattern_to_file(tmp_path): ...\n\n# def test_do_i_get_a_new_tmp_path(tmp_path): ...\n\n@pytest.fixture(scope=\"module\")\ndef _module_scoped_tmp(tmp_path_factory):\n    yield tmp_path_factory.mktemp(\"put_poetry_here\", numbered=False)\n```\n:::\n\n\nNote that as `tmp_path_factory` is session-scoped, I'm free to reference it in\nanother fixture with any scope. Here I define a module-scoped fixture, which\nmeans teardown of `_module_scoped_tmp` will occur once the final test in this\ntes module completes. Now repeating the logic executed with `tmp_path` above,\nbut this time with our new module-scoped temporary directory, we get a\ndifferent outcome.\n\n::: {#f2801181 .cell execution_count=9}\n``` {.python .cell-code}\n\"\"\"Tests for update_poetry module.\"\"\"\n# import statements ...\n\n# def test_update_poem_writes_new_pattern_to_file(tmp_path): ...\n\n# def test_do_i_get_a_new_tmp_path(tmp_path): ...\n\n@pytest.fixture(scope=\"module\")\ndef _module_scoped_tmp(tmp_path_factory):\n    yield tmp_path_factory.mktemp(\"put_poetry_here\", numbered=False)\n\n\ndef test_module_scoped_tmp_exists(_module_scoped_tmp):\n    new_poem_path = os.path.join(_module_scoped_tmp, \"new_poem.txt\")\n    update_poetry.update_poem(\n        poem_pth=\"tests/data/jack-jill-2024.txt\",\n        target_pattern=\"glitch\",\n        replacement=\"bug\",\n        out_file=new_poem_path\n        )\n    assert os.path.exists(new_poem_path)\n    with open(new_poem_path, \"r\") as f:\n        what_was_written = f.read()\n        f.close()\n    assert \"glitch\" not in what_was_written\n    assert \"bug\" in what_was_written\n    assert os.listdir(_module_scoped_tmp) == [\"new_poem.txt\"]\n\n\ndef test_do_i_get_a_new_tmp_path_factory(_module_scoped_tmp):\n    assert not os.listdir(_module_scoped_tmp) == [] # not empty...\n    assert os.listdir(_module_scoped_tmp) == [\"new_poem.txt\"]\n    # module-scoped fixture still contains file made in previous test function\n    with open(os.path.join(_module_scoped_tmp, \"new_poem.txt\")) as f:\n        found_txt = f.read()\n        f.close()\n    assert \"glitch\" not in found_txt\n    assert \"bug\" in found_txt\n```\n:::\n\n\nExecuting `pytest` one final time demonstrates that the same output file\nwritten to disk with `test_module_scoped_tmp_exists()` is subsequently\navailable for further testing in `test_do_i_get_a_new_tmp_path_factory()`.\n\nWhilst this may be useful for anything time-consuming your test suite has to\ndo, note that the order that these 2 tests run in is now important. These tests\nare no longer isolated and trying to run the second test on its own with\n`pytest -k \"test_do_i_get_a_new_tmp_path_factory\"` would result in a fail. For\nthis reason it may be advisable to pop the test functions within a common\ntest class, or even use\n<a href=\"https://docs.pytest.org/en/7.1.x/example/markers.html\" target=\"_blank\">pytest marks</a>\nto mark them as integration tests (more on this in a future blog). \n\n\n## Summary\n\nThe reasons we use temporary fixtures and how to use them has been demonstrated\nwith another silly (but hopefully relatable) little example. I have not gone\ninto the wealth of methods available in these temporary fixtures, but they have\na wealth of utilities to help. Maybe your working with a complex nexted\ndirectory structure for example, the `glob` method would surely help with that.\n\n```\n<INSERT CODE>\n```\n\nIf you spot an error with this article, or have  suggested improvement then\nfeel free to\n[raise an issue on GitHub](https://github.com/r-leyshon/blogging/issues).  \n\nHappy testing!\n\n## Acknowledgements\n\nTo past and present colleagues who have helped to discuss pros and cons,\nestablishing practice and firming-up some opinions. Particularly:\n\n* Charlie\n* Dan\n* Edward\n* Ian\n* Mark\n\n<p id=fin><i>fin!</i></p>\n\n",
    "supporting": [
      "12-pytest-tmp-path_files"
    ],
    "filters": [],
    "includes": {}
  }
}