{
  "hash": "5ce6cafbec5beb1e690fdced948e0a0d",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Pytest With `tmp_path` in Plain English\nauthor: Rich Leyshon\ndate: April 25 2024\ndescription: Plain English Discussion of Pytest Temporary Fixtures.\ncategories:\n  - Explanation\n  - pytest\n  - Unit tests\n  - tmp_path\n  - tmp_path_factory\n  - fixtures\n  - pytest-in-plain-english\nimage: 'https://images.pixexid.com/a-clock-with-gears-made-of-layered-textured-paper-and-a-glossy-metallic-face-s-0yp5gyd5.jpeg?h=699&amp;q=70'\nimage-alt: 'A clock with gears made of layered, textured paper and a glossy metallic face, set against a backdrop of passing time by [Ralph](https://pixexid.com/profile/cjxrsxsl7000008s6h21jecoe)'\ntoc: true\n---\n\n<figure class=center>\n  <img class=\"shaded_box\" width=400px src=\"https://images.pixexid.com/a-clock-with-gears-made-of-layered-textured-paper-and-a-glossy-metallic-face-s-0yp5gyd5.jpeg\"></img>\n  <figcaption style=\"text-align:center;\">Creative commons license by [Ralph](https://pixexid.com/profile/cjxrsxsl7000008s6h21jecoe)</figcaption>\n</figure>\n\n## Introduction\n\n`pytest` is a testing package for the python framework. It is broadly used to\nquality assure code logic. This article discusses why and how we use pytest's\ntemporary fixtures `tmp_path` and `tmp_path_factory`. This blog is the second\nin a series of blogs called\n[pytest in plain English](/../index.html#category=pytest-in-plain-english),\nfavouring accessible language and simple examples to explain the more intricate\nfeatures of the `pytest` package.\n\nFor a wealth of documentation, guides and how-tos, please consult the\n<a href=\"https://docs.pytest.org/en/8.0.x/\" target=\"_blank\">`pytest` documentation</a>.\n\n:::{.callout collapse=\"true\"}\n\n### A Note on the Purpose (Click to expand)\n\nThis article intends to discuss clearly. It doesn't aim to be clever or\nimpressive. Its aim is to extend understanding without overwhelming the reader.\n\n:::\n\n### Intended Audience\n\nProgrammers with a working knowledge of python and some familiarity with\n`pytest` and packaging. The type of programmer who has wondered about how to\noptimise their test code.\n\n### What You'll Need:\n\n- [ ] Preferred python environment manager (eg `conda`)\n- [ ] `pip install pytest==8.1.1`\n- [ ] Git\n- [ ] GitHub account\n- [ ] Command line access\n\n### Preparation\n\nThis blog is accompanied by code in\n[this repository](https://github.com/r-leyshon/pytest-fiddly-examples). The\nmain branch provides a template with the minimum structure and requirements\nexpected to run a `pytest` suite. The repo branches contain the code used in\nthe examples of the following sections.\n\nFeel free to fork or clone the repo and checkout to the example branches as\nneeded.\n\nThe example code that accompanies this article is available in the\n[temp-fixtures branch](https://github.com/r-leyshon/pytest-fiddly-examples/tree/temp-fixtures)\nof the example code repo.\n\n## What are temporary fixtures?\n\nIn the previous [`pytest` in plain English](/blogs/11-fiddly-bits-of-pytest.qmd)\narticle, we discussed how to write our own fixtures to serve data to our tests.\nBut `pytest` comes with its own set of fixtures that are really useful in\ncertain situations. In this article, we will consider those fixtures that are\nused to create temporary directories and files.\n\n## Why do we need temporary fixtures?\n\nIf the code you need to test carries out file operations, then you ought to\nconsider how to read and write files to and from disk safely. It is best\npractice in testing to ensure the system state in unaffected by running the\ntest suite. In the very worst cases I have encountered, running the test suite\nhas resulted in timestamped csvs being written to disk every time `pytest` was\nrun. As developers potentially run these tests hundreds of times while working\non a code base, this thoughtless little side-effect quickly results in a messy\nfile system. \n\nJust to clarify - I'm not saying it's a bad idea to use timestamped file names.\nOr to have functions with these kinds of side effects - they can be really\nuseful. It's just when the test suite creates junk on your disk that you\nweren't aware of...\n\nBy using temporary fixtures, we are ensuring the tests are isolated from each\nother and behave in dependable ways. If you ever encounter a test suite that\nbehaves differently on subsequent runs, then be suspicious of a messy test\nsuite with file operations that have changed the state of the system. In order\nfor us to reason about the state of the code, we need to be able to rely on the\nanswers we get from the tests, known in test-engineering speak as\n**determinism**.\n\n## Let's compare the available temporary fixtures\n\nThe 2 fixtures that we should be working with as of 2024 are `tmp_path` and\n`tmp_path_factory`. Both of these newer temporary fixtures return\n`pathlib.Path` objects and are included with the `pytest` package in order to\nencourage developers to use them. No need to import `tempfile` or any other\ndependency to get what you need, it's all bundled up with your `pytest`\ninstallation.\n\n`tmp_path` is a function-scoped fixture. Meaning that if we use `tmp_path` in\n2 unit tests, then we will be served with 2 separate temporary directories to\nwork with. This should meet most developers' needs. But if you're doing\nsomething more complex with files, there are occasions where you may need a\nmore persistent temporary directory. Perhaps a bunch of your functions need to\nwork sequentially using files on disk and you need to test how all these units\nwork together. This kind of scenario can arise if you are working on really\nlarge files where in-memory operations become too costly. This is where\n`tmp_path_factory` can be useful, as it is a session-scoped temporary\nstructure. A `tmp_path_factory` structure will be created at the start of a\ntest suite and will persist until teardown happens once the last test has been\nexecuted.\n\n| Fixture Name       | Scope    | Teardown after each |\n| ------------------ | ---------| ------------------- |\n| `tmp_path`         | function | test function       |\n| `tmp_path_factory` | session  | `pytest` session    |\n\n### What about tmpdir?\n\nAh, the eagle-eyed among you may have noticed that they `pytest` package\ncontains other fixtures that seem to be about temporary structures. Namely\n`tmpdir` and `tmpdir_factory`. These fixtures are older equivalents of the\nfixtures we discussed above. The main difference is that instead of returning\n`pathlib.Path` objects, they return `py.path.local` objects. These fixtures\nwere written before `pathlib` had been adopted as the\n[standardised approach](https://peps.python.org/pep-0519/#standard-library-changes)\nto handling paths across multiple operating systems. These future of `tmpdir`\nand `tmpdir_factory` have been discussed for deprecation. These fixtures are\nbeing sunsetted and it is advised to port old test suites over to the new\n`tmp_path` fixture instead. The `pytest` team have\n[provided a utility](https://docs.pytest.org/en/7.1.x/how-to/tmp_path.html#the-tmpdir-and-tmpdir-factory-fixtures)\nto help developers identify these issues in their old test suites. \n\nIn summary, don't use `tmpdir` any more and consider converting old code if you\nused it in the past... \n\n\n\n## Summary\n\n...\n\n* ...\n\nIf you spot an error with this article, or have  suggested improvement then\nfeel free to\n[raise an issue on GitHub](https://github.com/r-leyshon/blogging/issues).  \n\nHappy testing!\n\n## Acknowledgements\n\nTo past and present colleagues who have helped to discuss pros and cons,\nestablishing practice and firming-up some opinions. Particularly:\n\n* Charlie\n* Dan\n* Edward\n* Ian\n\n<p id=fin><i>fin!</i></p>\n\n",
    "supporting": [
      "12-pytest-tmp-path_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}