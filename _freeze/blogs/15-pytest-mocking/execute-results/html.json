{
  "hash": "fb36ca52756b30e7572266ea53348d92",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Mocking With Pytest in Plain English\"\nauthor: \"Rich Leyshon\"\ndate: \"July 14 2024\"\ndescription: \"Plain English Comparison of Mocking Approaches in Python\"\ncategories:\n    - Explanation\n    - pytest\n    - Unit tests\n    - mocking\n    - pytest-in-plain-english\n    - mockito\n    - MagicMock\n    - monkeypatch\nimage: \"https://i.imgur.com/K0mxjuF.jpeg\"\nimage-alt: \"Soul singer with Joker makeup.\"\ntoc: true\njupyter: \n  kernelspec:\n    name: \"mocking-env\"\n    language: \"python\"\n    display_name: \"blog-mocking-env\"\ncss: /www/13-pytest-parametrize/styles.css\n---\n\n\n\n\n<figure class=center >\n  <img class=\"shaded_box\" width=400px src=\"https://i.imgur.com/K0mxjuF.jpeg\"></img>\n  <figcaption>The Joker sings the Green Green Grass of Home.</figcaption>\n</figure>\n\n> \"A day without laughter is a day wasted.\" Charlie Chaplin\n\n## Introduction\n\n`pytest` is a testing package for the python framework. It is broadly used to\nquality assure code logic. This article discusses the dark art of mocking, why\nyou should do it and the nuts and bolts of implementing mocked tests. This blog\nis the fourth in a series of blogs called\n[pytest in plain English](/blogs/index.qmd#category=pytest-in-plain-english),\nfavouring accessible language and simple examples to explain the more intricate\nfeatures of the `pytest` package.\n\nFor a wealth of documentation, guides and how-tos, please consult the\n<a href=\"https://docs.pytest.org/en/8.0.x/\" target=\"_blank\">`pytest` documentation</a>.\n\n### What does Mocking Mean?\n\nCode often has external dependencies:\n\n* Web APIs (as in this article)\n* Websites (if scraping / crawling)\n* External code (importing packages)\n* Data feeds and databases\n* Environment variables\n\nAs developers cannot control the behaviour of those dependencies, they would\nnot write tests dependent upon them. In order to test their source code that\ndepends on these services, developers need to replace the properties of these\nservices when the test suite runs. Injecting replacement values into the code\nat runtime is generally referred to as mocking. Mocking these values means that\ndevelopers can feed dependable results to their code and make reliable\nassertions about the code's behaviour, without changes in the 'outside world'\naffecting outcomes in the system under test.\n\nDevelopers who write unit tests may also mock their own code. The \"unit\" in the\nterm \"unit test\" implies complete isolation from external dependencies. Mocking\nis an indispensible tool in achieving that isolation within a test suite. It\nensures that code can be efficiently verified in any order, without\ndependencies on other elements in your codebase. However, mocking also adds to\ncode complexity, increasing cognitive load and generally making things harder\nto debug.\n\n:::{.callout collapse=\"true\"}\n\n### A Note on the Purpose (Click to expand)\n\nThis article intends to discuss clearly. It doesn't aim to be clever or\nimpressive. Its aim is to extend understanding without overwhelming the reader.\nThe code may not always be optimal, favouring a simplistic approach wherever\npossible.\n\n:::\n\n### Intended Audience\n\nProgrammers with a working knowledge of python, HTTP requests and some\nfamiliarity with `pytest` and packaging. The type of programmer who has\nwondered about how to follow best practice in testing python code.\n\n### What You'll Need:\n\n- [ ] Preferred python environment manager (eg `conda`)\n- [ ] `pip install pytest==8.1.1 requests mockito`\n- [ ] Git\n- [ ] GitHub account\n- [ ] Command line access\n\n### Preparation\n\nThis blog is accompanied by code in\n[this repository](https://github.com/r-leyshon/pytest-fiddly-examples). The\nmain branch provides a template with the minimum structure and requirements\nexpected to run a `pytest` suite. The repo branches contain the code used in\nthe examples of the following sections.\n\nFeel free to fork or clone the repo and checkout to the example branches as\nneeded.\n\nThe example code that accompanies this article is available in the\n[mocking branch](https://github.com/r-leyshon/pytest-fiddly-examples/tree/mocking)\nof the repo.\n\n## Overview\n\nMocking is one of the trickier elements of testing. It's a bit niche and is\noften perceived to be too hacky to be worth the effort. The options for mocking\nin python are numerous and this adds to the complexity of many example\nimplementations you will find online. \n\nThere is also a compromise in simplicity versus flexibility. Some of the\noptions available are quite involved and can be adapted to the nichest of\ncases, but may not be the best option for those new to mocking. With this in\nmind, I present 3 alternative methods for mocking python source code. So if\nyou'll forgive me, this is the first of the\n[`pytest` in plain English](/blogs/index.qmd#category=pytest-in-plain-english)\nseries where I introduce alternative testing practices from beyond the `pytest`\npackage.\n\n1. [**monkeypatch**][monkeypatch]: The `pytest` fixture designed for mocking. The\norigin of the fixture's name is debated but potentially arose from the term\n'guerrilla patch' which may have been misinterpreted as 'gorilla patch'. This\nis the concept of modifying source code at runtime, which probably sounds a bit\nlike 'monkeying with the code'.\n2. [**MagicMock**][magicmock]: This is the mocking object provided by python3's\nbuiltin `unittest` package.\n3. [**mockito**][mockito]: This package is based upon the popular Java framework\nof the same name. Despite having a user-friendly syntax, `mockito` is robust\nand secure.\n\n:::{.callout-note collapse=\"true\"}\n\n[monkeypatch]: https://docs.pytest.org/en/stable/how-to/monkeypatch.html\n[magicmock]: https://docs.python.org/3/library/unittest.mock.html\n[mockito]: https://mockito-python.readthedocs.io/en/latest/walk-through.html\n\n\n### A note on the language\n\nMocking has a bunch of synonyms & related language which can be a bit\noff-putting. All of the below terms are associated with mocking. Some may be\npreferred to the communities of specific programming frameworks over others.\n\n| Term          | Brief Meaning | Frameworks/Libraries |\n|---------------|---------------|----------------------|\n| Mocking       | Creating objects that simulate the behaviour of real objects for testing | Mockito (Java), unittest.mock (Python), Jest (JavaScript), Moq (.NET)            |\n| Spying        | Observing and recording method calls on real objects                    | Mockito (Java), Sinon (JavaScript), unittest.mock (Python), RSpec (Ruby) |\n| Stubbing      | Replacing methods with predefined behaviours or return values            | Sinon (JavaScript), RSpec (Ruby), PHPUnit (PHP), unittest.mock (Python)      |\n| Patching      | Temporarily modifying or replacing parts of code for testing            | unittest.mock (Python), pytest-mock (Python), PowerMock (Java)             |\n| Faking        | Creating simplified implementations of complex dependencies             | Faker (multiple languages), Factory Boy (Python), FactoryGirl (Ruby)           |\n| Dummy Objects | Placeholder objects passed around but never actually used               | Can be created in any testing framework                                          |\n\n:::\n\n## Mocking in Python\n\nThis section will walk through some code that uses HTTP requests to an external\nservice and how we can go about testing the code's behaviour without relying on\nthat service being available. Feel free to clone the repository and check out\nto the\n[example code](https://github.com/r-leyshon/pytest-fiddly-examples/tree/mocking)\nbranch to run the examples.\n\nThe purpose of the code is to retrieve jokes from <https://icanhazdadjoke.com/>\nlike so:\n\n\n\n::: {#22f4ab8a .cell execution_count=2}\n``` {.python .cell-code}\nfor _ in range(3):\n    print(get_joke(f=\"application/json\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDid you know that ghosts call their true love their ghoul-friend?\nWhy did the melons plan a big wedding? Because they cantaloupe!\nWant to hear a joke about construction? Nah, I'm still working on it.\n```\n:::\n:::\n\n\n::: {.callout-caution}\n\nThe jokes are provided by <https://icanhazdadjoke.com/> and are not curated by\nme. In my testing of the service I have found the jokes to be harmless fun, but\nI cannot guarantee that. If an offensive joke is returned, this is\nunintentional but\n[let me know about it](https://github.com/r-leyshon/blogging/issues) and I will\ngenerate new jokes.\n\n:::\n\n### Define the Source Code\n\nThe function `get_joke()` uses 2 internals:\n\n1. `_query_endpoint()` Used to construct the HTTP request with required headers\nand user agent.\n2. `_handle_response()` Used to catch HTTP errors, or to pull the text out of\nthe various response formats.\n\n::: {#1c9537f4 .cell execution_count=3}\n``` {.python .cell-code}\n\"\"\"Retrieve dad jokes available.\"\"\"\nimport requests\n\n\ndef _query_endpoint(\n    endp:str, usr_agent:str, f:str,\n    ) -> requests.models.Response:\n    \"\"\"Utility for formatting query string & requesting endpoint.\"\"\"\n    HEADERS = {\n        \"User-Agent\": usr_agent,\n        \"Accept\": f,\n        }\n    resp = requests.get(endp, headers=HEADERS)\n    return resp\n```\n:::\n\n\nKeeping separate, the part of the codebase that you wish to target for mocking\nis often the simplest way to go about things. The target for our mocking will\nbe the command that integrates with the external service, so `requests.get()`\nhere. \n\nThe use of `requests.get()` in the code above depends on a few things:\n\n1. An endpoint string.\n2. A dictionary with string values for the keys \"User-Agent\" and \"Accept\".\n\nWe'll need to consider those dependencies when mocking. Once we return a\nresponse from the external service, we need a utility to handle the various\nstatuses of that response:\n\n::: {#30ec7ede .cell execution_count=4}\n``` {.python .cell-code}\n\"\"\"Retrieve dad jokes available.\"\"\"\nimport requests\n\n\ndef _query_endpoint(\n    endp:str, usr_agent:str, f:str,\n    ) -> requests.models.Response:\n    ...\n\n\ndef _handle_response(r: requests.models.Response) -> str:\n    \"\"\"Utility for handling reponse object & returning text content.\n\n    Parameters\n    ----------\n    r : requests.models.Response\n        Response returned from webAPI endpoint.\n\n    Raises\n    ------\n    NotImplementedError\n        Requested format `f` was not either 'text/plain' or 'application/json'. \n    requests.HTTPError\n        HTTP error was encountered.\n    \"\"\"\n    if r.ok:\n        c_type = r.headers[\"Content-Type\"]\n        if c_type == \"application/json\":\n            content = r.json()\n            content = content[\"joke\"]\n        elif c_type == \"text/plain\":\n            content = r.text\n        else:\n            raise NotImplementedError(\n                \"This client accepts 'application/json' or 'text/plain' format\"\n                )\n    else:\n        raise requests.HTTPError(\n            f\"{r.status_code}: {r.reason}\"\n        )\n    return content\n```\n:::\n\n\nOnce `_query_endpoint()` gets us a response, we can feed it into\n`_handle_response()`, where different logic is executed depending on the\nresponse's properties. Specifically, any response we want to mock would need\nthe following:\n\n1. headers, containing a dictionary eg: `{\"content_type\": \"plain/text\"}`\n2. A `json()` method.\n3. `text`, `status_code` and `reason` attributes.\n\nFinally, the above functions get wrapped in the `get_joke()` function below:\n\n::: {#ef76e949 .cell execution_count=5}\n``` {.python .cell-code}\n\"\"\"Retrieve dad jokes available.\"\"\"\nimport requests\n\n\ndef _query_endpoint(\n    endp:str, usr_agent:str, f:str,\n    ) -> requests.models.Response:\n    ...\n\n\ndef _handle_response(r: requests.models.Response) -> str:\n    ...\n\n\ndef get_joke(\n    endp:str = \"https://icanhazdadjoke.com/\",\n    usr_agent:str = \"datasavvycorner.com (https://github.com/r-leyshon/pytest-fiddly-examples)\", \n    f:str = \"text/plain\",\n) -> str:\n    \"\"\"Request a joke from icanhazdadjoke.com.\n\n    Ask for a joke in either plain text or JSON format. Return the joke text.\n\n    Parameters\n    ----------\n    endp : str, optional\n        Endpoint to query, by default \"https://icanhazdadjoke.com/\"\n    usr_agent : str, optional\n        User agent value, by default\n        \"datasavvycorner.com (https://github.com/r-leyshon/pytest-fiddly-examples)\"\n    f : str, optional\n        Format to request eg \"application.json\", by default \"text/plain\"\n\n    Returns\n    -------\n    str\n        Joke text.\n    \"\"\"\n    r = _query_endpoint(endp=endp, usr_agent=usr_agent, f=f)\n    return _handle_response(r)\n```\n:::\n\n\n### Let's Get Testing\n\nThe behaviour in `get_joke()` is summarised in the flowchart below:\n\n<img style=\" display: block; margin-left: auto; margin-right: auto; width: 500px;\" src=\"https://i.imgur.com/ekrD8nH.png\" alt=\"get_joke() logic flow\">\n\nThere are 4 outcomes to check, coloured red and green in the process chart\nabove.\n\n1. `get_joke()` successfully returns joke text when the user asked for json\nformat.\n2. `get_joke()` successfully returns joke text when the user asked for plain\ntext.\n3. `get_joke()` raises `NotImplementedError` if any other valid format is asked\nfor. Note that the API also accepts HTML and image formats, though parsing the\njoke text out of those is more involved and beyond the scope of this blog.\n4. `get_joke()` raises a `HTTPError` if the response from the API was not ok.\n\nNote that the event that we wish to target for mocking is highlighted in blue - \nwe don't want our tests to execute any real requests.\n\nThe strategy for testing this function without making requests to the web API\nis composed of 4 similar steps, regardless of the package used to implement the\nmocking. \n\n<img style=\" display: block; margin-left: auto; margin-right: auto; width: 800px;\" src=https://i.imgur.com/jRAdI1d.png alt=\"4 step mocking strategy\">\n\n1.  **Mock:** Define the object or property that you wish to use as a\nreplacement. This could be a static value or something a bit more involved,\nlike a mock class that can return dynamic values depending upon the values it\nreceives. \n2. **Patch:** Replace part of the source code with our mock value. \n3. **Use:** Use the source code to return a value.\n4. **Assert:** Check the returned value is what you expect.\n\nIn the examples that follow, I will label the equivalent steps for the various\nmocking implementations.\n\n### The \"Ultimate Joke\"\n\nWhat hard-coded text shall I use for my expected joke? I'll\n[create a fixture](/blogs/11-fiddly-bits-of-pytest.qmd) that will serve\nup this joke text to all of the test modules used below. I'm only going to\ndefine it once and then refer to it throughout several examples below. So it\nneeds to be a pretty memorable, awesome joke.\n\n::: {#50cc18ef .cell execution_count=6}\n``` {.python .cell-code}\nimport pytest\n\n\n@pytest.fixture(scope=\"session\")\ndef ULTI_JOKE():\n    return (\"Doc, I can't stop singing 'The Green, Green Grass of Home.' That \"\n    \"sounds like Tom Jones Syndrome. Is it common? Well, It's Not Unusual.\")\n```\n:::\n\n\nBeing a Welshman, I may be a bit biased. But that's a pretty memorable dad joke\nin my opinion. This joke will be available to every test within my test suite\nwhen I execute `pytest` from the command line. The assertions that we will\nuse when using `get_joke()` will expect this string to be returned. If some\nother joke is returned, then we have not mocked correctly and an HTTP request\nwas sent to the API.\n\n### Mocking Everything\n\nI'll start with an example of how to mock `get_joke()` completely. This is an\nintentionally bad idea. In doing this, the test won't actually be executing any\nof the code, just returning a hard-coded value for the joke text. All this does\nis prove that the mocking works as expected and has nothing to do with the\nlogic in our source code. \n\nSo why am I doing it? Hopefully I can illustrate the most basic implementation\nof mocking in this way. I'm not having to think about how I can mock a response\nobject with all the required properties. I just need to provide some hard coded\ntext. \n\n:::{.panel-tabset}\n\n#### monkeypatch\n\n::: {#d4087867 .cell execution_count=7}\n``` {.python .cell-code}\nimport example_pkg.only_joking\n\n\ndef test_get_joke_monkeypatched_entirely(monkeypatch, ULTI_JOKE):\n    \"\"\"Completely replace the entire get_joke return value.\n\n    Not a good idea for testing as none of our source code will be tested. But\n    this demonstrates how to entirely scrub a function and replace with any\n    placeholder value at pytest runtime.\"\"\"\n    # step 1\n    def _mock_joke():\n        \"\"\"Return the joke text.\n\n        monkeypatch.setattr expects the value argument to be callable. In plain\n        English, a function or class.\"\"\"\n        return ULTI_JOKE\n    # step 2\n    monkeypatch.setattr(\n        target=example_pkg.only_joking,\n        name=\"get_joke\",\n        value=_mock_joke\n        )\n    # step 3 & 4\n    # Use the module's namespace to correspond with the monkeypatch\n    assert example_pkg.only_joking.get_joke() == ULTI_JOKE \n```\n:::\n\n\n:::{.callout-note}\n\n##### Notes\n\n* **Step 1**\n    * Step 2 requires the hard coded text to be returned from a callable, like\n    a function or class. So we define `_mock_joke` to serve the text in the\n    required format.\n* **Step 2**\n    * `monkeypatch.setattr()` is able to take the module namespace that we\n    imported as the target. This must be the namespace where the function\n    (or variable etc) is defined.\n* **Step 3**\n    * When invoking the function, be sure to reference the function in the same\n    way as it was monkeypatched.\n    * Aliases can also be used if preferable\n    (eg `import example_pkg.only_joking as jk`). Be sure to update your\n    reference to `get_joke()` in step 2 and 3 to match your import statement.\n\n:::\n\n#### MagicMock\n\n::: {#bea5dbca .cell execution_count=8}\n``` {.python .cell-code}\nfrom unittest.mock import MagicMock, patch\n\nimport example_pkg.only_joking\n\n\ndef test_get_joke_magicmocked_entirely(ULTI_JOKE):\n    \"\"\"Completely replace the entire get_joke return value.\n\n    Not a good idea for testing as none of our source code will be tested. But\n    this demonstrates how to entirely scrub a function and replace with any\n    placeholder value at pytest runtime.\"\"\"\n    # step 1\n    _mock_joke = MagicMock(return_value=ULTI_JOKE)\n    # step 2\n    with patch(\"example_pkg.only_joking.get_joke\", _mock_joke):\n        # step 3\n        joke = example_pkg.only_joking.get_joke()\n        # step 4\n        assert joke == ULTI_JOKE\n```\n:::\n\n\n:::{.callout-note}\n\n##### Notes\n\n* **Step 1**\n    * `MagicMock()` allows us to return static values as mock objects.\n* **Step 3**\n    * When you use `get_joke()`, be sure to call reference the namespace in the\n    same way as to your patch in step 2.\n\n:::\n\n#### mockito\n\n::: {#f29f521c .cell execution_count=9}\n``` {.python .cell-code}\nfrom mockito import when, unstub\n\nimport example_pkg.only_joking\n\n\ndef test_get_joke_mockitoed_entirely(ULTI_JOKE):\n    \"\"\"Completely replace the entire get_joke return value.\n\n    Not a good idea for testing as none of our source code will be tested. But\n    this demonstrates how to entirely scrub a function and replace with any\n    placeholder value at pytest runtime.\"\"\"\n    # step 1 & 2\n    when(example_pkg.only_joking).get_joke().thenReturn(ULTI_JOKE)\n    # step 3\n    joke = example_pkg.only_joking.get_joke()\n    # step 4\n    assert joke == ULTI_JOKE\n    unstub()\n```\n:::\n\n\n:::{.callout-note}\n\n##### Notes\n\n* **Step 1 & 2**\n    * `mockito`'s intuitive `when(...).thenReturn(...)` pattern allows you\n    to reference any object within the imported namespace. Like with\n    `MagicMock`, the static string `ULTI_JOKE` can be referenced.\n* **Step 3**\n    * When you use `get_joke()`, be sure to call reference the namespace in the\n    same way as to your patch in step 2.\n* **unstub**\n    * This step explicitly 'unpatches' `get_joke()`. If you did not `unstub()`,\n    the patch to `get_joke()` would persist through the rest of your tests.\n    * `mockito` allows you to implicitly `unstub()` by using the context\n    manager `with`.\n\n:::\n\n:::\n\n### `monkeypatch()` without OOP\n\nSomething I've noticed about the `pytest` documentation for `monkeypatch`, is\nthat it gets straight into mocking with Object Oriented Programming (OOP).\nWhile this may be a bit more convenient, it is certainly not a requirement of\nusing `monkeypatch` and definitely adds to the cognitive load for new users.\nThis first example will mock the value of `requests.get` without using classes.\n\n::: {#8609db44 .cell execution_count=10}\n``` {.python .cell-code}\nimport requests\n\nfrom example_pkg.only_joking import get_joke\n\n\ndef test_get_joke_monkeypatched_no_OOP(monkeypatch, ULTI_JOKE):\n    # step 1: Mock the response object\n    def _mock_response(*args, **kwargs):\n        resp = requests.models.Response()\n        resp.status_code = 200\n        resp._content = ULTI_JOKE.encode(\"UTF8\")\n        resp.headers = {\"Content-Type\": \"text/plain\"}\n        return resp\n    \n    # step 2: Patch requests.get\n    monkeypatch.setattr(requests, \"get\", _mock_response)\n    # step 3: Use requests.get\n    joke = get_joke()\n    # step 4: Assert\n    assert joke == ULTI_JOKE, f\"Expected:\\n'{ULTI_JOKE}\\nFound:\\n{joke}'\"\n    # will also work for json format\n    joke = get_joke(f=\"application/json\")\n    assert joke == ULTI_JOKE, f\"Expected:\\n'{ULTI_JOKE}\\nFound:\\n{joke}'\"\n```\n:::\n\n\n:::{.callout-note}\n\n##### Notes\n\n* **Step 1**\n    * The return value of `requests.get()` will be a response object. We need\n    to mock this object with the methods and attributes required by the\n    `_handle_response()` function. \n    * We need to encode the static joke text as bytes to format the data. \n    Response objects encode data as bytes for interoperatability and\n    optimisation purposes.\n* **step4**\n    * As we have set an appropriate value for the mocked response's `_content`\n    attribute, the mocked joke will be returned for both JSON and plain text\n    formats - very convenient!\n\n:::\n\n### Condition 1: Test JSON\n\nIn this example, we demonstrate the same functionality as above, but the\n`monkeypatch` example will use an object-oriented design pattern. This approach\nmore closely follows that of the `pytest` documentation. As before, `MagicMock`\nand `mockito` examples will be included. \n\nThe purpose of this test is to test the outcome of `get_joke()` when the user\nspecifies a json format.\n\n:::{.panel-tabset}\n\n#### monkeypatch\n\n::: {#monkey-fixture .cell execution_count=11}\n``` {.python .cell-code}\nimport pytest\nimport requests\n\nfrom example_pkg.only_joking import get_joke\n\n\n@pytest.fixture\ndef _mock_response(ULTI_JOKE):\n    \"\"\"Return a class instance that will mock all the properties of a response\n    object that get_joke needs to work.\n    \"\"\"\n    HEADERS_MAP = {\n        \"text/plain\": {\"Content-Type\": \"text/plain\"},\n        \"application/json\": {\"Content-Type\": \"application/json\"},\n        \"text/html\": {\"Content-Type\": \"text/html\"},\n    }\n\n    class MockResponse:\n        def __init__(self, f, *args, **kwargs):\n            self.ok = True\n            self.f = f\n            self.headers = HEADERS_MAP[f] # header corresponds to format that\n            # the user requested\n            self.text = ULTI_JOKE \n\n        def json(self):\n            if self.f == \"application/json\":\n                return {\"joke\": ULTI_JOKE}\n            return None\n\n    return MockResponse\n\n\ndef test_get_joke_json_monkeypatched(monkeypatch, _mock_response, ULTI_JOKE):\n    \"\"\"Test behaviour when user asked for JSON joke.\n\n    Test get_joke using the mock class fixture. This approach is the\n    implementation suggested in the pytest docs.\n    \"\"\"\n    # step 1: Mock\n    def _mock_get_good_resp(*args, **kwargs):\n        \"\"\"Return fixtures with the correct header.\n\n        If the test uses \"text/plain\" format, we need to return a MockResponse\n        class instance with headers attribute equal to\n        {\"Content-Type\": \"text/plain\"}, likewise for JSON.\n        \"\"\"\n        f = kwargs[\"headers\"][\"Accept\"]\n        return _mock_response(f)\n    # Step 2: Patch\n    monkeypatch.setattr(requests, \"get\", _mock_get_good_resp)\n    # Step 3: Use\n    j_json = get_joke(f=\"application/json\")\n    # Step 4: Assert\n    assert j_json == ULTI_JOKE, f\"Expected:\\n'{ULTI_JOKE}\\nFound:\\n{j_json}'\"\n```\n:::\n\n\n:::{.callout-note}\n\n##### Notes\n\n* **Step 1**\n    * We define a mocked class instance with the necessary properties expected\n    by `_handle_response()`.\n    * The mocked response is served to our test as a `pytest` fixture.\n    * Within the test, we need another function, which will be able to take\n    the arguments passed to `requests.get()`. This will allow our class\n    instance to retrieve the appropriate header from the `HEADERS_MAP`\n    dictionary.\n\nAs you may appreciate, this does not appear to be the most straight forward\nimplementation, but it will allow us to test when the user asks for JSON,\nplain text or HTML formats. In the above test, we assert against JSON format\nonly.\n\n:::\n\n#### MagicMock\n\n::: {#77e69e10 .cell execution_count=12}\n``` {.python .cell-code}\nfrom unittest.mock import MagicMock, patch\nimport requests\n\nfrom example_pkg.only_joking import get_joke\n\n\ndef test_get_joke_json_magicmocked(ULTI_JOKE):\n    \"\"\"Test behaviour when user asked for JSON joke.\"\"\"\n    # step 1: Mock\n    mock_response = MagicMock(spec=requests.models.Response)\n    mock_response.ok = True\n    mock_response.headers = {\"Content-Type\": \"application/json\"}\n    mock_response.json.return_value = {\"joke\": ULTI_JOKE}\n    # step 2: Patch\n    with patch(\"requests.get\", return_value=mock_response):\n        # step 3: Use\n        joke = get_joke(f=\"application/json\")\n        # step 4: Assert\n        assert joke == ULTI_JOKE\n```\n:::\n\n\n:::{.callout-note}\n\n##### Notes\n\n* **Step 1**\n    * `MagicMock()` can return a mock object with a specification designed to\n    mock response objects. Super useful.\n    * Our static joke content can be served directly to `MagicMock` without the\n    need for an intermediate class.\n    * In comparison to the `monkeypatch` approach, this appears to be more\n    straight forward and maintainable.\n:::\n\n#### mockito\n\n::: {#731e5bde .cell execution_count=13}\n``` {.python .cell-code}\nfrom mockito import when, unstub\nimport requests\n\nimport example_pkg.only_joking\n\n\ndef test_get_joke_json_mockitoed(ULTI_JOKE):\n    \"\"\"Test behaviour when user asked for JSON joke.\"\"\"\n    # step 1: Mock\n    _mock_response = requests.models.Response()\n    _mock_response.status_code = 200\n    _mock_response._content = b'{\"joke\": \"' + ULTI_JOKE.encode(\"utf-8\") + b'\"}'\n    _mock_response.headers = {\"Content-Type\": \"application/json\"}\n    # step 2: Patch\n    when(requests).get(...).thenReturn(_mock_response)\n    # step 3: Use\n    joke = example_pkg.only_joking.get_joke(f=\"application/json\")\n    # step 4: Assert\n    assert joke == ULTI_JOKE\n    unstub()\n```\n:::\n\n\n:::{.callout-note}\n\n##### Notes\n\n* **Step 1**\n    * In order to encode the expected joke for JSON format, we need a\n    dictionary encoded within a bytestring. This bit is a little tricky.\n    * Alternatively, define the expected dictionary and use the `json`\n    package. `json.dumps(dict).encode(\"UTF8\")` will format the content\n    dictionary in the required way.\n* **Step 2**\n    * `mockito`'s `when()` approach will allow you to access the methods of the\n    object that is being patched, in this case `requests`. \n    * `mockito` allows you to pass the `...` argument to a patched method, to\n    indicate that whatever arguments were passed to `get()`, return the\n    specified mock value.\n    * Being able to specify values passed in place of `...` will allow you to\n    set different return values depending on argument values received by\n    `get()`.\n:::\n\n:::\n\n### Condition 2: Test Plain Text\n\nThe purpose of this test is to check the outcome when the user specifies a\nplain/text format while using `get_joke()`.\n\n:::{.panel-tabset}\n\n#### monkeypatch\n\n::: {#dfba4446 .cell execution_count=14}\n``` {.python .cell-code}\nimport pytest\nimport requests\n\nfrom example_pkg.only_joking import get_joke\n\n\n@pytest.fixture\ndef _mock_response(ULTI_JOKE):\n    \"\"\"The same fixture as was used for testing JSON format\"\"\"\n    ...\n\n\ndef test_get_joke_text_monkeypatched(monkeypatch, _mock_response, ULTI_JOKE):\n    \"\"\"Test behaviour when user asked for plain text joke.\"\"\"\n    # step 1: Mock\n    def _mock_get_good_resp(*args, **kwargs):\n        f = kwargs[\"headers\"][\"Accept\"]\n        return _mock_response(f)\n    # step 2: Patch\n    monkeypatch.setattr(requests, \"get\", _mock_get_good_resp)\n    # step 3: Use\n    j_txt = get_joke(f=\"text/plain\")\n    # step 4: Assert\n    assert j_txt == ULTI_JOKE, f\"Expected:\\n'{ULTI_JOKE}\\nFound:\\n{j_txt}'\"\n```\n:::\n\n\n:::{.callout-note}\n\n##### Notes\n\n* **Step 1**\n    * We can use the same mock class as for testing\n    [Condition 1](#monkey-fixture), due to the content of the `HEADERS_MAP`\n    dictionary.\n:::\n\n#### MagicMock\n\n::: {#02078611 .cell execution_count=15}\n``` {.python .cell-code}\nfrom unittest.mock import MagicMock, patch\nimport requests\n\nfrom example_pkg.only_joking import get_joke\n\n\ndef test_get_joke_text_magicmocked(ULTI_JOKE):\n    \"\"\"Test behaviour when user asked for plain text joke.\"\"\"\n    # step 1: Mock\n    mock_response = MagicMock(spec=requests.models.Response)\n    mock_response.ok = True\n    mock_response.headers = {\"Content-Type\": \"text/plain\"}\n    mock_response.text = ULTI_JOKE\n    # step 2: Patch\n    with patch(\"requests.get\", return_value=mock_response):\n        # step 3: Use\n        joke = get_joke(f=\"text/plain\")\n        # step 4: Assert\n        assert joke == ULTI_JOKE\n```\n:::\n\n\n#### mockito\n\n::: {#875499a4 .cell execution_count=16}\n``` {.python .cell-code}\nfrom mockito import when, unstub\nimport requests\n\nimport example_pkg.only_joking\n\ndef test_get_joke_text_mockitoed(ULTI_JOKE):\n    \"\"\"Test behaviour when user asked for plain text joke.\"\"\"\n    # step 1: Mock\n    mock_response = requests.models.Response()\n    mock_response.status_code = 200\n    mock_response._content = ULTI_JOKE.encode(\"utf-8\")\n    mock_response.headers = {\"Content-Type\": \"text/plain\"}\n    # step 2: Patch\n    when(requests).get(...).thenReturn(mock_response)\n    # step 3: Use\n    joke = example_pkg.only_joking.get_joke(f=\"text/plain\")\n    # step 4: Assert\n    assert joke == ULTI_JOKE\n    unstub()\n```\n:::\n\n\n:::\n\n### Condition 3: Test Not Implemented\n\nThis test will check the outcome of what happens when the user asks for a\nformat other than text or JSON format. As the webAPI also offers image or HTML\nformats, a response 200 (ok) would be returned from the service. But I was too\nbusy (lazy) to extract the text from those formats. \n\n:::{.panel-tabset}\n\n#### monkeypatch\n\n::: {#98687e57 .cell execution_count=17}\n``` {.python .cell-code}\nimport pytest\nimport requests\n\nfrom example_pkg.only_joking import get_joke\n\n\n@pytest.fixture\ndef _mock_response(ULTI_JOKE):\n    \"\"\"The same fixture as was used for testing JSON format\"\"\"\n    ...\n\n\ndef test_get_joke_not_implemented_monkeypatched(\n    monkeypatch, _mock_response):\n    \"\"\"Test behaviour when user asked for HTML response.\"\"\"\n    #  step 1: Mock\n    def _mock_get_good_resp(*args, **kwargs):\n        f = kwargs[\"headers\"][\"Accept\"]\n        return _mock_response(f)\n    # step 2: Patch\n    monkeypatch.setattr(requests, \"get\", _mock_get_good_resp)\n    # step 3 & 4 Use (try to but exception is raised) & Assert\n    with pytest.raises(\n        NotImplementedError,\n        match=\"This client accepts 'application/json' or 'text/plain' format\"):\n        get_joke(f=\"text/html\")\n```\n:::\n\n\n:::{.callout-note}\n\n##### Notes\n\n* **Step 1**\n    * We can use the same mock class as for testing\n    [Condition 1](#monkey-fixture), due to the content of the `HEADERS_MAP`\n    dictionary.\n* **Step 4**\n    * We use a context manager (`with pytest.raises`) which catches the raised\n    exception and stops it from terminating our `pytest` session. \n    * The asserted `match` argument can take a regular expression, so that\n    wildcard patterns can be used. This allows matching of part of the\n    exception message.\n:::\n\n#### MagicMock\n\n::: {#3bd0d245 .cell execution_count=18}\n``` {.python .cell-code}\nimport pytest\nimport requests\nfrom unittest.mock import MagicMock, patch\n\nfrom example_pkg.only_joking import get_joke\ndef test__handle_response_not_implemented_magicmocked():\n    \"\"\"Test behaviour when user asked for HTML response.\"\"\"\n    # step 1: Mock\n    mock_response = MagicMock(spec=requests.models.Response)\n    mock_response.ok = True\n    mock_response.headers = {\"Content-Type\": \"text/html\"}\n    #  step 2: Patch\n    with patch(\"requests.get\", return_value=mock_response):\n        # step 3 & 4 Use (try to but exception is raised) & Assert\n        with pytest.raises(\n            NotImplementedError,\n            match=\"client accepts 'application/json' or 'text/plain' format\"):\n            get_joke(f=\"text/html\")\n```\n:::\n\n\n#### mockito\n\n::: {#bca954e0 .cell execution_count=19}\n``` {.python .cell-code}\nfrom mockito import when, unstub\nimport requests\n\nimport example_pkg.only_joking\n\ndef test_get_joke_not_implemented_mockitoed():\n    \"\"\"Test behaviour when user asked for HTML response.\"\"\"\n    # step 1: Mock\n    mock_response = requests.models.Response()\n    mock_response.status_code = 200\n    mock_response.headers = {\"Content-Type\": \"text/html\"}\n    # step 2: Patch\n    when(\n        example_pkg.only_joking\n        )._query_endpoint(...).thenReturn(mock_response)\n    # step 3 & 4 Use (try to but exception is raised) & Assert\n    with pytest.raises(\n        NotImplementedError,\n        match=\"This client accepts 'application/json' or 'text/plain' format\"):\n        example_pkg.only_joking.get_joke(f=\"text/html\")\n    unstub()\n```\n:::\n\n\n:::\n\n### Condition 4: Test Bad Response\n\nIn this test, we simulate a bad response from the webAPI, which could arise\nfor a number of reasons:\n\n* The api is unavailable.\n* The request asked for a resource that is not available.\n* Too many requests were made in a short period.\n\nThese conditions are those that we have the least control over and therefore\nhave the greatest need for mocking.\n\n:::{.panel-tabset}\n\n#### monkeypatch\n\n::: {#ef8a5627 .cell execution_count=20}\n``` {.python .cell-code}\nimport pytest\nimport requests\n\nfrom example_pkg.only_joking import get_joke, _handle_response\n\n\n@pytest.fixture\ndef _mock_bad_response():\n    class MockBadResponse:\n        def __init__(self, *args, **kwargs):\n            self.ok = False\n            self.status_code = 404\n            self.reason = \"Not Found\"\n    return MockBadResponse\n\n\ndef test_get_joke_http_error_monkeypatched(\n    monkeypatch, _mock_bad_response):\n    \"\"\"Test bad HTTP response.\"\"\"\n    #  step 1: Mock\n    def _mock_get_bad_response(*args, **kwargs):\n        f = kwargs[\"headers\"][\"Accept\"]\n        return _mock_bad_response(f)\n    #  step 2: Patch\n    monkeypatch.setattr(requests, \"get\", _mock_get_bad_response)\n    # step 3 & 4 Use (try to but exception is raised) & Assert\n    with pytest.raises(requests.HTTPError, match=\"404: Not Found\"):\n        get_joke()\n```\n:::\n\n\n:::{.callout-note}\n\n##### Notes\n\n* **Step 1**\n    * This time we need to define a new fixture that returns a bad response.\n    * Alternatively, we could have implemented a single fixture for all of our\n    tests that dynamically served a good or bad response dependent upon\n    arguments passed to `get_joke()`, for example different string values\n    passed as the endpoint.\n    * In a more thorough implementation of `get_joke()`, you may wish to retry\n    the request for certain HTTP error status codes. The ability to provide\n    mocked objects that reliably serve those statuses allow you to\n    deterministically validate your code's behaviour.\n\n:::\n\n#### MagicMock\n\n::: {#01ce7e91 .cell execution_count=21}\n``` {.python .cell-code}\nimport pytest\nfrom unittest.mock import MagicMock, patch\nimport requests\n\nfrom example_pkg.only_joking import get_joke\n\n\ndef test_get_joke_http_error_magicmocked():\n    \"\"\"Test bad HTTP response.\"\"\"\n    # step 1: Mock\n    _mock_response = MagicMock(spec=requests.models.Response)\n    _mock_response.ok = False\n    _mock_response.status_code = 404\n    _mock_response.reason = \"Not Found\"\n    # step 2: Patch\n    with patch(\"requests.get\", return_value=_mock_response):\n        # step 3 & 4 Use (try to but exception is raised) & Assert\n        with pytest.raises(requests.HTTPError, match=\"404: Not Found\"):\n            get_joke()\n```\n:::\n\n\n#### mockito\n\n::: {#dd4024ad .cell execution_count=22}\n``` {.python .cell-code}\nfrom mockito import when, unstub\nimport requests\n\nimport example_pkg.only_joking\n\n\ndef test_get_joke_http_error_mockitoed():\n    \"\"\"Test bad HTTP response.\"\"\"\n    # step 1: Mock\n    _mock_response = requests.models.Response()\n    _mock_response.status_code = 404\n    _mock_response.reason = \"Not Found\"\n    # step 2: Patch\n    when(example_pkg.only_joking)._query_endpoint(...).thenReturn(\n        _mock_response)\n    # step 3 & 4 Use (try to but exception is raised) & Assert\n    with pytest.raises(requests.HTTPError, match=\"404: Not Found\"):\n        example_pkg.only_joking.get_joke()\n    unstub()\n```\n:::\n\n\n:::\n\n\n## Summary\n\nWe have thoroughly tested our code using approaches that mock the behaviour of\nan external webAPI. We have also seen how to implement those tests with 3\ndifferent packages.\n\nI hope that this has provided you with enough introductory material to begin\nmocking tests if you have not done so before. If you find that your specific\nuse case for mocking is quite nuanced and fiddly (it's likely to be that way),\nthen the alternative implementations presented here can help you to understand\nhow to solve your specific mocking dilemma. \n\nOne final quote for those developers having their patience tested by errors\nattempting to implement mocking:\n\n> \"He who laughs last, laughs loudest.\"\n\n...or she for that matter: Don't give up!\n\nIf you spot an error with this article, or have a suggested improvement then\nfeel free to\n[raise an issue on GitHub](https://github.com/r-leyshon/blogging/issues).  \n\nHappy testing!\n\n## Acknowledgements\n\nTo past and present colleagues who have helped to discuss pros and cons,\nestablishing practice and firming-up some opinions. Special thanks to Edward\nfor bringing `mockito` to my attention.\n\nThe diagrams used in this article were produced with the excellent\n[Excalidraw](https://excalidraw.com/).\n\n<p id=fin><i>fin!</i></p>\n\n",
    "supporting": [
      "15-pytest-mocking_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}