{
  "hash": "e00db3d02eee6400ed272f9a88744102",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Parametrized Tests With Pytest in Plain English\"\nauthor: \"Rich Leyshon\"\ndate: \"June 07 2024\"\ndescription: \"Plain English Discussion of Pytest Parametrize\"\ncategories:\n    - Explanation\n    - pytest\n    - Unit tests\n    - parametrize\n    - pytest-in-plain-english\nimage: /./www/13-pytest-parametrize/intro-img.jpg\nimage-alt: \"Futuristic Russian dolls on a conveyor belt.\"\ntoc: true\njupyter: \n  kernelspec:\n    name: \"pytest-env\"\n    language: \"python\"\n    display_name: \"pytest-env\"\ncss: /www/13-pytest-parametrize/styles.css\nformat:\n  html:\n    mermaid:\n      theme: forest\n---\n\n<img class=shaded_box src=/./www/13-pytest-parametrize/intro-img.jpg alt=\"Futuristic Russian dolls on a conveyor belt.\" style=\"display:block;margin-left:auto;margin-right:auto;width:40%;border:none;\">\n\n## Introduction\n\n`pytest` is a testing package for the python framework. It is broadly used to\nquality assure code logic. This article discusses what parametrized tests mean\nand how to implement them with `pytest`. This blog is the third in a series of\nblogs called\n[pytest in plain English](/blogs/index.qmd#category=pytest-in-plain-english),\nfavouring accessible language and simple examples to explain the more intricate\nfeatures of the `pytest` package.\n\nFor a wealth of documentation, guides and how-tos, please consult the\n<a href=\"https://docs.pytest.org/en/8.0.x/\" target=\"_blank\">`pytest` documentation</a>.\n\n:::{.callout collapse=\"true\"}\n\n### A Note on the Purpose (Click to expand)\n\nThis article intends to discuss clearly. It doesn't aim to be clever or\nimpressive. Its aim is to extend understanding without overwhelming the reader.\n\n:::\n\n### Intended Audience\n\nProgrammers with a working knowledge of python and some familiarity with\n`pytest` and packaging. The type of programmer who has wondered about how to\nfollow best practice in testing python code.\n\n### What You'll Need:\n\n- [ ] Preferred python environment manager (eg `conda`)\n- [ ] `pip install pytest==8.1.1`\n- [ ] Git\n- [ ] GitHub account\n- [ ] Command line access\n\n### Preparation\n\nThis blog is accompanied by code in\n[this repository](https://github.com/r-leyshon/pytest-fiddly-examples). The\nmain branch provides a template with the minimum structure and requirements\nexpected to run a `pytest` suite. The repo branches contain the code used in\nthe examples of the following sections.\n\nFeel free to fork or clone the repo and checkout to the example branches as\nneeded.\n\nThe example code that accompanies this article is available in the\n[parametrize branch](https://github.com/r-leyshon/pytest-fiddly-examples/tree/parametrize)\nof the repo.\n\n## Overview\n\n### What Are Parametrized Tests?\n\nParametrized tests are simply tests that are applied recursively to multiple\ninput values. For example, rather than testing a function on one input value,\na list of different values could be passed as a parametrized fixture.\n\nA standard approach to testing could look like Figure 1 below, where separate\ntests are defined for the different values we need to check. This would likely\nresult in a fair amount of repeated boilerplate code.\n\n```{mermaid}\n%%| label: fig-no-parametrize\n%%| fig-cap: \"Testing multiple values without parametrization\"\nflowchart LR\n    subgraph tests [Separate Test Functions]\n        T1[test_value_1]\n        T2[test_value_2]\n        T3[test_value_3]\n        T4[test_value_n...]\n    end\n    T1 --> F[function]\n    T2 --> F\n    T3 --> F\n    T4 --> F\n```\n\nInstead, we can reduce the number of tests down to 1 and pass a list of tuples\nto the test instead. Each tuple should contain a parameter value and the\nexpected result, as illustrated in Figure 2.\n\n```{mermaid}\n%%| label: fig-parametrize\n%%| fig-cap: \"Parametrized testing of multiple values\"\nflowchart LR\n    subgraph params [Parametrized Fixture]\n        P[\"[(val1, exp1), (val2, exp2), (val3, exp3)]\"]\n    end\n    params --> T[Single Test Function]\n    T --> F[function]\n```\n\nSo let's imagine we have a simple function called `double()`, the setup for the\nparametrized list is illustrated in Figure 3.\n\n```{mermaid}\n%%| label: fig-test-double\n%%| fig-cap: \"Exemplified parametrization for test_double()\"\nflowchart LR\n    subgraph fixture [\"@pytest.mark.parametrize\"]\n        direction TB\n        R1[\"(2, 4)\"]\n        R2[\"(3, 6)\"]\n        R3[\"(5, 10)\"]\n    end\n    fixture --> T[\"test_double(input, expected)\"]\n    T --> D[\"double(input)\"]\n    D --> A[\"assert result == expected\"]\n```\n\n### Why use Parametrization?\n\nThis approach allows us to thoroughly check the behaviour of our functions\nagainst multiple values, ensuring that edge-cases are safely treated or\nexceptions are raised as expected. \n\nIn this way, we serve multiple parameters and expected outcomes to a single\ntest, reducing boilerplate code. Parametrization is not a silver bullet, and we\nstill need to define all of our parameters and results in a parametrized\nfixture. This approach is not quite as flexible as the property-based testing\nachievable with a package such as\n[`hypothesis`](https://hypothesis.readthedocs.io/en/latest/). However, the\nlearning curve for `hypothesis` is a bit greater and may be disproportionate to\nthe job at hand.\n\nFor the reasons outlined above, there are likely many competent python\ndevelopers that never use parametrized fixtures. But parametrization does allow\nus to avoid implementing tests with a `for` loop or vectorized approaches to\nthe same outcomes. When coupled with programmatic approaches to generating our\ninput parameters, many lines of code can be saved. And things get even more\ninteresting when we pass multiple parametrized fixtures to our tests, which\nI'll come to in a bit. For these reasons, I believe that awareness of\nparametrization should be promoted among python developers as a useful solution\nin the software development toolkit.\n\n## Implementing Parametrization\n\nIn this section, we will compare some very simple examples of tests with and\nwithout parametrization. Feel free to clone the repository and check out to the\n[example code](https://github.com/r-leyshon/pytest-fiddly-examples/tree/parametrize)\nbranch to run the examples.\n\n### Define the Source Code\n\nHere we define a very basic function that checks whether an integer is prime.\nIf a prime is encountered, then True is returned. If not, then False. The value\n1 gets its own treatment (return `False`). Lastly, we include some basic\ndefensive checks, we return a `TypeError` if anything other than integer is\npassed to the function and a `ValueError` if the integer is less than or equal\nto 0.\n\n::: {#260f782d .cell execution_count=1}\n``` {.python .cell-code}\ndef is_num_prime(pos_int: int) -> bool:\n    \"\"\"Check if a positive integer is a prime number.\n\n    Parameters\n    ----------\n    pos_int : int\n        A positive integer.\n\n    Returns\n    -------\n    bool\n        True if the number is a prime number.\n\n    Raises\n    ------\n    TypeError\n        Value passed to `pos_int` is not an integer.\n    ValueError\n        Value passed to `pos_int` is less than or equal to 0.\n    \"\"\"\n    if not isinstance(pos_int, int):\n        raise TypeError(\"`pos_int` must be a positive integer.\")\n    if pos_int <= 0:\n        raise ValueError(\"`pos_int` must be a positive integer.\")\n    elif pos_int == 1:\n        return False\n    else:\n        for i in range(2, (pos_int // 2) + 1):\n            # If divisible by any number 2<>(n/2)+1, it is not prime\n            if (pos_int % i) == 0:\n                return False\n        else:\n            return True\n```\n:::\n\n\nRunning this function with a range of values demonstrates its behaviour.\n\n::: {#0258bd21 .cell execution_count=2}\n``` {.python .cell-code}\nfor i in range(1, 11):\n  print(f\"{i}: {is_num_prime(i)}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1: False\n2: True\n3: True\n4: False\n5: True\n6: False\n7: True\n8: False\n9: False\n10: False\n```\n:::\n:::\n\n\n### Let's Get Testing\n\nLet's begin with the defensive tests. Let's say I need to check that the\nfunction can be relied upon to raise on a number of conditions. The typical\napproach may be to test the raise conditions within a dedicated test function.\n\n::: {#37be9691 .cell execution_count=3}\n``` {.python .cell-code}\n\"\"\"Tests for primes module.\"\"\"\nimport pytest\n\nfrom example_pkg.primes import is_num_prime\n\n\ndef test_is_num_primes_exceptions_manually():\n    \"\"\"Testing the function's defensive checks.\n\n    Here we have to repeat a fair bit of pytest boilerplate.\n    \"\"\"\n    with pytest.raises(TypeError, match=\"must be a positive integer.\"):\n        is_num_prime(1.0)\n    with pytest.raises(ValueError, match=\"must be a positive integer.\"):\n        is_num_prime(-1)\n```\n:::\n\n\nWithin this function, I can run multiple assertions against several hard-coded\ninputs. I'm only checking against a couple of values here but production-ready\ncode may test against many more cases. To do that, I'd need to have a lot of\nrepeated `pytest.raises` statements. Perhaps more importantly, watch what\nhappens when I run the test.\n\n```\n% pytest -k \"test_is_num_primes_exceptions_manually\"\n============================= test session starts =============================\nplatform darwin -- Python 3.12.3, pytest-8.1.1, pluggy-1.5.0\nconfigfile: pyproject.toml\ntestpaths: ./tests\ncollected 56 items / 55 deselected / 1 selected                                \n\ntests/test_primes.py .                                                   [100%]\n\n======================= 1 passed, 55 deselected in 0.01s ======================\n\n```\n\nNotice that both assertions will either pass or fail together as one test. This\ncould potentially make it more challenging to troubleshoot a failing pipeline.\nIt could be better to have separate test functions for each value, but that\nseems like an awful lot of work...\n\n### ...Enter Parametrize\n\nNow to start using parametrize, we need to use the `@pytest.mark.parametrize`\ndecorator, which takes 2 arguments, a string and an iterable.\n\n::: {#509e5292 .cell execution_count=4}\n``` {.python .cell-code}\n@pytest.mark.parametrize(\n    \"some_values, exception_types\", [(1.0, TypeError), (-1, ValueError)]\n    )\n```\n:::\n\n\nThe string should contain comma separated values for the names that you would\nlike to refer to when iterating through the iterable. They can be any\nplaceholder you would wish to use in your test. These names will map to the\nindex of elements in the iterable.\n\nSo when I use the fixture with a test, I will expect to inject the following\nvalues:\n\niteration 1... \"some_values\" = 1.0, \"exception_types\" = TypeError  \niteration 2... \"some_values\" = -1, \"exception_types\" = ValueError\n\nLet's go ahead and use this parametrized fixture with a test.\n\n::: {#4c8b3dd5 .cell execution_count=5}\n``` {.python .cell-code}\n@pytest.mark.parametrize(\n    \"some_values, exception_types\", [(1.0, TypeError), (-1, ValueError)]\n    )\ndef test_is_num_primes_exceptions_parametrized(some_values, exception_types):\n    \"\"\"The same defensive checks but this time with parametrized input.\n\n    Less lines in the test but if we increase the number of cases, we need to\n    add more lines to the parametrized fixture instead.\n    \"\"\"\n    with pytest.raises(exception_types, match=\"must be a positive integer.\"):\n        is_num_prime(some_values)\n```\n:::\n\n\nThe outcome for running this test is shown below.\n\n```\n% pytest -k \"test_is_num_primes_exceptions_parametrized\"\n============================= test session starts =============================\nplatform darwin -- Python 3.12.3, pytest-8.1.1, pluggy-1.5.0\nconfigfile: pyproject.toml\ntestpaths: ./tests\ncollected 56 items / 54 deselected / 2 selected                                \n\ntests/test_primes.py ..                                                  [100%]\n\n======================= 2 passed, 54 deselected in 0.01s ======================\n\n```\n\nIt's a subtle difference, but notice that we now get 2 passing tests rather\nthan 1? We can make this more explicit by passing the `-v` flag (for verbose)\nwhen we invoke `pytest`.\n\n```\n% pytest -k \"test_is_num_primes_exceptions_parametrized\" -v \n============================= test session starts =============================\nplatform darwin -- Python 3.12.3, pytest-8.1.1, pluggy-1.5.0 \ncachedir: .pytest_cache\nconfigfile: pyproject.toml\ntestpaths: ./tests\ncollected 56 items / 54 deselected / 2 selected                                \n\ntest_is_num_primes_exceptions_parametrized[1.0-TypeError] PASSED         [ 50%]\ntest_is_num_primes_exceptions_parametrized[-1-ValueError] PASSED         [100%]\n\n======================= 2 passed, 54 deselected in 0.01s ======================\n\n```\n\nIn this way, we get a helpful printout of the test and parameter combination\nbeing executed. This can be very helpful in identifying problem cases.\n\n### Yet More Cases\n\nNext up, we may wish to check return values for our function with several\nmore cases. To keep things simple, let's write a test that checks the return\nvalues for a range of numbers between 1 and 5.\n\n::: {#b4f4f5f0 .cell execution_count=6}\n``` {.python .cell-code}\ndef test_is_num_primes_manually():\n    \"\"\"Test several positive integers return expected boolean.\n\n    This is quite a few lines of code. Note that this runs as a single test.\n    \"\"\"\n    assert is_num_prime(1) == False\n    assert is_num_prime(2) == True\n    assert is_num_prime(3) == True\n    assert is_num_prime(4) == False\n    assert is_num_prime(5) == True\n```\n:::\n\n\nOne way that this can be serialised is by using a list of parameters and\nexpected results.\n\n::: {#d2d4c3ef .cell execution_count=7}\n``` {.python .cell-code}\ndef test_is_num_primes_with_list():\n    \"\"\"Test the same values using lists.\n\n    Less lines but is run as a single test.\n    \"\"\"\n    answers = [is_num_prime(i) for i in range(1, 6)]\n    assert answers == [False, True, True, False, True]\n```\n:::\n\n\nThis is certainly neater than the previous example. Although both\nimplementations will evaluate as a single test, so a failing instance will not\nbe explicitly indicated in the `pytest` report.\n\n```\n% pytest -k \"test_is_num_primes_with_list\"\n============================= test session starts =============================\nplatform darwin -- Python 3.12.3, pytest-8.1.1, pluggy-1.5.0\nconfigfile: pyproject.toml\ntestpaths: ./tests\ncollected 56 items / 55 deselected / 1 selected                               \n\ntests/test_primes.py .                                                   [100%]\n\n======================= 1 passed, 55 deselected in 0.01s ======================\n```\n\nTo parametrize the equivalent test, we can take the below approach.\n\n::: {#27ec8de4 .cell execution_count=8}\n``` {.python .cell-code}\n@pytest.mark.parametrize(\n    \"some_integers, answers\",\n    [(1, False), (2, True), (3, True), (4, False), (5, True)]\n    )\ndef test_is_num_primes_parametrized(some_integers, answers):\n    \"\"\"The same tests but this time with parametrized input.\n\n    Fewer lines and 5 separate tests are run by pytest.\n    \"\"\"\n    assert is_num_prime(some_integers) == answers\n```\n:::\n\n\nThis is slightly more lines than `test_is_num_primes_with_list` but has the\nadvantage of being run as separate tests:\n\n```\n% pytest -k \"test_is_num_primes_parametrized\" -v\n============================= test session starts =============================\nplatform darwin -- Python 3.12.3, pytest-8.1.1, pluggy-1.5.0\ncachedir: .pytest_cache\nconfigfile: pyproject.toml\ntestpaths: ./tests\ncollected 56 items / 51 deselected / 5 selected                               \n\ntests/test_primes.py::test_is_num_primes_parametrized[1-False] PASSED    [ 20%]\ntests/test_primes.py::test_is_num_primes_parametrized[2-True] PASSED     [ 40%]\ntests/test_primes.py::test_is_num_primes_parametrized[3-True] PASSED     [ 60%]\ntests/test_primes.py::test_is_num_primes_parametrized[4-False] PASSED    [ 80%]\ntests/test_primes.py::test_is_num_primes_parametrized[5-True] PASSED     [100%]\n\n======================= 5 passed, 51 deselected in 0.01s ======================\n\n```\n\nWhere this approach really comes into its own is when the number of cases you\nneed to test increases, you can explore ways of generating cases rather than\nhard-coding the values, as in the previous examples.\n\nIn the example below, we can use the `range()` function to generate the \nintegers we need to test, and then zipping these cases to their expected return\nvalues.\n\n::: {#a7927e41 .cell execution_count=9}\n``` {.python .cell-code}\n# if my list of cases is growing, I can employ other tactics...\nin_ = range(1, 21)\nout = [\n    False, True, True, False, True, False, True, False, False, False,\n    True, False, True, False, False, False, True, False, True, False,\n    ]\n\n\n@pytest.mark.parametrize(\"some_integers, some_answers\", zip(in_, out))\ndef test_is_num_primes_with_zipped_lists(some_integers, some_answers):\n    \"\"\"The same tests but this time with zipped inputs.\"\"\"\n    assert is_num_prime(some_integers) == some_answers\n```\n:::\n\n\nRunning this test yields the following result:\n\n:::{.scrolling}\n\n```\n% pytest -k \"test_is_num_primes_with_zipped_lists\" -v \n============================= test session starts =============================\nplatform darwin -- Python 3.11.6, pytest-7.4.3, pluggy-1.3.0\ncachedir: .pytest_cache\nconfigfile: pyproject.toml\ntestpaths: ./tests\nplugins: anyio-4.0.0\ncollected 56 items / 36 deselected / 20 selected\n\n/test_primes.py::test_is_num_primes_with_zipped_lists[1-False] PASSED  [  5%]\n/test_primes.py::test_is_num_primes_with_zipped_lists[2-True] PASSED   [ 10%]\n/test_primes.py::test_is_num_primes_with_zipped_lists[3-True] PASSED   [ 15%]\n/test_primes.py::test_is_num_primes_with_zipped_lists[4-False] PASSED  [ 20%]\n/test_primes.py::test_is_num_primes_with_zipped_lists[5-True] PASSED   [ 25%]\n/test_primes.py::test_is_num_primes_with_zipped_lists[6-False] PASSED  [ 30%]\n/test_primes.py::test_is_num_primes_with_zipped_lists[7-True] PASSED   [ 35%]\n/test_primes.py::test_is_num_primes_with_zipped_lists[8-False] PASSED  [ 40%]\n/test_primes.py::test_is_num_primes_with_zipped_lists[9-False] PASSED  [ 45%]\n/test_primes.py::test_is_num_primes_with_zipped_lists[10-False] PASSED [ 50%]\n/test_primes.py::test_is_num_primes_with_zipped_lists[11-True] PASSED  [ 55%]\n/test_primes.py::test_is_num_primes_with_zipped_lists[12-False] PASSED [ 60%]\n/test_primes.py::test_is_num_primes_with_zipped_lists[13-True] PASSED  [ 65%]\n/test_primes.py::test_is_num_primes_with_zipped_lists[14-False] PASSED [ 70%]\n/test_primes.py::test_is_num_primes_with_zipped_lists[15-False] PASSED [ 75%]\n/test_primes.py::test_is_num_primes_with_zipped_lists[16-False] PASSED [ 80%]\n/test_primes.py::test_is_num_primes_with_zipped_lists[17-True] PASSED  [ 85%]\n/test_primes.py::test_is_num_primes_with_zipped_lists[18-False] PASSED [ 90%]\n/test_primes.py::test_is_num_primes_with_zipped_lists[19-True] PASSED  [ 95%]\n/test_primes.py::test_is_num_primes_with_zipped_lists[20-False] PASSED [100%]\n\n====================== 20 passed, 36 deselected in 0.02s ======================\n```\n\n:::\n\n## Stacked Parametrization\n\nParametrize gets really interesting when you have a situation where you need to\ntest **combinations of input parameters** against expected outputs. In this\nscenario, stacked parametrization allows you to set up all combinations with\nvery little fuss. \n\nFor this section, I will define a new function built on top of our\n`is_num_prime()` function. This function will take 2 positive integers and add\nthem together, but only if both of the input integers are prime. Otherwise,\nwe'll simply return the input numbers. To keep things simple, we'll always\nreturn a tuple in all cases.\n\n::: {#5c9de4fd .cell execution_count=10}\n``` {.python .cell-code}\ndef sum_if_prime(pos_int1: int, pos_int2: int) -> tuple:\n    \"\"\"Sum 2 integers only if they are prime numbers.\n\n    Parameters\n    ----------\n    pos_int1 : int\n        A positive integer.\n    pos_int2 : int\n        A positive integer.\n\n    Returns\n    -------\n    tuple\n        Tuple of one integer if both inputs are prime numbers, else returns a\n        tuple of the inputs.\n    \"\"\"\n    if is_num_prime(pos_int1) and is_num_prime(pos_int2):\n        return (pos_int1 + pos_int2,)\n    else:\n        return (pos_int1, pos_int2)\n```\n:::\n\n\nThen using this function with a range of numbers:\n\n::: {#c1e1fb34 .cell execution_count=11}\n``` {.python .cell-code}\nfor i in range(1, 6):\n    print(f\"{i} and {i} result: {sum_if_prime(i, i)}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1 and 1 result: (1, 1)\n2 and 2 result: (4,)\n3 and 3 result: (6,)\n4 and 4 result: (4, 4)\n5 and 5 result: (10,)\n```\n:::\n:::\n\n\nTesting combinations of input parameters for this function will quickly become\nburdensome:\n\n::: {#386ddc80 .cell execution_count=12}\n``` {.python .cell-code}\nfrom example_pkg.primes import sum_if_prime\n\n\ndef test_sum_if_prime_with_manual_combinations():\n    \"\"\"Manually check several cases.\"\"\"\n    assert sum_if_prime(1, 1) == (1, 1)\n    assert sum_if_prime(1, 2) == (1, 2)\n    assert sum_if_prime(1, 3) == (1, 3)\n    assert sum_if_prime(1, 4) == (1, 4)\n    assert sum_if_prime(1, 5) == (1, 5)\n    assert sum_if_prime(2, 1) == (2, 1)\n    assert sum_if_prime(2, 2) == (4,) # the first case where both are primes\n    assert sum_if_prime(2, 3) == (5,) \n    assert sum_if_prime(2, 4) == (2, 4)\n    assert sum_if_prime(2, 5) == (7,)\n    # ...\n```\n:::\n\n\n```\n% pytest -k \"test_sum_if_prime_with_manual_combinations\"\n============================= test session starts =============================\nplatform darwin -- Python 3.12.3, pytest-8.1.1, pluggy-1.5.0\nconfigfile: pyproject.toml\ntestpaths: ./tests\ncollected 56 items / 55 deselected / 1 selected\n\ntests/test_primes.py .                                                   [100%]\n\n====================== 1 passed, 55 deselected in 0.01s =======================\n\n```\n\n### Single Assertions\n\nBecause we take more than one input parameter, we can use stacked\nparametrization to easily inject all combinations of parameters to a test.\nSimply put, this means that we pass more than one parametrized fixture to the\nsame test. Behind the scenes, `pytest` prepares all parameter combinations to\ninject into our test. \n\nThis allows us to very easily pass all parameter combinations to a\n**single assertion statement**, as in the diagram below.\n\n```{mermaid}\n%%| label: fig-stacked-single\n%%| fig-cap: \"Stacked parametrization against a single assertion\"\nflowchart LR\n    subgraph fix1 [\"@parametrize first_ints\"]\n        A1[1]\n        A2[2]\n        A3[3]\n    end\n    subgraph fix2 [\"@parametrize second_ints\"]\n        B1[1]\n        B2[2]\n        B3[3]\n    end\n    fix1 --> C[\"All Combinations: 3 x 3 = 9 tests\"]\n    fix2 --> C\n    C --> T[\"Single Assertion: isinstance(result, tuple)\"]\n```\n\nTo use stacked parametrization against our `sum_if_prime()` function, we can\nuse 2 separate iterables:\n\n::: {#4d28e74f .cell execution_count=13}\n``` {.python .cell-code}\n@pytest.mark.parametrize(\"first_ints\", range(1,6))\n@pytest.mark.parametrize(\"second_ints\", range(1,6))\ndef test_sum_if_prime_stacked_parametrized_inputs(\n    first_ints, second_ints, expected_answers):\n    \"\"\"Using stacked parameters to set up combinations of all cases.\"\"\"\n    assert isinstance(sum_if_prime(first_ints, second_ints), tuple)\n```\n:::\n\n\n:::{.scrolling}\n\n```\n% pytest -k \"test_sum_if_prime_stacked_parametrized_inputs\" -v\n============================= test session starts =============================\nplatform darwin -- Python 3.11.6, pytest-7.4.3, pluggy-1.3.0 \ncachedir: .pytest_cache\nconfigfile: pyproject.toml\ntestpaths: ./tests\nplugins: anyio-4.0.0\ncollected 56 items / 31 deselected / 25 selected\n\ntest_sum_if_prime_stacked_parametrized_inputs[1-1] PASSED                [  4%]\ntest_sum_if_prime_stacked_parametrized_inputs[1-2] PASSED                [  8%]\ntest_sum_if_prime_stacked_parametrized_inputs[1-3] PASSED                [ 12%]\ntest_sum_if_prime_stacked_parametrized_inputs[1-4] PASSED                [ 16%]\ntest_sum_if_prime_stacked_parametrized_inputs[1-5] PASSED                [ 20%]\ntest_sum_if_prime_stacked_parametrized_inputs[2-1] PASSED                [ 24%]\ntest_sum_if_prime_stacked_parametrized_inputs[2-2] PASSED                [ 28%]\ntest_sum_if_prime_stacked_parametrized_inputs[2-3] PASSED                [ 32%]\ntest_sum_if_prime_stacked_parametrized_inputs[2-4] PASSED                [ 36%]\ntest_sum_if_prime_stacked_parametrized_inputs[2-5] PASSED                [ 40%]\ntest_sum_if_prime_stacked_parametrized_inputs[3-1] PASSED                [ 44%]\ntest_sum_if_prime_stacked_parametrized_inputs[3-2] PASSED                [ 48%]\ntest_sum_if_prime_stacked_parametrized_inputs[3-3] PASSED                [ 52%]\ntest_sum_if_prime_stacked_parametrized_inputs[3-4] PASSED                [ 56%]\ntest_sum_if_prime_stacked_parametrized_inputs[3-5] PASSED                [ 60%]\ntest_sum_if_prime_stacked_parametrized_inputs[4-1] PASSED                [ 64%]\ntest_sum_if_prime_stacked_parametrized_inputs[4-2] PASSED                [ 68%]\ntest_sum_if_prime_stacked_parametrized_inputs[4-3] PASSED                [ 72%]\ntest_sum_if_prime_stacked_parametrized_inputs[4-4] PASSED                [ 76%]\ntest_sum_if_prime_stacked_parametrized_inputs[4-5] PASSED                [ 80%]\ntest_sum_if_prime_stacked_parametrized_inputs[5-1] PASSED                [ 84%]\ntest_sum_if_prime_stacked_parametrized_inputs[5-2] PASSED                [ 88%]\ntest_sum_if_prime_stacked_parametrized_inputs[5-3] PASSED                [ 92%]\ntest_sum_if_prime_stacked_parametrized_inputs[5-4] PASSED                [ 96%]\ntest_sum_if_prime_stacked_parametrized_inputs[5-5] PASSED                [100%]\n\n====================== 25 passed, 31 deselected in 0.01s ======================\n\n```\n:::\n<br>\nThe above test; which is 6 lines long; executed 25 tests. This is clearly a very\nbeneficial feature of `pytest`. However, the eagle-eyed among you may have\nspotted a problem - this is only going to work if the expected answer is always\nthe same. The test we defined is only checking that a `tuple` is returned in\nall cases. How can we ensure that we serve the expected answers to the test\ntoo? This is where things get a little fiddly.\n\n### Multiple Assertions\n\nTo test our function against combinations of parameters with\n**different expected answers**, we must employ a dictionary mapping of the\nparameter combinations as keys and the expected assertions as values.\n\n```{mermaid}\n%%| label: fig-dict-mapping\n%%| fig-cap: \"Using a dictionary to map multiple assertions against stacked parametrized fixtures\"\nflowchart LR\n    subgraph stack [Stacked Fixtures]\n        P1[\"first_ints: 1,2,3\"]\n        P2[\"second_ints: 1,2,3\"]\n    end\n    stack --> L[\"Lookup: expected[first][second]\"]\n    subgraph dict [Dictionary Fixture]\n        D[\"{1: {1: result, 2: result}, 2: {...}}\"]\n    end\n    dict --> L\n    L --> A[\"assert answer == expected\"]\n```\n\nTo do this, we need to define a new fixture, which will return the required\ndictionary mapping of parameters to expected values.\n\n::: {#19b62458 .cell execution_count=14}\n``` {.python .cell-code}\n# Using stacked parametrization, we can avoid manually typing the cases out,\n# though we do still need to define a dictionary of the expected answers...\n@pytest.fixture\ndef expected_answers() -> dict:\n    \"\"\"A dictionary of expected answers for all combinations of 1 through 5.\n\n    First key corresponds to `pos_int1` and second key is `pos_int2`.\n\n    Returns\n    -------\n    dict\n        Dictionary of cases and their expected tuples.\n    \"\"\"\n    expected= {\n        1: {1: (1,1), 2: (1,2), 3: (1,3), 4: (1,4), 5: (1,5),},\n        2: {1: (2,1), 2: (4,), 3: (5,), 4: (2,4), 5: (7,),},\n        3: {1: (3,1), 2: (5,), 3: (6,), 4: (3,4), 5: (8,),},\n        4: {1: (4,1), 2: (4,2), 3: (4,3), 4: (4,4), 5: (4,5),},\n        5: {1: (5,1), 2: (7,), 3: (8,), 4: (5,4), 5: (10,),},\n    }\n    return expected\n```\n:::\n\n\nPassing our `expected_answers` fixture to our test will allow us to match all\nparameter combinations to their expected answer. Let's update\n`test_sum_if_prime_stacked_parametrized_inputs` to use the parameter values to\naccess the expected assertion value from the dictionary.\n\n::: {#a051d2c7 .cell execution_count=15}\n``` {.python .cell-code}\n@pytest.mark.parametrize(\"first_ints\", range(1,6))\n@pytest.mark.parametrize(\"second_ints\", range(1,6))\ndef test_sum_if_prime_stacked_parametrized_inputs(\n    first_ints, second_ints, expected_answers):\n    \"\"\"Using stacked parameters to set up combinations of all cases.\"\"\"\n    assert isinstance(sum_if_prime(first_ints, second_ints), tuple)\n    answer = sum_if_prime(first_ints, second_ints)\n    # using the parametrized values, pull out their keys from the\n    # expected_answers dictionary\n    assert answer == expected_answers[first_ints][second_ints]\n```\n:::\n\n\nFinally, running this test produces the below `pytest` report.\n\n:::{.scrolling}\n\n```\n% pytest -k \"test_sum_if_prime_stacked_parametrized_inputs\" -v\n============================= test session starts =============================\nplatform darwin -- Python 3.12.3, pytest-8.1.1, pluggy-1.5.0 \ncachedir: .pytest_cache\nconfigfile: pyproject.toml\ntestpaths: ./tests\ncollected 56 items / 31 deselected / 25 selected\n\ntest_sum_if_prime_stacked_parametrized_inputs[1-1] PASSED                [  4%]\ntest_sum_if_prime_stacked_parametrized_inputs[1-2] PASSED                [  8%]\ntest_sum_if_prime_stacked_parametrized_inputs[1-3] PASSED                [ 12%]\ntest_sum_if_prime_stacked_parametrized_inputs[1-4] PASSED                [ 16%]\ntest_sum_if_prime_stacked_parametrized_inputs[1-5] PASSED                [ 20%]\ntest_sum_if_prime_stacked_parametrized_inputs[2-1] PASSED                [ 24%]\ntest_sum_if_prime_stacked_parametrized_inputs[2-2] PASSED                [ 28%]\ntest_sum_if_prime_stacked_parametrized_inputs[2-3] PASSED                [ 32%]\ntest_sum_if_prime_stacked_parametrized_inputs[2-4] PASSED                [ 36%]\ntest_sum_if_prime_stacked_parametrized_inputs[2-5] PASSED                [ 40%]\ntest_sum_if_prime_stacked_parametrized_inputs[3-1] PASSED                [ 44%]\ntest_sum_if_prime_stacked_parametrized_inputs[3-2] PASSED                [ 48%]\ntest_sum_if_prime_stacked_parametrized_inputs[3-3] PASSED                [ 52%]\ntest_sum_if_prime_stacked_parametrized_inputs[3-4] PASSED                [ 56%]\ntest_sum_if_prime_stacked_parametrized_inputs[3-5] PASSED                [ 60%]\ntest_sum_if_prime_stacked_parametrized_inputs[4-1] PASSED                [ 64%]\ntest_sum_if_prime_stacked_parametrized_inputs[4-2] PASSED                [ 68%]\ntest_sum_if_prime_stacked_parametrized_inputs[4-3] PASSED                [ 72%]\ntest_sum_if_prime_stacked_parametrized_inputs[4-4] PASSED                [ 76%]\ntest_sum_if_prime_stacked_parametrized_inputs[4-5] PASSED                [ 80%]\ntest_sum_if_prime_stacked_parametrized_inputs[5-1] PASSED                [ 84%]\ntest_sum_if_prime_stacked_parametrized_inputs[5-2] PASSED                [ 88%]\ntest_sum_if_prime_stacked_parametrized_inputs[5-3] PASSED                [ 92%]\ntest_sum_if_prime_stacked_parametrized_inputs[5-4] PASSED                [ 96%]\ntest_sum_if_prime_stacked_parametrized_inputs[5-5] PASSED                [100%]\n\n====================== 25 passed, 31 deselected in 0.01s ======================\n```\n\n:::\n\n## Summary\n\nThere you have it - how to use basic and stacked parametrization in your tests.\nWe have:\n\n* used parametrize to inject multiple parameter values to a single test.\n* used stacked parametrize to test combinations of parameters against a single\nassertion.\n* used a nested dictionary fixture to map stacked parametrize input\ncombinations to different expected assertion values.\n\nIf you spot an error with this article, or have a suggested improvement then\nfeel free to\n[raise an issue on GitHub](https://github.com/r-leyshon/blogging/issues).  \n\nHappy testing!\n\n## Acknowledgements\n\nTo past and present colleagues who have helped to discuss pros and cons,\nestablishing practice and firming-up some opinions. Particularly:\n\n* Charlie\n* Ethan\n* Henry\n* Sergio\n\n<p id=fin><i>fin!</i></p>\n\n",
    "supporting": [
      "13-pytest-parametrize_files"
    ],
    "filters": [],
    "includes": {}
  }
}