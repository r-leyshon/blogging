{
  "hash": "d9d8b8c9c0126653ca2346b33f56370b",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Lazy Mocking\"\nauthor: \"Rich Leyshon\"\ndate: \"November 05 2024\"\ndescription: \"Mocking with Fixtures: Deferred Evaluation\"\ncategories:\n    - How-to\n    - pytest\n    - Unit tests\n    - mocking\n    - pytest-in-plain-english\n    - patching\n    - lazy\n    - lazy evaluation\nimage: /./www/20-lazy-mocking/intro-img.jpg\nimage-alt: \"The marionette Taking a Nap in a cyberpunk setting.\"\ntoc: true\ncss: /./www/17-quarto-comments/styles.css\ncode-annotations: select\n---\n\n<img class=shaded_box src=/./www/20-lazy-mocking/intro-img.jpg alt=\"The marionette Taking a Nap in a cyberpunk setting.\" style=\"display:block;margin-left:auto;margin-right:auto;width:40%;border:none;\">\n\n> \"Time to live  \n> Time to lie  \n> Time to laugh  \n> Time to die  \n> Take it easy, baby  \n> Take it as it comes\" Take It As It Comes, The Doors.\n\n## Introduction\n\nA simple approach to sharing a fixture across multiple tests where mocking is a\nrequirement. After comparing implementations with `pytest`'s `monkeypatch` and\n`mockito`, `unittest.patch` was selected because it is straightforward and\nsuccinct. The code in this article is\n<a href=https://gist.github.com/r-leyshon/817e19438380eb9df638dfb1cd4c242e target=_blank>available in this gist</a>\nfor those pushed for time.\n\n### Intended Audience\n\nExperienced python Developers, test engineers & any intersection of the two.\nThis tutorial is not for those new to mocking. Please refer to\n[Mocking With Pytest in Plain English](/./blogs/15-pytest-mocking.qmd) for a\nmore comprehensive introduction to that. This blog is part of a series called\n[pytest in plain English](/blogs/index.qmd#category=pytest-in-plain-english).\n\n### Requirements\n\n`pip install pytest`\n\n## Some Source Code\n\nThis little function would cause a problem when writing your test suite:\n\n::: {#c3c02f5b .cell execution_count=1}\n``` {.python .cell-code}\nfrom datetime import datetime\n\ndef get_poem_line_for_day():\n    \"\"\"Returns the line of the poem based on the current day of the week.\"\"\"\n    day_of_week = datetime.today().strftime('%A')\n    POEM = {\n        \"Monday\": \"Monday's child is fair of face\",\n        \"Tuesday\": \"Tuesday's child is full of grace\",\n        \"Wednesday\": \"Wednesday's child is full of woe\",\n        \"Thursday\": \"Thursday's child has far to go\",\n        \"Friday\": \"Friday's child is loving and giving\",\n        \"Saturday\": \"Saturday's child works hard for his living\",\n        \"Sunday\": \"And the child that is born on the Sabbath day is bonny and blithe, and good and gay\",\n    }\n    return POEM.get(day_of_week, \"Unknown day\")\n\nget_poem_line_for_day()\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n\"Monday's child is fair of face\"\n```\n:::\n:::\n\n\n::: {.callout collapse=\"true\"}\n\n### Why would this be hard to test without mocking? (Click to reveal)\n\n* The function will return different strings depending on the day the test is\nrun.\n* Without mocking `get_poem_line_for_day`, you would have to update hard-coded\ntest predicates to match the current day of the week. Nope.\n* In CI, avoiding mocking would likely result in setting a variable equal to\nthe current day of the week and basing your test predicates off of that. Nope.\n* Let's instead patch the values...\n\n:::\n\n## Let's Test...\n\n### Local-Scoped Mock\n\nThis is very easy to mock using local-scoped utility functions.\n\n::: {#9a4a5ee5 .cell execution_count=2}\n``` {.python .cell-code}\nfrom unittest import mock\n\nimport pytest\n\nimport poem\n\nPOEM = {\n        \"Monday\": \"Monday's child is fair of face\",\n        \"Tuesday\": \"Tuesday's child is full of grace\",\n        \"Wednesday\": \"Wednesday's child is full of woe\",\n        \"Thursday\": \"Thursday's child has far to go\",\n        \"Friday\": \"Friday's child is loving and giving\",\n        \"Saturday\": \"Saturday's child works hard for his living\",\n        \"Sunday\": \"And the child that is born on the Sabbath day is bonny and blithe, and good and gay\",\n    }\n\n\n@mock.patch(\"poem.get_poem_line_for_day\")                                       # <1>\ndef test_poem_line_forever_thursday(patched_poem):                              # <2>\n    \"\"\"Uses immediate instantiation\"\"\"\n\n    def mock_poem(day, poem=POEM):                                              # <3>\n        return poem[day]\n\n    patched_poem.return_value = mock_poem(day=\"Thursday\")                       # <4>\n    result = poem.get_poem_line_for_day()                                       # <5>\n    assert result == \"Thursday's child has far to go\"                           # <6>\n```\n:::\n\n\n1. Specify the target that we wish to patch.\n2. Define a name for the patch as `patched_poem`. We'll need to refer to this\nwhen implementing the patch in the test.\n3. Define a locally-scoped function that will serve the line of the poem\ndepending on the day that **you ask for**.\n4. Set the return value of the patch we specified to be equal to the line for a\nhard-coded day of the week. Note that we could go ahead and make multiple\nassertions re-using the `mock_poem` utility.\n5. Use the System Under Test (SUT). Note that in a real test suite, we would\nlikely target the component of the SUT that we need to control, rather than the\nentire source code. Eg - target `datetime.today` rather than\n`get_poem_line_for_day`.\n6. Whatever day the test is executed on, the resulting value will be patched in\nthe way we specified.\n\n### Broken Mock with Fixture\n\nIt is common to start with a [locally-scoped mock](#local-scoped-mock) and then\n, as the test suite grows, it would be better to share the mock across multiple\ntests. You may naively try to use the same `mock_poem` as a `pytest` fixture.\n\n::: {#9dfaa6a5 .cell execution_count=3}\n``` {.python .cell-code}\nfrom unittest import mock\n\nimport pytest\n\nimport poem\n\n\n@pytest.fixture(scope=\"function\")                                               # <1>\ndef BROKEN_mock_poem(day, poem=POEM):                                                  # <2>\n    return poem[day]\n\n\n@mock.patch(\"poem.get_poem_line_for_day\")                                       # <3>\ndef test_IS_BROKEN_(patched_poem, BROKEN_mock_poem):\n    \"\"\"Uses deferred instantiation.\"\"\"\n    patched_poem.return_value = BROKEN_mock_poem(day_name=\"Wednesday\")\n    result = poem.get_poem_line_for_day()                                       \n    assert result == \"Wednesday's child is full of woe\"\n\n    patched_poem.return_value = BROKEN_mock_poem(day_name=\"Friday\")\n    result = poem.get_poem_line_for_day()\n    assert result == \"Friday's child is loving and giving\"\n```\n:::\n\n\n1. We attempt to shift the utility to a fixture in order to use it across\nmultiple tests.\n2. `pytest` fixtures will eagerly evaluate the arguments to the fixture and\nraise an exception, as a value for `day` has not been set. \n3. The test is not run due to the above exception.\n\nThe problem with the above code is that `pytest` fixtures expect other\nfixtures, not placeholder arguments. As part of their dependency injection\nprocess, `pytest` fixtures will evaluate all arguments passed to the fixture\nbefore tests are run.\n\n### Mock with Fixture - Fixed\n\nWe need to implement some minor tweaks to the broken fixture in order to delay\nevaluation of the parameters. In this way, we make the fixture \"lazy\" by using\na factory function to instantiate the poem line within the test, rather than\nbefore it.\n\n::: {#2b319b56 .cell execution_count=4}\n``` {.python .cell-code}\nfrom unittest import mock\n\nimport pytest\n\nimport poem\n\n\n@pytest.fixture(scope=\"function\")\ndef mock_poem_line_factory():                                                   # <1>\n    \"\"\"Factory function that mocks expected return values.\"\"\"\n    def _get_poem_line(day_name: str, poem: dict = POEM) -> str:                # <2>\n        return poem[day_name]                                                   # <2>\n    \n    return _get_poem_line                                                       # <3>\n\n@mock.patch(\"poem.get_poem_line_for_day\")\ndef test_poem_line_any_day_we_like(patched_poem, mock_poem_line_factory):       # <4>\n    \"\"\"Uses deferred instantiation.\"\"\"\n    patched_poem.return_value = mock_poem_line_factory(day_name=\"Wednesday\")\n    result = poem.get_poem_line_for_day()                                       # <5>\n    assert result == \"Wednesday's child is full of woe\"\n\n    patched_poem.return_value = mock_poem_line_factory(day_name=\"Friday\")\n    result = poem.get_poem_line_for_day()\n    assert result == \"Friday's child is loving and giving\"\n```\n:::\n\n\n1. The fixture will now act as a factory function, encapsulating the\ninstantiation of the values we wish to return. This gives us more control over\nwhen the `day_name` parameter is evaluated. Note that the fixture signature\ntakes no arguments, though you could pass it other `pytest` fixtures if you\nneeded to.\n2. The internal `_get_poem_line` signature defines the arguments needed to\ncontrol which poem lines you wish to return.\n3. Note the factory function should return the internal itself, rather than its\nvalue - we need to delay evaluation.\n4. Don't forget to pass in the fixture to the test signature. It must come\nafter the alias we used for `mock.patch`, due to the decorator.\n5. The mock fixture gets evaluated when we attempt to patch the SUT. \n\n## Summary\n\nWe've demonstrated how to go from a locally scoped mock to a fixture mock:\n\n1. Demonstrating how to achieve a straightforward mock:patch combo with a local\nutility.\n2. Demonstrating that the same approach does not work for a `pytest` fixture.\n3. Updating the fixture to use lazy evaluation.\n\nPlease feel free to share your own thoughts and ideas in the comment\nsection below (GitHub login required)! If you spot an error with this\narticle, or have a suggested improvement then feel free to \n[raise an issue on GitHub](https://github.com/r-leyshon/blogging/issues). \n\n<p id=fin><i>fin!</i></p>\n\n",
    "supporting": [
      "20-lazy-mocking_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}