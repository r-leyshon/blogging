---
title: "Mocking With Pytest in Plain English"
author: "Rich Leyshon"
date: "July 10 2024"
description: "Plain English Comparison of Mocking Approaches in Python"
categories:
    - Explanation
    - pytest
    - Unit tests
    - mocking
    - pytest-in-plain-english
    - mockito
    - MagicMock
    - monkeypatch
image: "https://i.imgur.com/K0mxjuF.jpeg"
image-alt: "Soul singer with Joker makeup."
toc: true
jupyter: 
  kernelspec:
    name: "conda-env-mocking-env-py"
    language: "python"
    display_name: "blog-mocking-env"
css: /www/13-pytest-parametrize/styles.css
---

<figure class=center >
  <img class="shaded_box" width=400px src="https://i.imgur.com/K0mxjuF.jpeg"></img>
  <figcaption>Soul singer with Joker makeup.</figcaption>
</figure>

> "A day without laughter is a day wasted." Charlie Chaplin

## Introduction

`pytest` is a testing package for the python framework. It is broadly used to
quality assure code logic. This article discusses the dark art of mocking, why
you should do it and the nuts and bolts of implementing mocked tests. This blog
is the fourth in a series of blogs called
[pytest in plain English](/../index.html#category=pytest-in-plain-english),
favouring accessible language and simple examples to explain the more intricate
features of the `pytest` package.

For a wealth of documentation, guides and how-tos, please consult the
<a href="https://docs.pytest.org/en/8.0.x/" target="_blank">`pytest` documentation</a>.

### What does Mocking Mean?

Code often has external dependencies:

*  Web APIs (as in this article)
* Websites (if scraping / crawling)
* External code (importing libraries)
* Data feeds and databases
* Environment variables

As developers cannot control the behaviour of those dependencies, they would
not write tests dependent upon them. In order to test their source code that
depends on these services, developers need to replace the properties of these
services when the test suite runs. Injecting replacement values into the code
at runtime is generally referred to as mocking. Mocking these values means that
developers can feed dependable results to their code and make reliable
assertions about the code's behaviour, without changes in the 'outside world'
affecting outcomes in the system under test.

:::{.callout collapse="true"}

### A Note on the Purpose (Click to expand)

This article intends to discuss clearly. It doesn't aim to be clever or
impressive. Its aim is to extend understanding without overwhelming the reader.
The code may not always be optimal, favouring a simplistic approach wherever
possible.

:::

### Intended Audience

Programmers with a working knowledge of python, HTTP requests and some
familiarity with `pytest` and packaging. The type of programmer who has
wondered about how to follow best practice in testing python code.

### What You'll Need:

- [ ] Preferred python environment manager (eg `conda`)
- [ ] `pip install pytest==8.1.1 requests mockito`
- [ ] Git
- [ ] GitHub account
- [ ] Command line access

### Preparation

This blog is accompanied by code in
[this repository](https://github.com/r-leyshon/pytest-fiddly-examples). The
main branch provides a template with the minimum structure and requirements
expected to run a `pytest` suite. The repo branches contain the code used in
the examples of the following sections.

Feel free to fork or clone the repo and checkout to the example branches as
needed.

The example code that accompanies this article is available in the
[mocking branch](https://github.com/r-leyshon/pytest-fiddly-examples/tree/mocking)
of the repo.

## Overview

Mocking is one of the trickier elements of testing. It's a bit niche and is
often perceived to be too hacky to be worth the effort. The options for mocking
in python are numerous and this adds to the complexity of many example
implementations you will find online. 

There is also a compromise in simplicity versus flexibility. Some of the
options available are quite involved and can be adapted to the nichest of
cases, but may not be the best option for those new to mocking. With this in
mind, I present 3 alternative methods for mocking python source code:

1. **monkeypatch**: The `pytest` fixture designed for mocking. The origin of
the fixture's name is debated but potentially arose from the term
'guerrilla patch' which may have been misinterpreted as 'gorilla patch'. This
is the concept of modifying source code at runtime, otherwise known as
'monkeying around'.
2. **MagicMock**: This is the mocking object provided by python3's builtin
`unittest` library.
3. **mockito**: This library is based upon the popular Jave framework of the
same name. Despite having a user-friendly syntax, `mockito` is robust and
secure.

:::{.callout-note collapse="true"}

### A note on the language

Mocking has a bunch of synonyms & related language which can be a bit
off-putting. All of the below terms are associated with mocking. Some may be
preferred to the communities of specific pragramming frameworks over others.

| Term          | Brief Meaning | Frameworks/Libraries |
|---------------|---------------|----------------------|
| Mocking       | Creating objects that simulate the behavior of real objects for testing | Mockito (Java), unittest.mock (Python), Jest (JavaScript), Moq (.NET)            |
| Spying        | Observing and recording method calls on real objects                    | Mockito (Java), Sinon (JavaScript), unittest.mock (Python), RSpec (Ruby) |
| Stubbing      | Replacing methods with predefined behaviors or return values            | Sinon (JavaScript), RSpec (Ruby), PHPUnit (PHP), unittest.mock (Python)      |
| Patching      | Temporarily modifying or replacing parts of code for testing            | unittest.mock (Python), pytest-mock (Python), PowerMock (Java)             |
| Faking        | Creating simplified implementations of complex dependencies             | Faker (multiple languages), Factory Boy (Python), FactoryGirl (Ruby)           |
| Dummy Objects | Placeholder objects passed around but never actually used               | Can be created in any testing framework                                          |

:::

## Mocking in Python

This section will walk through some code that uses HTTP requests and how we
can go about testing the code's behaviour without relying on the service being
available. Feel free to clone the repository and check out to the
[example code](https://github.com/r-leyshon/pytest-fiddly-examples/tree/mocking)
branch to run the examples.

The purpose of the code is to retrieve jokes from <https://icanhazdadjoke.com/>
like so:

```{python}
#| echo: false

import requests


def _query_endpoint(endp:str, usr_agent:str, f:str,) -> requests.models.Response:
    """Utility for formatting query string & requesting endpoint."""
    HEADERS = {
        "User-Agent": usr_agent,
        "Accept": f,
        }
    resp = requests.get(endp, headers=HEADERS)
    return resp


def _handle_response(r: requests.models.Response) -> str:
    """Utility for handling reponse object & returning text content."""
    if r.ok:
        c_type = r.headers["Content-Type"]
        if c_type == "application/json":
            content = r.json()
            content = content["joke"]
        elif c_type == "text/plain":
            content = r.text
        else:
            raise NotImplementedError(
                "This client accepts 'application/json' or 'text/plain' format"
                )
    else:
        raise requests.HTTPError(
            f"{r.status_code}: {r.reason}"
        )
    return content


def get_joke(
    endp:str = "https://icanhazdadjoke.com/",
    usr_agent:str = "datasavvycorner.com (https://github.com/r-leyshon/pytest-fiddly-examples)", 
    f:str = "text/plain",
) -> str:
    """Request a joke from icanhazdadjoke.com."""
    r = _query_endpoint(endp=endp, usr_agent=usr_agent, f=f)
    return _handle_response(r)
```

```{python}
for _ in range(0,3):
    print(get_joke(f="application/json"))

```


### Define the Source Code

...

### Let's Get Testing

...

### ...Enter Parametrize
...

### Yet More Cases
...



## Summary

There you have it - how to use basic and stacked parametrization in your tests.
We have:

* used parametrize to inject multiple parameter values to a single test.
* used stacked parametrize to test combinations of parameters against a single
assertion.
* used a nested dictionary fixture to map stacked parametrize input
combinations to different expected assertion values.

If you spot an error with this article, or have a suggested improvement then
feel free to
[raise an issue on GitHub](https://github.com/r-leyshon/blogging/issues).  

Happy testing!

## Acknowledgements

To past and present colleagues who have helped to discuss pros and cons,
establishing practice and firming-up some opinions. Thanks specifically to
Edward for bringing `mockito` to my attention.

The diagrams used in this article were produced with the excellent
[Excalidraw](https://excalidraw.com/).

<p id=fin><i>fin!</i></p>
