{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Parametrized Tests With Pytest in Plain English\"\n",
        "author: \"Rich Leyshon\"\n",
        "date: \"June 07 2024\"\n",
        "description: \"Plain English Discussion of Pytest Parametrize\"\n",
        "categories:\n",
        "    - Explanation\n",
        "    - pytest\n",
        "    - Unit tests\n",
        "    - parametrize\n",
        "    - pytest-in-plain-english\n",
        "image: /./www/13-pytest-parametrize/intro-img.jpg\n",
        "image-alt: \"Futuristic Russian dolls on a conveyor belt.\"\n",
        "toc: true\n",
        "jupyter: \n",
        "  kernelspec:\n",
        "    name: \"pytest-env\"\n",
        "    language: \"python\"\n",
        "    display_name: \"pytest-env\"\n",
        "css: /www/13-pytest-parametrize/styles.css\n",
        "format:\n",
        "  html:\n",
        "    mermaid:\n",
        "      theme: forest\n",
        "---\n",
        "\n",
        "<img class=shaded_box src=/./www/13-pytest-parametrize/intro-img.jpg alt=\"Futuristic Russian dolls on a conveyor belt.\" style=\"display:block;margin-left:auto;margin-right:auto;width:40%;border:none;\">\n",
        "\n",
        "## Introduction\n",
        "\n",
        "`pytest` is a testing package for the python framework. It is broadly used to\n",
        "quality assure code logic. This article discusses what parametrized tests mean\n",
        "and how to implement them with `pytest`. This blog is the third in a series of\n",
        "blogs called\n",
        "[pytest in plain English](/blogs/index.qmd#category=pytest-in-plain-english),\n",
        "favouring accessible language and simple examples to explain the more intricate\n",
        "features of the `pytest` package.\n",
        "\n",
        "For a wealth of documentation, guides and how-tos, please consult the\n",
        "<a href=\"https://docs.pytest.org/en/8.0.x/\" target=\"_blank\">`pytest` documentation</a>.\n",
        "\n",
        ":::{.callout collapse=\"true\"}\n",
        "\n",
        "### A Note on the Purpose (Click to expand)\n",
        "\n",
        "This article intends to discuss clearly. It doesn't aim to be clever or\n",
        "impressive. Its aim is to extend understanding without overwhelming the reader.\n",
        "\n",
        ":::\n",
        "\n",
        "### Intended Audience\n",
        "\n",
        "Programmers with a working knowledge of python and some familiarity with\n",
        "`pytest` and packaging. The type of programmer who has wondered about how to\n",
        "follow best practice in testing python code.\n",
        "\n",
        "### What You'll Need:\n",
        "\n",
        "- [ ] Preferred python environment manager (eg `conda`)\n",
        "- [ ] `pip install pytest==8.1.1`\n",
        "- [ ] Git\n",
        "- [ ] GitHub account\n",
        "- [ ] Command line access\n",
        "\n",
        "### Preparation\n",
        "\n",
        "This blog is accompanied by code in\n",
        "[this repository](https://github.com/r-leyshon/pytest-fiddly-examples). The\n",
        "main branch provides a template with the minimum structure and requirements\n",
        "expected to run a `pytest` suite. The repo branches contain the code used in\n",
        "the examples of the following sections.\n",
        "\n",
        "Feel free to fork or clone the repo and checkout to the example branches as\n",
        "needed.\n",
        "\n",
        "The example code that accompanies this article is available in the\n",
        "[parametrize branch](https://github.com/r-leyshon/pytest-fiddly-examples/tree/parametrize)\n",
        "of the repo.\n",
        "\n",
        "## Overview\n",
        "\n",
        "### What Are Parametrized Tests?\n",
        "\n",
        "Parametrized tests are simply tests that are applied recursively to multiple\n",
        "input values. For example, rather than testing a function on one input value,\n",
        "a list of different values could be passed as a parametrized fixture.\n",
        "\n",
        "A standard approach to testing could look like Figure 1 below, where separate\n",
        "tests are defined for the different values we need to check. This would likely\n",
        "result in a fair amount of repeated boilerplate code.\n",
        "\n",
        "```{mermaid}\n",
        "%%| label: fig-no-parametrize\n",
        "%%| fig-cap: \"Testing multiple values without parametrization\"\n",
        "flowchart LR\n",
        "    subgraph tests [Separate Test Functions]\n",
        "        T1[test_value_1]\n",
        "        T2[test_value_2]\n",
        "        T3[test_value_3]\n",
        "        T4[test_value_n...]\n",
        "    end\n",
        "    T1 --> F[function]\n",
        "    T2 --> F\n",
        "    T3 --> F\n",
        "    T4 --> F\n",
        "```\n",
        "\n",
        "Instead, we can reduce the number of tests down to 1 and pass a list of tuples\n",
        "to the test instead. Each tuple should contain a parameter value and the\n",
        "expected result, as illustrated in Figure 2.\n",
        "\n",
        "```{mermaid}\n",
        "%%| label: fig-parametrize\n",
        "%%| fig-cap: \"Parametrized testing of multiple values\"\n",
        "flowchart LR\n",
        "    subgraph params [Parametrized Fixture]\n",
        "        P[\"[(val1, exp1), (val2, exp2), (val3, exp3)]\"]\n",
        "    end\n",
        "    params --> T[Single Test Function]\n",
        "    T --> F[function]\n",
        "```\n",
        "\n",
        "So let's imagine we have a simple function called `double()`, the setup for the\n",
        "parametrized list is illustrated in Figure 3.\n",
        "\n",
        "```{mermaid}\n",
        "%%| label: fig-test-double\n",
        "%%| fig-cap: \"Exemplified parametrization for test_double()\"\n",
        "flowchart LR\n",
        "    subgraph fixture [\"@pytest.mark.parametrize\"]\n",
        "        direction TB\n",
        "        R1[\"(2, 4)\"]\n",
        "        R2[\"(3, 6)\"]\n",
        "        R3[\"(5, 10)\"]\n",
        "    end\n",
        "    fixture --> T[\"test_double(input, expected)\"]\n",
        "    T --> D[\"double(input)\"]\n",
        "    D --> A[\"assert result == expected\"]\n",
        "```\n",
        "\n",
        "### Why use Parametrization?\n",
        "\n",
        "This approach allows us to thoroughly check the behaviour of our functions\n",
        "against multiple values, ensuring that edge-cases are safely treated or\n",
        "exceptions are raised as expected. \n",
        "\n",
        "In this way, we serve multiple parameters and expected outcomes to a single\n",
        "test, reducing boilerplate code. Parametrization is not a silver bullet, and we\n",
        "still need to define all of our parameters and results in a parametrized\n",
        "fixture. This approach is not quite as flexible as the property-based testing\n",
        "achievable with a package such as\n",
        "[`hypothesis`](https://hypothesis.readthedocs.io/en/latest/). However, the\n",
        "learning curve for `hypothesis` is a bit greater and may be disproportionate to\n",
        "the job at hand.\n",
        "\n",
        "For the reasons outlined above, there are likely many competent python\n",
        "developers that never use parametrized fixtures. But parametrization does allow\n",
        "us to avoid implementing tests with a `for` loop or vectorized approaches to\n",
        "the same outcomes. When coupled with programmatic approaches to generating our\n",
        "input parameters, many lines of code can be saved. And things get even more\n",
        "interesting when we pass multiple parametrized fixtures to our tests, which\n",
        "I'll come to in a bit. For these reasons, I believe that awareness of\n",
        "parametrization should be promoted among python developers as a useful solution\n",
        "in the software development toolkit.\n",
        "\n",
        "## Implementing Parametrization\n",
        "\n",
        "In this section, we will compare some very simple examples of tests with and\n",
        "without parametrization. Feel free to clone the repository and check out to the\n",
        "[example code](https://github.com/r-leyshon/pytest-fiddly-examples/tree/parametrize)\n",
        "branch to run the examples.\n",
        "\n",
        "### Define the Source Code\n",
        "\n",
        "Here we define a very basic function that checks whether an integer is prime.\n",
        "If a prime is encountered, then True is returned. If not, then False. The value\n",
        "1 gets its own treatment (return `False`). Lastly, we include some basic\n",
        "defensive checks, we return a `TypeError` if anything other than integer is\n",
        "passed to the function and a `ValueError` if the integer is less than or equal\n",
        "to 0."
      ],
      "id": "2606d6d6"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def is_num_prime(pos_int: int) -> bool:\n",
        "    \"\"\"Check if a positive integer is a prime number.\n",
        "\n",
        "    Parameters\n",
        "    ----------\n",
        "    pos_int : int\n",
        "        A positive integer.\n",
        "\n",
        "    Returns\n",
        "    -------\n",
        "    bool\n",
        "        True if the number is a prime number.\n",
        "\n",
        "    Raises\n",
        "    ------\n",
        "    TypeError\n",
        "        Value passed to `pos_int` is not an integer.\n",
        "    ValueError\n",
        "        Value passed to `pos_int` is less than or equal to 0.\n",
        "    \"\"\"\n",
        "    if not isinstance(pos_int, int):\n",
        "        raise TypeError(\"`pos_int` must be a positive integer.\")\n",
        "    if pos_int <= 0:\n",
        "        raise ValueError(\"`pos_int` must be a positive integer.\")\n",
        "    elif pos_int == 1:\n",
        "        return False\n",
        "    else:\n",
        "        for i in range(2, (pos_int // 2) + 1):\n",
        "            # If divisible by any number 2<>(n/2)+1, it is not prime\n",
        "            if (pos_int % i) == 0:\n",
        "                return False\n",
        "        else:\n",
        "            return True"
      ],
      "id": "f348804a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Running this function with a range of values demonstrates its behaviour."
      ],
      "id": "339e0893"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "for i in range(1, 11):\n",
        "  print(f\"{i}: {is_num_prime(i)}\")"
      ],
      "id": "4f1ecc6c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Let's Get Testing\n",
        "\n",
        "Let's begin with the defensive tests. Let's say I need to check that the\n",
        "function can be relied upon to raise on a number of conditions. The typical\n",
        "approach may be to test the raise conditions within a dedicated test function."
      ],
      "id": "f149ab89"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: false\n",
        "\n",
        "\"\"\"Tests for primes module.\"\"\"\n",
        "import pytest\n",
        "\n",
        "from example_pkg.primes import is_num_prime\n",
        "\n",
        "\n",
        "def test_is_num_primes_exceptions_manually():\n",
        "    \"\"\"Testing the function's defensive checks.\n",
        "\n",
        "    Here we have to repeat a fair bit of pytest boilerplate.\n",
        "    \"\"\"\n",
        "    with pytest.raises(TypeError, match=\"must be a positive integer.\"):\n",
        "        is_num_prime(1.0)\n",
        "    with pytest.raises(ValueError, match=\"must be a positive integer.\"):\n",
        "        is_num_prime(-1)"
      ],
      "id": "efdb934c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Within this function, I can run multiple assertions against several hard-coded\n",
        "inputs. I'm only checking against a couple of values here but production-ready\n",
        "code may test against many more cases. To do that, I'd need to have a lot of\n",
        "repeated `pytest.raises` statements. Perhaps more importantly, watch what\n",
        "happens when I run the test.\n",
        "\n",
        "```\n",
        "% pytest -k \"test_is_num_primes_exceptions_manually\"\n",
        "============================= test session starts =============================\n",
        "platform darwin -- Python 3.12.3, pytest-8.1.1, pluggy-1.5.0\n",
        "configfile: pyproject.toml\n",
        "testpaths: ./tests\n",
        "collected 56 items / 55 deselected / 1 selected                                \n",
        "\n",
        "tests/test_primes.py .                                                   [100%]\n",
        "\n",
        "======================= 1 passed, 55 deselected in 0.01s ======================\n",
        "\n",
        "```\n",
        "\n",
        "Notice that both assertions will either pass or fail together as one test. This\n",
        "could potentially make it more challenging to troubleshoot a failing pipeline.\n",
        "It could be better to have separate test functions for each value, but that\n",
        "seems like an awful lot of work...\n",
        "\n",
        "### ...Enter Parametrize\n",
        "\n",
        "Now to start using parametrize, we need to use the `@pytest.mark.parametrize`\n",
        "decorator, which takes 2 arguments, a string and an iterable."
      ],
      "id": "2a8d2007"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: false\n",
        "\n",
        "@pytest.mark.parametrize(\n",
        "    \"some_values, exception_types\", [(1.0, TypeError), (-1, ValueError)]\n",
        "    )"
      ],
      "id": "63234038",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The string should contain comma separated values for the names that you would\n",
        "like to refer to when iterating through the iterable. They can be any\n",
        "placeholder you would wish to use in your test. These names will map to the\n",
        "index of elements in the iterable.\n",
        "\n",
        "So when I use the fixture with a test, I will expect to inject the following\n",
        "values:\n",
        "\n",
        "iteration 1... \"some_values\" = 1.0, \"exception_types\" = TypeError  \n",
        "iteration 2... \"some_values\" = -1, \"exception_types\" = ValueError\n",
        "\n",
        "Let's go ahead and use this parametrized fixture with a test."
      ],
      "id": "ecc403ed"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: false\n",
        "\n",
        "@pytest.mark.parametrize(\n",
        "    \"some_values, exception_types\", [(1.0, TypeError), (-1, ValueError)]\n",
        "    )\n",
        "def test_is_num_primes_exceptions_parametrized(some_values, exception_types):\n",
        "    \"\"\"The same defensive checks but this time with parametrized input.\n",
        "\n",
        "    Less lines in the test but if we increase the number of cases, we need to\n",
        "    add more lines to the parametrized fixture instead.\n",
        "    \"\"\"\n",
        "    with pytest.raises(exception_types, match=\"must be a positive integer.\"):\n",
        "        is_num_prime(some_values)"
      ],
      "id": "ee901e6d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The outcome for running this test is shown below.\n",
        "\n",
        "```\n",
        "% pytest -k \"test_is_num_primes_exceptions_parametrized\"\n",
        "============================= test session starts =============================\n",
        "platform darwin -- Python 3.12.3, pytest-8.1.1, pluggy-1.5.0\n",
        "configfile: pyproject.toml\n",
        "testpaths: ./tests\n",
        "collected 56 items / 54 deselected / 2 selected                                \n",
        "\n",
        "tests/test_primes.py ..                                                  [100%]\n",
        "\n",
        "======================= 2 passed, 54 deselected in 0.01s ======================\n",
        "\n",
        "```\n",
        "\n",
        "It's a subtle difference, but notice that we now get 2 passing tests rather\n",
        "than 1? We can make this more explicit by passing the `-v` flag (for verbose)\n",
        "when we invoke `pytest`.\n",
        "\n",
        "```\n",
        "% pytest -k \"test_is_num_primes_exceptions_parametrized\" -v \n",
        "============================= test session starts =============================\n",
        "platform darwin -- Python 3.12.3, pytest-8.1.1, pluggy-1.5.0 \n",
        "cachedir: .pytest_cache\n",
        "configfile: pyproject.toml\n",
        "testpaths: ./tests\n",
        "collected 56 items / 54 deselected / 2 selected                                \n",
        "\n",
        "test_is_num_primes_exceptions_parametrized[1.0-TypeError] PASSED         [ 50%]\n",
        "test_is_num_primes_exceptions_parametrized[-1-ValueError] PASSED         [100%]\n",
        "\n",
        "======================= 2 passed, 54 deselected in 0.01s ======================\n",
        "\n",
        "```\n",
        "\n",
        "In this way, we get a helpful printout of the test and parameter combination\n",
        "being executed. This can be very helpful in identifying problem cases.\n",
        "\n",
        "### Yet More Cases\n",
        "\n",
        "Next up, we may wish to check return values for our function with several\n",
        "more cases. To keep things simple, let's write a test that checks the return\n",
        "values for a range of numbers between 1 and 5."
      ],
      "id": "a871125d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: false\n",
        "\n",
        "def test_is_num_primes_manually():\n",
        "    \"\"\"Test several positive integers return expected boolean.\n",
        "\n",
        "    This is quite a few lines of code. Note that this runs as a single test.\n",
        "    \"\"\"\n",
        "    assert is_num_prime(1) == False\n",
        "    assert is_num_prime(2) == True\n",
        "    assert is_num_prime(3) == True\n",
        "    assert is_num_prime(4) == False\n",
        "    assert is_num_prime(5) == True"
      ],
      "id": "88338efc",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "One way that this can be serialised is by using a list of parameters and\n",
        "expected results."
      ],
      "id": "23f2715e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: false\n",
        "\n",
        "def test_is_num_primes_with_list():\n",
        "    \"\"\"Test the same values using lists.\n",
        "\n",
        "    Less lines but is run as a single test.\n",
        "    \"\"\"\n",
        "    answers = [is_num_prime(i) for i in range(1, 6)]\n",
        "    assert answers == [False, True, True, False, True]"
      ],
      "id": "8919b4f9",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "This is certainly neater than the previous example. Although both\n",
        "implementations will evaluate as a single test, so a failing instance will not\n",
        "be explicitly indicated in the `pytest` report.\n",
        "\n",
        "```\n",
        "% pytest -k \"test_is_num_primes_with_list\"\n",
        "============================= test session starts =============================\n",
        "platform darwin -- Python 3.12.3, pytest-8.1.1, pluggy-1.5.0\n",
        "configfile: pyproject.toml\n",
        "testpaths: ./tests\n",
        "collected 56 items / 55 deselected / 1 selected                               \n",
        "\n",
        "tests/test_primes.py .                                                   [100%]\n",
        "\n",
        "======================= 1 passed, 55 deselected in 0.01s ======================\n",
        "```\n",
        "\n",
        "To parametrize the equivalent test, we can take the below approach."
      ],
      "id": "4e9e0e71"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: false\n",
        "\n",
        "@pytest.mark.parametrize(\n",
        "    \"some_integers, answers\",\n",
        "    [(1, False), (2, True), (3, True), (4, False), (5, True)]\n",
        "    )\n",
        "def test_is_num_primes_parametrized(some_integers, answers):\n",
        "    \"\"\"The same tests but this time with parametrized input.\n",
        "\n",
        "    Fewer lines and 5 separate tests are run by pytest.\n",
        "    \"\"\"\n",
        "    assert is_num_prime(some_integers) == answers"
      ],
      "id": "662a02dc",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "This is slightly more lines than `test_is_num_primes_with_list` but has the\n",
        "advantage of being run as separate tests:\n",
        "\n",
        "```\n",
        "% pytest -k \"test_is_num_primes_parametrized\" -v\n",
        "============================= test session starts =============================\n",
        "platform darwin -- Python 3.12.3, pytest-8.1.1, pluggy-1.5.0\n",
        "cachedir: .pytest_cache\n",
        "configfile: pyproject.toml\n",
        "testpaths: ./tests\n",
        "collected 56 items / 51 deselected / 5 selected                               \n",
        "\n",
        "tests/test_primes.py::test_is_num_primes_parametrized[1-False] PASSED    [ 20%]\n",
        "tests/test_primes.py::test_is_num_primes_parametrized[2-True] PASSED     [ 40%]\n",
        "tests/test_primes.py::test_is_num_primes_parametrized[3-True] PASSED     [ 60%]\n",
        "tests/test_primes.py::test_is_num_primes_parametrized[4-False] PASSED    [ 80%]\n",
        "tests/test_primes.py::test_is_num_primes_parametrized[5-True] PASSED     [100%]\n",
        "\n",
        "======================= 5 passed, 51 deselected in 0.01s ======================\n",
        "\n",
        "```\n",
        "\n",
        "Where this approach really comes into its own is when the number of cases you\n",
        "need to test increases, you can explore ways of generating cases rather than\n",
        "hard-coding the values, as in the previous examples.\n",
        "\n",
        "In the example below, we can use the `range()` function to generate the \n",
        "integers we need to test, and then zipping these cases to their expected return\n",
        "values."
      ],
      "id": "bc9976ba"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: false\n",
        "\n",
        "# if my list of cases is growing, I can employ other tactics...\n",
        "in_ = range(1, 21)\n",
        "out = [\n",
        "    False, True, True, False, True, False, True, False, False, False,\n",
        "    True, False, True, False, False, False, True, False, True, False,\n",
        "    ]\n",
        "\n",
        "\n",
        "@pytest.mark.parametrize(\"some_integers, some_answers\", zip(in_, out))\n",
        "def test_is_num_primes_with_zipped_lists(some_integers, some_answers):\n",
        "    \"\"\"The same tests but this time with zipped inputs.\"\"\"\n",
        "    assert is_num_prime(some_integers) == some_answers"
      ],
      "id": "5a13db51",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Running this test yields the following result:\n",
        "\n",
        ":::{.scrolling}\n",
        "\n",
        "```\n",
        "% pytest -k \"test_is_num_primes_with_zipped_lists\" -v \n",
        "============================= test session starts =============================\n",
        "platform darwin -- Python 3.11.6, pytest-7.4.3, pluggy-1.3.0\n",
        "cachedir: .pytest_cache\n",
        "configfile: pyproject.toml\n",
        "testpaths: ./tests\n",
        "plugins: anyio-4.0.0\n",
        "collected 56 items / 36 deselected / 20 selected\n",
        "\n",
        "/test_primes.py::test_is_num_primes_with_zipped_lists[1-False] PASSED  [  5%]\n",
        "/test_primes.py::test_is_num_primes_with_zipped_lists[2-True] PASSED   [ 10%]\n",
        "/test_primes.py::test_is_num_primes_with_zipped_lists[3-True] PASSED   [ 15%]\n",
        "/test_primes.py::test_is_num_primes_with_zipped_lists[4-False] PASSED  [ 20%]\n",
        "/test_primes.py::test_is_num_primes_with_zipped_lists[5-True] PASSED   [ 25%]\n",
        "/test_primes.py::test_is_num_primes_with_zipped_lists[6-False] PASSED  [ 30%]\n",
        "/test_primes.py::test_is_num_primes_with_zipped_lists[7-True] PASSED   [ 35%]\n",
        "/test_primes.py::test_is_num_primes_with_zipped_lists[8-False] PASSED  [ 40%]\n",
        "/test_primes.py::test_is_num_primes_with_zipped_lists[9-False] PASSED  [ 45%]\n",
        "/test_primes.py::test_is_num_primes_with_zipped_lists[10-False] PASSED [ 50%]\n",
        "/test_primes.py::test_is_num_primes_with_zipped_lists[11-True] PASSED  [ 55%]\n",
        "/test_primes.py::test_is_num_primes_with_zipped_lists[12-False] PASSED [ 60%]\n",
        "/test_primes.py::test_is_num_primes_with_zipped_lists[13-True] PASSED  [ 65%]\n",
        "/test_primes.py::test_is_num_primes_with_zipped_lists[14-False] PASSED [ 70%]\n",
        "/test_primes.py::test_is_num_primes_with_zipped_lists[15-False] PASSED [ 75%]\n",
        "/test_primes.py::test_is_num_primes_with_zipped_lists[16-False] PASSED [ 80%]\n",
        "/test_primes.py::test_is_num_primes_with_zipped_lists[17-True] PASSED  [ 85%]\n",
        "/test_primes.py::test_is_num_primes_with_zipped_lists[18-False] PASSED [ 90%]\n",
        "/test_primes.py::test_is_num_primes_with_zipped_lists[19-True] PASSED  [ 95%]\n",
        "/test_primes.py::test_is_num_primes_with_zipped_lists[20-False] PASSED [100%]\n",
        "\n",
        "====================== 20 passed, 36 deselected in 0.02s ======================\n",
        "```\n",
        "\n",
        ":::\n",
        "\n",
        "## Stacked Parametrization\n",
        "\n",
        "Parametrize gets really interesting when you have a situation where you need to\n",
        "test **combinations of input parameters** against expected outputs. In this\n",
        "scenario, stacked parametrization allows you to set up all combinations with\n",
        "very little fuss. \n",
        "\n",
        "For this section, I will define a new function built on top of our\n",
        "`is_num_prime()` function. This function will take 2 positive integers and add\n",
        "them together, but only if both of the input integers are prime. Otherwise,\n",
        "we'll simply return the input numbers. To keep things simple, we'll always\n",
        "return a tuple in all cases."
      ],
      "id": "b7c1b998"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def sum_if_prime(pos_int1: int, pos_int2: int) -> tuple:\n",
        "    \"\"\"Sum 2 integers only if they are prime numbers.\n",
        "\n",
        "    Parameters\n",
        "    ----------\n",
        "    pos_int1 : int\n",
        "        A positive integer.\n",
        "    pos_int2 : int\n",
        "        A positive integer.\n",
        "\n",
        "    Returns\n",
        "    -------\n",
        "    tuple\n",
        "        Tuple of one integer if both inputs are prime numbers, else returns a\n",
        "        tuple of the inputs.\n",
        "    \"\"\"\n",
        "    if is_num_prime(pos_int1) and is_num_prime(pos_int2):\n",
        "        return (pos_int1 + pos_int2,)\n",
        "    else:\n",
        "        return (pos_int1, pos_int2)"
      ],
      "id": "3773bc2b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Then using this function with a range of numbers:"
      ],
      "id": "fb9cda50"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "for i in range(1, 6):\n",
        "    print(f\"{i} and {i} result: {sum_if_prime(i, i)}\")"
      ],
      "id": "a0828ee4",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Testing combinations of input parameters for this function will quickly become\n",
        "burdensome:"
      ],
      "id": "020b9775"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: false\n",
        "from example_pkg.primes import sum_if_prime\n",
        "\n",
        "\n",
        "def test_sum_if_prime_with_manual_combinations():\n",
        "    \"\"\"Manually check several cases.\"\"\"\n",
        "    assert sum_if_prime(1, 1) == (1, 1)\n",
        "    assert sum_if_prime(1, 2) == (1, 2)\n",
        "    assert sum_if_prime(1, 3) == (1, 3)\n",
        "    assert sum_if_prime(1, 4) == (1, 4)\n",
        "    assert sum_if_prime(1, 5) == (1, 5)\n",
        "    assert sum_if_prime(2, 1) == (2, 1)\n",
        "    assert sum_if_prime(2, 2) == (4,) # the first case where both are primes\n",
        "    assert sum_if_prime(2, 3) == (5,) \n",
        "    assert sum_if_prime(2, 4) == (2, 4)\n",
        "    assert sum_if_prime(2, 5) == (7,)\n",
        "    # ..."
      ],
      "id": "e97b9fe3",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "```\n",
        "% pytest -k \"test_sum_if_prime_with_manual_combinations\"\n",
        "============================= test session starts =============================\n",
        "platform darwin -- Python 3.12.3, pytest-8.1.1, pluggy-1.5.0\n",
        "configfile: pyproject.toml\n",
        "testpaths: ./tests\n",
        "collected 56 items / 55 deselected / 1 selected\n",
        "\n",
        "tests/test_primes.py .                                                   [100%]\n",
        "\n",
        "====================== 1 passed, 55 deselected in 0.01s =======================\n",
        "\n",
        "```\n",
        "\n",
        "### Single Assertions\n",
        "\n",
        "Because we take more than one input parameter, we can use stacked\n",
        "parametrization to easily inject all combinations of parameters to a test.\n",
        "Simply put, this means that we pass more than one parametrized fixture to the\n",
        "same test. Behind the scenes, `pytest` prepares all parameter combinations to\n",
        "inject into our test. \n",
        "\n",
        "This allows us to very easily pass all parameter combinations to a\n",
        "**single assertion statement**, as in the diagram below.\n",
        "\n",
        "```{mermaid}\n",
        "%%| label: fig-stacked-single\n",
        "%%| fig-cap: \"Stacked parametrization against a single assertion\"\n",
        "flowchart LR\n",
        "    subgraph fix1 [\"@parametrize first_ints\"]\n",
        "        A1[1]\n",
        "        A2[2]\n",
        "        A3[3]\n",
        "    end\n",
        "    subgraph fix2 [\"@parametrize second_ints\"]\n",
        "        B1[1]\n",
        "        B2[2]\n",
        "        B3[3]\n",
        "    end\n",
        "    fix1 --> C[\"All Combinations: 3 x 3 = 9 tests\"]\n",
        "    fix2 --> C\n",
        "    C --> T[\"Single Assertion: isinstance(result, tuple)\"]\n",
        "```\n",
        "\n",
        "To use stacked parametrization against our `sum_if_prime()` function, we can\n",
        "use 2 separate iterables:"
      ],
      "id": "f6c6300a"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: false\n",
        "@pytest.mark.parametrize(\"first_ints\", range(1,6))\n",
        "@pytest.mark.parametrize(\"second_ints\", range(1,6))\n",
        "def test_sum_if_prime_stacked_parametrized_inputs(\n",
        "    first_ints, second_ints, expected_answers):\n",
        "    \"\"\"Using stacked parameters to set up combinations of all cases.\"\"\"\n",
        "    assert isinstance(sum_if_prime(first_ints, second_ints), tuple)"
      ],
      "id": "9a34d35e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::{.scrolling}\n",
        "\n",
        "```\n",
        "% pytest -k \"test_sum_if_prime_stacked_parametrized_inputs\" -v\n",
        "============================= test session starts =============================\n",
        "platform darwin -- Python 3.11.6, pytest-7.4.3, pluggy-1.3.0 \n",
        "cachedir: .pytest_cache\n",
        "configfile: pyproject.toml\n",
        "testpaths: ./tests\n",
        "plugins: anyio-4.0.0\n",
        "collected 56 items / 31 deselected / 25 selected\n",
        "\n",
        "test_sum_if_prime_stacked_parametrized_inputs[1-1] PASSED                [  4%]\n",
        "test_sum_if_prime_stacked_parametrized_inputs[1-2] PASSED                [  8%]\n",
        "test_sum_if_prime_stacked_parametrized_inputs[1-3] PASSED                [ 12%]\n",
        "test_sum_if_prime_stacked_parametrized_inputs[1-4] PASSED                [ 16%]\n",
        "test_sum_if_prime_stacked_parametrized_inputs[1-5] PASSED                [ 20%]\n",
        "test_sum_if_prime_stacked_parametrized_inputs[2-1] PASSED                [ 24%]\n",
        "test_sum_if_prime_stacked_parametrized_inputs[2-2] PASSED                [ 28%]\n",
        "test_sum_if_prime_stacked_parametrized_inputs[2-3] PASSED                [ 32%]\n",
        "test_sum_if_prime_stacked_parametrized_inputs[2-4] PASSED                [ 36%]\n",
        "test_sum_if_prime_stacked_parametrized_inputs[2-5] PASSED                [ 40%]\n",
        "test_sum_if_prime_stacked_parametrized_inputs[3-1] PASSED                [ 44%]\n",
        "test_sum_if_prime_stacked_parametrized_inputs[3-2] PASSED                [ 48%]\n",
        "test_sum_if_prime_stacked_parametrized_inputs[3-3] PASSED                [ 52%]\n",
        "test_sum_if_prime_stacked_parametrized_inputs[3-4] PASSED                [ 56%]\n",
        "test_sum_if_prime_stacked_parametrized_inputs[3-5] PASSED                [ 60%]\n",
        "test_sum_if_prime_stacked_parametrized_inputs[4-1] PASSED                [ 64%]\n",
        "test_sum_if_prime_stacked_parametrized_inputs[4-2] PASSED                [ 68%]\n",
        "test_sum_if_prime_stacked_parametrized_inputs[4-3] PASSED                [ 72%]\n",
        "test_sum_if_prime_stacked_parametrized_inputs[4-4] PASSED                [ 76%]\n",
        "test_sum_if_prime_stacked_parametrized_inputs[4-5] PASSED                [ 80%]\n",
        "test_sum_if_prime_stacked_parametrized_inputs[5-1] PASSED                [ 84%]\n",
        "test_sum_if_prime_stacked_parametrized_inputs[5-2] PASSED                [ 88%]\n",
        "test_sum_if_prime_stacked_parametrized_inputs[5-3] PASSED                [ 92%]\n",
        "test_sum_if_prime_stacked_parametrized_inputs[5-4] PASSED                [ 96%]\n",
        "test_sum_if_prime_stacked_parametrized_inputs[5-5] PASSED                [100%]\n",
        "\n",
        "====================== 25 passed, 31 deselected in 0.01s ======================\n",
        "\n",
        "```\n",
        ":::\n",
        "<br>\n",
        "The above test; which is 6 lines long; executed 25 tests. This is clearly a very\n",
        "beneficial feature of `pytest`. However, the eagle-eyed among you may have\n",
        "spotted a problem - this is only going to work if the expected answer is always\n",
        "the same. The test we defined is only checking that a `tuple` is returned in\n",
        "all cases. How can we ensure that we serve the expected answers to the test\n",
        "too? This is where things get a little fiddly.\n",
        "\n",
        "### Multiple Assertions\n",
        "\n",
        "To test our function against combinations of parameters with\n",
        "**different expected answers**, we must employ a dictionary mapping of the\n",
        "parameter combinations as keys and the expected assertions as values.\n",
        "\n",
        "```{mermaid}\n",
        "%%| label: fig-dict-mapping\n",
        "%%| fig-cap: \"Using a dictionary to map multiple assertions against stacked parametrized fixtures\"\n",
        "flowchart LR\n",
        "    subgraph stack [Stacked Fixtures]\n",
        "        P1[\"first_ints: 1,2,3\"]\n",
        "        P2[\"second_ints: 1,2,3\"]\n",
        "    end\n",
        "    stack --> L[\"Lookup: expected[first][second]\"]\n",
        "    subgraph dict [Dictionary Fixture]\n",
        "        D[\"{1: {1: result, 2: result}, 2: {...}}\"]\n",
        "    end\n",
        "    dict --> L\n",
        "    L --> A[\"assert answer == expected\"]\n",
        "```\n",
        "\n",
        "To do this, we need to define a new fixture, which will return the required\n",
        "dictionary mapping of parameters to expected values."
      ],
      "id": "aa87f91c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: false\n",
        "# Using stacked parametrization, we can avoid manually typing the cases out,\n",
        "# though we do still need to define a dictionary of the expected answers...\n",
        "@pytest.fixture\n",
        "def expected_answers() -> dict:\n",
        "    \"\"\"A dictionary of expected answers for all combinations of 1 through 5.\n",
        "\n",
        "    First key corresponds to `pos_int1` and second key is `pos_int2`.\n",
        "\n",
        "    Returns\n",
        "    -------\n",
        "    dict\n",
        "        Dictionary of cases and their expected tuples.\n",
        "    \"\"\"\n",
        "    expected= {\n",
        "        1: {1: (1,1), 2: (1,2), 3: (1,3), 4: (1,4), 5: (1,5),},\n",
        "        2: {1: (2,1), 2: (4,), 3: (5,), 4: (2,4), 5: (7,),},\n",
        "        3: {1: (3,1), 2: (5,), 3: (6,), 4: (3,4), 5: (8,),},\n",
        "        4: {1: (4,1), 2: (4,2), 3: (4,3), 4: (4,4), 5: (4,5),},\n",
        "        5: {1: (5,1), 2: (7,), 3: (8,), 4: (5,4), 5: (10,),},\n",
        "    }\n",
        "    return expected"
      ],
      "id": "f033f4a0",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Passing our `expected_answers` fixture to our test will allow us to match all\n",
        "parameter combinations to their expected answer. Let's update\n",
        "`test_sum_if_prime_stacked_parametrized_inputs` to use the parameter values to\n",
        "access the expected assertion value from the dictionary."
      ],
      "id": "98f8ba45"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: false\n",
        "@pytest.mark.parametrize(\"first_ints\", range(1,6))\n",
        "@pytest.mark.parametrize(\"second_ints\", range(1,6))\n",
        "def test_sum_if_prime_stacked_parametrized_inputs(\n",
        "    first_ints, second_ints, expected_answers):\n",
        "    \"\"\"Using stacked parameters to set up combinations of all cases.\"\"\"\n",
        "    assert isinstance(sum_if_prime(first_ints, second_ints), tuple)\n",
        "    answer = sum_if_prime(first_ints, second_ints)\n",
        "    # using the parametrized values, pull out their keys from the\n",
        "    # expected_answers dictionary\n",
        "    assert answer == expected_answers[first_ints][second_ints]"
      ],
      "id": "3bc3cee8",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Finally, running this test produces the below `pytest` report.\n",
        "\n",
        ":::{.scrolling}\n",
        "\n",
        "```\n",
        "% pytest -k \"test_sum_if_prime_stacked_parametrized_inputs\" -v\n",
        "============================= test session starts =============================\n",
        "platform darwin -- Python 3.12.3, pytest-8.1.1, pluggy-1.5.0 \n",
        "cachedir: .pytest_cache\n",
        "configfile: pyproject.toml\n",
        "testpaths: ./tests\n",
        "collected 56 items / 31 deselected / 25 selected\n",
        "\n",
        "test_sum_if_prime_stacked_parametrized_inputs[1-1] PASSED                [  4%]\n",
        "test_sum_if_prime_stacked_parametrized_inputs[1-2] PASSED                [  8%]\n",
        "test_sum_if_prime_stacked_parametrized_inputs[1-3] PASSED                [ 12%]\n",
        "test_sum_if_prime_stacked_parametrized_inputs[1-4] PASSED                [ 16%]\n",
        "test_sum_if_prime_stacked_parametrized_inputs[1-5] PASSED                [ 20%]\n",
        "test_sum_if_prime_stacked_parametrized_inputs[2-1] PASSED                [ 24%]\n",
        "test_sum_if_prime_stacked_parametrized_inputs[2-2] PASSED                [ 28%]\n",
        "test_sum_if_prime_stacked_parametrized_inputs[2-3] PASSED                [ 32%]\n",
        "test_sum_if_prime_stacked_parametrized_inputs[2-4] PASSED                [ 36%]\n",
        "test_sum_if_prime_stacked_parametrized_inputs[2-5] PASSED                [ 40%]\n",
        "test_sum_if_prime_stacked_parametrized_inputs[3-1] PASSED                [ 44%]\n",
        "test_sum_if_prime_stacked_parametrized_inputs[3-2] PASSED                [ 48%]\n",
        "test_sum_if_prime_stacked_parametrized_inputs[3-3] PASSED                [ 52%]\n",
        "test_sum_if_prime_stacked_parametrized_inputs[3-4] PASSED                [ 56%]\n",
        "test_sum_if_prime_stacked_parametrized_inputs[3-5] PASSED                [ 60%]\n",
        "test_sum_if_prime_stacked_parametrized_inputs[4-1] PASSED                [ 64%]\n",
        "test_sum_if_prime_stacked_parametrized_inputs[4-2] PASSED                [ 68%]\n",
        "test_sum_if_prime_stacked_parametrized_inputs[4-3] PASSED                [ 72%]\n",
        "test_sum_if_prime_stacked_parametrized_inputs[4-4] PASSED                [ 76%]\n",
        "test_sum_if_prime_stacked_parametrized_inputs[4-5] PASSED                [ 80%]\n",
        "test_sum_if_prime_stacked_parametrized_inputs[5-1] PASSED                [ 84%]\n",
        "test_sum_if_prime_stacked_parametrized_inputs[5-2] PASSED                [ 88%]\n",
        "test_sum_if_prime_stacked_parametrized_inputs[5-3] PASSED                [ 92%]\n",
        "test_sum_if_prime_stacked_parametrized_inputs[5-4] PASSED                [ 96%]\n",
        "test_sum_if_prime_stacked_parametrized_inputs[5-5] PASSED                [100%]\n",
        "\n",
        "====================== 25 passed, 31 deselected in 0.01s ======================\n",
        "```\n",
        "\n",
        ":::\n",
        "\n",
        "## Summary\n",
        "\n",
        "There you have it - how to use basic and stacked parametrization in your tests.\n",
        "We have:\n",
        "\n",
        "* used parametrize to inject multiple parameter values to a single test.\n",
        "* used stacked parametrize to test combinations of parameters against a single\n",
        "assertion.\n",
        "* used a nested dictionary fixture to map stacked parametrize input\n",
        "combinations to different expected assertion values.\n",
        "\n",
        "If you spot an error with this article, or have a suggested improvement then\n",
        "feel free to\n",
        "[raise an issue on GitHub](https://github.com/r-leyshon/blogging/issues).  \n",
        "\n",
        "Happy testing!\n",
        "\n",
        "## Acknowledgements\n",
        "\n",
        "To past and present colleagues who have helped to discuss pros and cons,\n",
        "establishing practice and firming-up some opinions. Particularly:\n",
        "\n",
        "* Charlie\n",
        "* Ethan\n",
        "* Henry\n",
        "* Sergio\n",
        "\n",
        "<p id=fin><i>fin!</i></p>"
      ],
      "id": "dc46c531"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "pytest-env",
      "language": "python",
      "display_name": "pytest-env"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}