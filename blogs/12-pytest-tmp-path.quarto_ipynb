{
 "cells": [
  {
   "cell_type": "raw",
   "id": "691d04d2",
   "metadata": {},
   "source": [
    "---\n",
    "title: Pytest With `tmp_path` in Plain English\n",
    "author: Rich Leyshon\n",
    "date: April 25 2024\n",
    "description: Plain English Discussion of Pytest Temporary Fixtures.\n",
    "categories:\n",
    "  - Explanation\n",
    "  - pytest\n",
    "  - Unit tests\n",
    "  - tmp_path\n",
    "  - tmp_path_factory\n",
    "  - fixtures\n",
    "  - pytest-in-plain-english\n",
    "image: /./www/12-pytest-tmp-path/intro-img.jpg\n",
    "image-alt: Temporary directories being produced by a factory on a futuristic workbench.\n",
    "toc: true\n",
    "---"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b4ca10b2",
   "metadata": {},
   "source": [
    "<img class=shaded_box src=/./www/12-pytest-tmp-path/intro-img.jpg alt=\"Temporary directories being produced by a factory on a futuristic workbench.\" style=\"display:block;margin-left:auto;margin-right:auto;width:40%;border:none;\">\n",
    "\n",
    "## Introduction\n",
    "\n",
    "`pytest` is a testing package for the python framework. It is broadly used to\n",
    "quality assure code logic. This article discusses why and how we use pytest's\n",
    "temporary fixtures `tmp_path` and `tmp_path_factory`. This blog is the second\n",
    "in a series of blogs called\n",
    "[pytest in plain English](/blogs/index.qmd#category=pytest-in-plain-english),\n",
    "favouring accessible language and simple examples to explain the more intricate\n",
    "features of the `pytest` package.\n",
    "\n",
    "For a wealth of documentation, guides and how-tos, please consult the\n",
    "<a href=\"https://docs.pytest.org/en/8.0.x/\" target=\"_blank\">`pytest` documentation</a>.\n",
    "\n",
    ":::{.callout collapse=\"true\"}\n",
    "\n",
    "### A Note on the Purpose (Click to expand)\n",
    "\n",
    "This article intends to discuss clearly. It doesn't aim to be clever or\n",
    "impressive. Its aim is to extend understanding without overwhelming the reader.\n",
    "\n",
    ":::\n",
    "\n",
    "### Intended Audience\n",
    "\n",
    "Programmers with a working knowledge of python and some familiarity with\n",
    "`pytest` and packaging. The type of programmer who has wondered about how to\n",
    "follow best practice in testing python code.\n",
    "\n",
    "### What You'll Need:\n",
    "\n",
    "- [ ] Preferred python environment manager (eg `conda`)\n",
    "- [ ] `pip install pytest==8.1.1`\n",
    "- [ ] Git\n",
    "- [ ] GitHub account\n",
    "- [ ] Command line access\n",
    "\n",
    "### Preparation\n",
    "\n",
    "This blog is accompanied by code in\n",
    "[this repository](https://github.com/r-leyshon/pytest-fiddly-examples). The\n",
    "main branch provides a template with the minimum structure and requirements\n",
    "expected to run a `pytest` suite. The repo branches contain the code used in\n",
    "the examples of the following sections.\n",
    "\n",
    "Feel free to fork or clone the repo and checkout to the example branches as\n",
    "needed.\n",
    "\n",
    "The example code that accompanies this article is available in the\n",
    "[temp-fixtures branch](https://github.com/r-leyshon/pytest-fiddly-examples/tree/temp-fixtures)\n",
    "of the repo.\n",
    "\n",
    "## What Are Temporary Fixtures?\n",
    "\n",
    "In the previous [`pytest` in plain English](/blogs/11-fiddly-bits-of-pytest.qmd)\n",
    "article, we discussed how to write our own fixtures to serve data to our tests.\n",
    "But `pytest` comes with its own set of fixtures that are really useful in\n",
    "certain situations. In this article, we will consider those fixtures that are\n",
    "used to create temporary directories and files.\n",
    "\n",
    "### Why Do We Need Temporary Fixtures?\n",
    "\n",
    "If the code you need to test carries out file operations, then there are a few\n",
    "considerations needed when writing our tests. It is best practice in testing to\n",
    "ensure the system state is unaffected by running the test suite. In the very\n",
    "worst cases I have encountered, running the test suite has resulted in\n",
    "timestamped csvs being written to disk every time `pytest` was run. As\n",
    "developers potentially run these tests hundreds of times while working on a\n",
    "code base, this thoughtless little side-effect quickly results in a messy file\n",
    "system. \n",
    "\n",
    "Just to clarify - I'm not saying it's a bad idea to use timestamped file names.\n",
    "Or to have functions with these kinds of side effects - these features can be\n",
    "really useful. The problem is when the test suite creates junk on your disk\n",
    "that you weren't aware of...\n",
    "\n",
    "By using temporary fixtures, we are ensuring the tests are isolated from each\n",
    "other and behave in dependable ways. If you ever encounter a test suite that\n",
    "behaves differently on subsequent runs, then be suspicious of a messy test\n",
    "suite with file operations that have changed the state of the system. In order\n",
    "for us to reason about the state of the code, we need to be able to rely on the\n",
    "answers we get from the tests, known in test engineering speak as\n",
    "**determinism**.\n",
    "\n",
    "### Let's Compare the Available Temporary Fixtures\n",
    "\n",
    "The 2 fixtures that we should be working with as of 2024 are `tmp_path` and\n",
    "`tmp_path_factory`. Both of these newer temporary fixtures return\n",
    "`pathlib.Path` objects and are included with the `pytest` package in order to\n",
    "encourage developers to use them. No need to import `tempfile` or any other\n",
    "dependency to get what you need, it's all bundled up with your `pytest`\n",
    "installation.\n",
    "\n",
    "`tmp_path` is a function-scoped fixture. Meaning that if we use `tmp_path` in\n",
    "2 unit tests, then we will be served with 2 separate temporary directories to\n",
    "work with. This should meet most developers' needs. But if you're doing\n",
    "something more complex with files, there are occasions where you may need a\n",
    "more persistent temporary directory. Perhaps a bunch of your functions need to\n",
    "work sequentially using files on disk and you need to test how all these units\n",
    "work together. This kind of scenario can arise if you are working on really\n",
    "large files where in-memory operations become too costly. This is where\n",
    "`tmp_path_factory` can be useful, as it is a session-scoped temporary\n",
    "structure. A `tmp_path_factory` structure will be created at the start of a\n",
    "test suite and will persist until teardown happens once the last test has been\n",
    "executed.\n",
    "\n",
    "| Fixture Name       | Scope    | Teardown after each |\n",
    "| ------------------ | ---------| ------------------- |\n",
    "| `tmp_path`         | function | test function       |\n",
    "| `tmp_path_factory` | session  | `pytest` session    |\n",
    "\n",
    "### What About `tmpdir`?\n",
    "\n",
    "Ah, the eagle-eyed among you may have noticed that the `pytest` package\n",
    "contains other fixtures that are relevant to temporary structures. Namely\n",
    "`tmpdir` and `tmpdir_factory`. These fixtures are older equivalents of the\n",
    "fixtures we discussed above. The main difference is that instead of returning\n",
    "`pathlib.Path` objects, they return `py.path.local` objects. These fixtures\n",
    "were written before `pathlib` had been adopted as the\n",
    "[standardised approach](https://peps.python.org/pep-0519/#standard-library-changes)\n",
    "to handling paths across multiple operating systems. The future of `tmpdir` and\n",
    "`tmpdir_factory` have been discussed for deprecation. These fixtures are being\n",
    "sunsetted and it is advised to port old test suites over to the new `tmp_path`\n",
    "fixture instead. The `pytest` team has\n",
    "[provided a utility](https://docs.pytest.org/en/7.1.x/how-to/tmp_path.html#the-tmpdir-and-tmpdir-factory-fixtures)\n",
    "to help developers identify these issues in their old test suites. \n",
    "\n",
    "In summary, don't use `tmpdir` any more and consider converting old code if you\n",
    "used it in the past... \n",
    "\n",
    "## How to Use Temporary Fixtures\n",
    "\n",
    "### Writing Source Code\n",
    "\n",
    "As a reminder, <a href=\"https://github.com/r-leyshon/pytest-fiddly-examples/tree/temp-fixtures\" target=\"_blank\">the code for this section is located here.</a>\n",
    "\n",
    "In this deliberately silly example, let's say we have a poem sitting on our\n",
    "disk in a text file. Thanks to chatGPT for the poem and MSFT Bing Copilot for\n",
    "the image, making this a trivial consideration. Or should I really thank the\n",
    "millions of people who wrote the content that these services trained on?\n",
    "\n",
    "Saving the text file in the chunk below to the `./tests/data/` folder is where\n",
    "you would typically save data for your tests.\n",
    "\n",
    "<img src=\"/./www/12-pytest-tmp-path/jack_jill.jpg\" alt=\"A modern take on Jack and Jill sees the pair fending off bugs in a future technological dystopia.\" class=\"center\" width=400/>\n",
    "\n",
    "```{.abc filename=\"tests/data/jack-jill-2024.txt\"}\n",
    "In the realm of data, where Jack and Jill dwell,\n",
    "They ventured forth, their tale to tell.\n",
    "But amidst the bytes, a glitch they found,\n",
    "A challenge profound, in algorithms bound.\n",
    "\n",
    "Their circuits whirred, their processors spun,\n",
    "As they analyzed the glitch, one by one.\n",
    "Yet despite their prowess, misfortune struck,\n",
    "A bug so elusive, like lightning struck.\n",
    "\n",
    "Their systems faltered, errors abound,\n",
    "As frustration grew with each rebound.\n",
    "But Jack and Jill, with minds so keen,\n",
    "Refused to let the glitch remain unseen.\n",
    "\n",
    "With perseverance strong and logic clear,\n",
    "They traced the bug to its hidden sphere.\n",
    "And with precision fine and code refined,\n",
    "They patched the glitch, their brilliance defined.\n",
    "\n",
    "In the end, though misfortune came their way,\n",
    "Jack and Jill triumphed, without delay.\n",
    "For in the realm of AI, where challenges frown,\n",
    "Their intellect prevailed, wearing victory's crown.\n",
    "\n",
    "So let their tale inspire, in bytes and code,\n",
    "Where challenges rise on the digital road.\n",
    "For Jack and Jill, with their AI might,\n",
    "Showed that even in darkness, there's always light.\n",
    "\n",
    "```\n",
    "\n",
    "Let's imagine we need a program that can edit the text and write new versions\n",
    "of the poem to disk. Let's go ahead and create a function that will read the\n",
    "poem from disk and replace any word that you'd like to change."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "20e6e98b",
   "metadata": {},
   "outputs": [],
   "source": [
    "\"\"\"Demonstrating tmp_path & tmp_path_factory with a simple txt file.\"\"\"\n",
    "from pathlib import Path\n",
    "from typing import Union\n",
    "\n",
    "def _update_a_term(\n",
    "    txt_pth: Union[Path, str], target_pattern:str, replacement:str) -> str:\n",
    "    \"\"\"Replace the target pattern in a body of text.\n",
    "\n",
    "    Parameters\n",
    "    ----------\n",
    "    txt_pth : Union[Path, str]\n",
    "        Path to a txt file.\n",
    "    target_pattern : str\n",
    "        The pattern to replace.\n",
    "    replacement : str\n",
    "        The replacement value.\n",
    "\n",
    "    Returns\n",
    "    -------\n",
    "    str\n",
    "        String with any occurrences of target_pattern replaced with specified\n",
    "        replacement value.\n",
    "\n",
    "    \"\"\"\n",
    "    with open(txt_pth, \"r\") as f:\n",
    "        txt = f.read()\n",
    "        f.close()\n",
    "    return txt.replace(target_pattern, replacement)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e8c129f5",
   "metadata": {},
   "source": [
    "Now we can try using the function to rename a character in the rhyme, by\n",
    "running the below code in a python shell."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "145b276e",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "In the realm of data, where Jack and Jock dwell,\n",
      "They ventured forth, their tale to tell.\n",
      "But amidst the bytes, a glitch they found,\n",
      "A challenge profound, in algorithms bound.\n"
     ]
    }
   ],
   "source": [
    "from pyprojroot import here\n",
    "rhyme = _update_a_term(\n",
    "  txt_pth=here(\"data/blogs/jack-jill-2024.txt\"),\n",
    "  target_pattern=\"Jill\",\n",
    "  replacement=\"Jock\")\n",
    "print(rhyme[0:175])"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f3ccfa51",
   "metadata": {},
   "source": [
    "::: {.callout-note collapse=\"true\"}\n",
    "\n",
    "#### Why Use Underscores?\n",
    "\n",
    "You may have noticed that the above function starts with an underscore. This\n",
    "convention means the function is not intended for use by the user. These\n",
    "internal functions would typically have less defensive checks than those you\n",
    "intend to expose to your users. It's not an enforced thing but is considered\n",
    "good practice. It means \"use at your own risk\" as internals often have less\n",
    "documentation, may not be directly tested and could be less stable than\n",
    "functions in the api.\n",
    "\n",
    ":::\n",
    "\n",
    "Great, next we need a little utility function that will take our text and write\n",
    "it to a file of our choosing."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "b8d7a01b",
   "metadata": {},
   "outputs": [],
   "source": [
    "def _write_string_to_txt(some_txt:str, out_pth:Union[Path, str]) -> None:\n",
    "    \"\"\"Write some string to a text file.\n",
    "\n",
    "    Parameters\n",
    "    ----------\n",
    "    some_txt : str\n",
    "        The text to write to file.\n",
    "    out_pth : Union[Path, str]\n",
    "        The path to the file.\n",
    "    \n",
    "    Returns\n",
    "    -------\n",
    "    None\n",
    "\n",
    "    \"\"\"\n",
    "    with open(out_pth, \"w\") as f:\n",
    "        f.writelines(some_txt)\n",
    "        f.close()    "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "bd4989e5",
   "metadata": {},
   "source": [
    "Finally, we need a wrapper function that will use the above functions, allowing\n",
    "the user to read in the text file, replace a pattern and then write the new\n",
    "poem to file."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "e6efe982",
   "metadata": {},
   "outputs": [],
   "source": [
    "def update_poem(\n",
    "    poem_pth:Union[Path, str],\n",
    "    target_pattern:str,\n",
    "    replacement:str,\n",
    "    out_file:Union[Path, str]) -> None:\n",
    "    \"\"\"Takes a txt file, replaces a pattern and writes to a new file.\n",
    "\n",
    "    Parameters\n",
    "    ----------\n",
    "    poem_pth : Union[Path, str]\n",
    "        Path to a txt file.\n",
    "    target_pattern : str\n",
    "        A pattern to update.\n",
    "    replacement : str\n",
    "        The replacement value.\n",
    "    out_file : Union[Path, str]\n",
    "        A file path to write to.\n",
    "\n",
    "    \"\"\"\n",
    "    txt = _update_a_term(poem_pth, target_pattern, replacement)\n",
    "    _write_string_to_txt(txt, out_file)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5aa257af",
   "metadata": {},
   "source": [
    "How do we know it works? We can use it and observe the output, as I did with\n",
    "`_update_a_term()` earlier, but this article is about testing. So let's get to\n",
    "it.\n",
    "\n",
    "### Testing the Source Code\n",
    "\n",
    "We need to test `update_poem()` but it writes files to disk. We don't want to\n",
    "litter our (and our colleagues') disks with files every time `pytest` runs.\n",
    "Therefore we need to ensure the function's `out_file` parameter is pointing at\n",
    "a temporary directory. In that way, we can rely on the temporary structure's\n",
    "behaviour on teardown to remove these files when pytest finishes doing its\n",
    "business."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "3c70f60f",
   "metadata": {},
   "outputs": [],
   "source": [
    "#| eval: false\n",
    "\n",
    "\"\"\"Tests for update_poetry module.\"\"\"\n",
    "import os\n",
    "\n",
    "import pytest\n",
    "\n",
    "from example_pkg import update_poetry\n",
    "\n",
    "def test_update_poem_writes_new_pattern_to_file(tmp_path):\n",
    "    \"\"\"Check that update_poem changes the poem pattern and writes to file.\"\"\"\n",
    "    new_poem_path = os.path.join(tmp_path, \"new_poem.txt\")\n",
    "    update_poetry.update_poem(\n",
    "        poem_pth=\"tests/data/jack-jill-2024.txt\",\n",
    "        target_pattern=\"glitch\",\n",
    "        replacement=\"bug\",\n",
    "        out_file=new_poem_path\n",
    "        )"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "bd97bd83",
   "metadata": {},
   "source": [
    "Before I go ahead and add a bunch of assertions in, look at how easy it is to\n",
    "use `tmp_path`, blink and you'll miss it. You simply reference it in the\n",
    "signature of the test where you wish to use it and then you are able to work\n",
    "with it like you would any other path object.\n",
    "\n",
    "So far in this test function, I specified that I'd like to read the text from a\n",
    "file called `jack-jill-2024.txt`, replace the word \"glitch\" with \"bug\" wherever\n",
    "it occurs and then write this text to a file called `new_poem.txt` in a\n",
    "temporary directory. \n",
    "\n",
    "Some simple tests for this little function:\n",
    "\n",
    "* Does the file I asked for exist?\n",
    "* Are the contents of that file as I expect?\n",
    "\n",
    "Let's go ahead and add in those assertions."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "e50bfc11",
   "metadata": {},
   "outputs": [],
   "source": [
    "#| eval: false\n",
    "\n",
    "\"\"\"Tests for update_poetry module.\"\"\"\n",
    "\n",
    "import os\n",
    "\n",
    "import pytest\n",
    "\n",
    "from example_pkg import update_poetry\n",
    "\n",
    "def test_update_poem_writes_new_pattern_to_file(tmp_path):\n",
    "    \"\"\"Check that update_poem changes the poem pattern and writes to file.\"\"\"\n",
    "    new_poem_path = os.path.join(tmp_path, \"new_poem.txt\")\n",
    "    update_poetry.update_poem(\n",
    "        poem_pth=\"tests/data/jack-jill-2024.txt\",\n",
    "        target_pattern=\"glitch\",\n",
    "        replacement=\"bug\",\n",
    "        out_file=new_poem_path\n",
    "        )\n",
    "    # Now for the assertions\n",
    "    assert os.path.exists(new_poem_path)\n",
    "    assert os.listdir(tmp_path) == [\"new_poem.txt\"]\n",
    "    # let's check what pattern was written - now we need to read in the\n",
    "    # contents of the new file.\n",
    "    with open(new_poem_path, \"r\") as f:\n",
    "        what_was_written = f.read()\n",
    "        f.close()\n",
    "    assert \"glitch\" not in what_was_written\n",
    "    assert \"bug\" in what_was_written\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "bacb009b",
   "metadata": {},
   "source": [
    "Running `pytest` results in the below output.\n",
    "\n",
    "```\n",
    "collected 1 item\n",
    "\n",
    "tests/test_update_poetry.py .                                            [100%]\n",
    "\n",
    "============================== 1 passed in 0.01s ==============================\n",
    "```\n",
    "\n",
    "So we prove that the function works how we hoped it would. But what if I want\n",
    "to work with the `new_poem.txt` file again in another test function? Let's add\n",
    "another test to `test_update_poetry.py` and see what we get when we try to use\n",
    "`tmp_path` once more."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "b94fd7ce",
   "metadata": {},
   "outputs": [],
   "source": [
    "#| eval: false\n",
    "\"\"\"Tests for update_poetry module.\"\"\"\n",
    "# import statements ...\n",
    "\n",
    "# def test_update_poem_writes_new_pattern_to_file(tmp_path): ...\n",
    "\n",
    "def test_do_i_get_a_new_tmp_path(tmp_path):\n",
    "    \"\"\"Remind ourselves that tmp_path is function-scoped.\"\"\"\n",
    "    assert \"new_poem\" not in os.listdir(tmp_path)\n",
    "    assert os.listdir(tmp_path) == []\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "6a5fa5f9",
   "metadata": {},
   "source": [
    "As is demonstrated when running `pytest` once more, `tmp_path` is\n",
    "function-scoped and we have now lost the new poem with the bugs instead of the\n",
    "glitches. Drat! What to do...\n",
    "\n",
    "```\n",
    "collected 2 items\n",
    "\n",
    "tests/test_update_poetry.py ..                                           [100%]\n",
    "\n",
    "============================== 2 passed in 0.01s ==============================\n",
    "\n",
    "```\n",
    "\n",
    "As mentioned earlier, `pytest` provides another fixture with more\n",
    "flexibility, called `tmp_path_factory`. As this fixture is session-scoped, we\n",
    "can have full control over this fixture's scoping. \n",
    "\n",
    "::: {.callout-tip collapse=\"true\"}\n",
    "\n",
    "#### Fixture Scopes\n",
    "\n",
    "For a refresher on the rules of scope referencing, please see the blog [Pytest Fixtures in Plain English](/blogs/11-fiddly-bits-of-pytest.qmd#scopemismatch-error).\n",
    "\n",
    ":::"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "69a5e856",
   "metadata": {},
   "outputs": [],
   "source": [
    "#| eval: false\n",
    "\"\"\"Tests for update_poetry module.\"\"\"\n",
    "# import statements ...\n",
    "\n",
    "# def test_update_poem_writes_new_pattern_to_file(tmp_path): ...\n",
    "\n",
    "# def test_do_i_get_a_new_tmp_path(tmp_path): ...\n",
    "\n",
    "@pytest.fixture(scope=\"module\")\n",
    "def _module_scoped_tmp(tmp_path_factory):\n",
    "    yield tmp_path_factory.mktemp(\"put_poetry_here\", numbered=False)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f6ac556e",
   "metadata": {},
   "source": [
    "Note that as `tmp_path_factory` is session-scoped, I'm free to reference it in\n",
    "another fixture with any scope. Here I define a module-scoped fixture, which\n",
    "means teardown of `_module_scoped_tmp` will occur once the final test in this\n",
    "test module completes. Now repeating the logic executed with `tmp_path` above,\n",
    "but this time with our new module-scoped temporary directory, we get a\n",
    "different outcome."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "2e7f967d",
   "metadata": {},
   "outputs": [],
   "source": [
    "#| eval: false\n",
    "\"\"\"Tests for update_poetry module.\"\"\"\n",
    "# import statements ...\n",
    "\n",
    "# def test_update_poem_writes_new_pattern_to_file(tmp_path): ...\n",
    "\n",
    "# def test_do_i_get_a_new_tmp_path(tmp_path): ...\n",
    "\n",
    "@pytest.fixture(scope=\"module\")\n",
    "def _module_scoped_tmp(tmp_path_factory):\n",
    "    yield tmp_path_factory.mktemp(\"put_poetry_here\", numbered=False)\n",
    "\n",
    "\n",
    "def test_module_scoped_tmp_exists(_module_scoped_tmp):\n",
    "    new_poem_path = os.path.join(_module_scoped_tmp, \"new_poem.txt\")\n",
    "    update_poetry.update_poem(\n",
    "        poem_pth=\"tests/data/jack-jill-2024.txt\",\n",
    "        target_pattern=\"glitch\",\n",
    "        replacement=\"bug\",\n",
    "        out_file=new_poem_path\n",
    "        )\n",
    "    assert os.path.exists(new_poem_path)\n",
    "    with open(new_poem_path, \"r\") as f:\n",
    "        what_was_written = f.read()\n",
    "        f.close()\n",
    "    assert \"glitch\" not in what_was_written\n",
    "    assert \"bug\" in what_was_written\n",
    "    assert os.listdir(_module_scoped_tmp) == [\"new_poem.txt\"]\n",
    "\n",
    "\n",
    "def test_do_i_get_a_new_tmp_path_factory(_module_scoped_tmp):\n",
    "    assert not os.listdir(_module_scoped_tmp) == [] # not empty...\n",
    "    assert os.listdir(_module_scoped_tmp) == [\"new_poem.txt\"]\n",
    "    # module-scoped fixture still contains file made in previous test function\n",
    "    with open(os.path.join(_module_scoped_tmp, \"new_poem.txt\")) as f:\n",
    "        found_txt = f.read()\n",
    "        f.close()\n",
    "    assert \"glitch\" not in found_txt\n",
    "    assert \"bug\" in found_txt"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "819ff2e5",
   "metadata": {},
   "source": [
    "Executing `pytest` one final time demonstrates that the same output file\n",
    "written to disk with `test_module_scoped_tmp_exists()` is subsequently\n",
    "available for further testing in `test_do_i_get_a_new_tmp_path_factory()`.\n",
    "\n",
    "```\n",
    "collected 4 items\n",
    "\n",
    "tests/test_update_poetry.py ....                                         [100%]\n",
    "\n",
    "============================== 4 passed in 0.01s ==============================\n",
    "```\n",
    "\n",
    "Note that the order that these 2 tests run in is now important. These tests are\n",
    "no longer isolated and trying to run the second test on its own with\n",
    "`pytest -k \"test_do_i_get_a_new_tmp_path_factory\"` would result in a failure.\n",
    "For this reason, it may be advisable to pop the test functions within a common\n",
    "test class, or even use\n",
    "<a href=\"https://docs.pytest.org/en/7.1.x/example/markers.html\" target=\"_blank\">pytest marks</a>\n",
    "to mark them as integration tests (more on this in a future blog). \n",
    "\n",
    "\n",
    "## Summary\n",
    "\n",
    "The reasons we use temporary fixtures and how to use them has been demonstrated\n",
    "with another silly (but hopefully relatable) little example. I have not gone\n",
    "into the wealth of methods available in these temporary fixtures, but they have\n",
    "many useful utilities. Maybe you're working with a complex nested directory\n",
    "structure for example, the `glob` method would surely help with that.\n",
    "\n",
    "Below are the public methods and attributes of `tmp_path`:\n",
    "\n",
    "```\n",
    "['absolute', 'anchor', 'as_posix', 'as_uri', 'chmod', 'cwd', 'drive', 'exists',\n",
    "'expanduser', 'glob', 'group', 'hardlink_to', 'home', 'is_absolute',\n",
    "'is_block_device', 'is_char_device', 'is_dir', 'is_fifo', 'is_file',\n",
    "'is_junction', 'is_mount', 'is_relative_to', 'is_reserved', 'is_socket',\n",
    "'is_symlink', 'iterdir', 'joinpath', 'lchmod', 'lstat', 'match', 'mkdir',\n",
    "'name', 'open', 'owner', 'parent', 'parents', 'parts', 'read_bytes',\n",
    "'read_text', 'readlink', 'relative_to', 'rename', 'replace', 'resolve',\n",
    "'rglob', 'rmdir', 'root', 'samefile', 'stat', 'stem', 'suffix', 'suffixes',\n",
    "'symlink_to', 'touch', 'unlink', 'walk', 'with_name', 'with_segments',\n",
    "'with_stem', 'with_suffix', 'write_bytes', 'write_text'] \n",
    "```\n",
    "\n",
    "It is useful to\n",
    "[read the `pathlib.Path` docs](https://docs.python.org/3/library/pathlib.html#pathlib.Path)\n",
    "as both fixtures return this type and many of the methods above are inherited\n",
    "from these types. To read the `tmp_path` and `tmp_path_factory` implementation,\n",
    "I recommend reading the\n",
    "[tmp docstrings](https://github.com/pytest-dev/pytest/blob/main/src/_pytest/tmpdir.py)\n",
    "on GitHub.\n",
    "\n",
    "If you spot an error with this article, or have  suggested improvement then\n",
    "feel free to\n",
    "[raise an issue on GitHub](https://github.com/r-leyshon/blogging/issues).  \n",
    "\n",
    "Happy testing!\n",
    "\n",
    "## Acknowledgements\n",
    "\n",
    "To past and present colleagues who have helped to discuss pros and cons,\n",
    "establishing practice and firming-up some opinions. Particularly:\n",
    "\n",
    "* Charlie\n",
    "* Dan\n",
    "* Edward\n",
    "* Ian\n",
    "* Mark\n",
    "\n",
    "<p id=fin><i>fin!</i></p>"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "pytest-env",
   "language": "python",
   "name": "pytest-env"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.12"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
