{
  "cells": [
    {
      "cell_type": "raw",
      "metadata": {},
      "source": [
        "---\n",
        "title: Pytest Fixtures in Plain English\n",
        "author: Rich Leyshon\n",
        "date: April 07 2024\n",
        "description: Plain English Discussion of Pytest Fixtures.\n",
        "categories:\n",
        "  - Explanation\n",
        "  - pytest\n",
        "  - Unit tests\n",
        "  - fixtures\n",
        "  - pytest-in-plain-english\n",
        "image: /./www/11-fiddly-bits-of-pytest/intro-img.jpg\n",
        "image-alt: A futuristic lab test bench.\n",
        "toc: true\n",
        "---"
      ],
      "id": "e66d1097"
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "<img class=shaded_box src=/./www/11-fiddly-bits-of-pytest/intro-img.jpg alt=\"A futuristic lab test bench.\" style=\"display:block;margin-left:auto;margin-right:auto;width:40%;border:none;\">\n",
        "## Introduction\n",
        "\n",
        "`pytest` is a testing package for the python framework. It is broadly used to\n",
        "quality assure code logic. This article discusses using test data as fixtures\n",
        "with `pytest` and is the first in a series of blogs called\n",
        "[pytest in plain English](/blogs/index.qmd#category=pytest-in-plain-english),\n",
        "favouring accessible language and simple examples to explain the more intricate\n",
        "features of the `pytest` package.\n",
        "\n",
        "For a wealth of documentation, guides and how-tos, please consult the\n",
        "<a href=\"https://docs.pytest.org/en/8.0.x/\" target=\"_blank\">pytest documentation</a>.\n",
        "\n",
        ":::{.callout collapse=\"true\"}\n",
        "\n",
        "### A Note on the Purpose (Click to expand)\n",
        "\n",
        "This article intends to discuss clearly. It doesn't aim to be clever or\n",
        "impressive. Its aim is to extend the audience's understanding of the more\n",
        "intricate features of `pytest` by describing their utility with simple code\n",
        "examples.  \n",
        "\n",
        ":::\n",
        "\n",
        "### Intended Audience\n",
        "\n",
        "Programmers with a working knowledge of python and some familiarity with\n",
        "`pytest` and packaging. The type of programmer who has wondered about how to\n",
        "optimise their test code.\n",
        "\n",
        "### What You'll Need:\n",
        "\n",
        "- [ ] Preferred python environment manager (eg `conda`)\n",
        "- [ ] `pip install pytest==8.1.1`\n",
        "- [ ] Git\n",
        "- [ ] GitHub account\n",
        "- [ ] Command line access\n",
        "\n",
        "### Preparation\n",
        "\n",
        "This blog is accompanied by code in\n",
        "[this repository](https://github.com/r-leyshon/pytest-fiddly-examples). The\n",
        "main branch provides a template with the minimum structure and requirements\n",
        "expected to run a `pytest` suite. The repo branches contain the code used in\n",
        "the examples of the following sections.\n",
        "\n",
        "Feel free to fork or clone the repo and checkout to the example branches as\n",
        "needed.\n",
        "\n",
        "The example code that accompanies this article is available in the\n",
        "[fixtures branch](https://github.com/r-leyshon/pytest-fiddly-examples/tree/fixtures)\n",
        "of the example code repo.\n",
        "\n",
        "## What are fixtures?\n",
        "\n",
        "Data. Well, data provided specifically for testing purposes. This is the\n",
        "essential definition for a fixture. One could argue the case that fixtures are\n",
        "more than this. Fixtures could be environment variables, class instances,\n",
        "connection to a server or whatever dependencies your code needs to run.\n",
        "\n",
        "I would agree that fixtures are not just data. But that all fixtures return\n",
        "data of some sort, regardless of the system under test.\n",
        "\n",
        "## When would you use fixtures?\n",
        "\n",
        "It's a bad idea to commit data to a git repository, right? Agreed. Though\n",
        "fixtures are rarely 'real' data. The data used for testing purposes should be\n",
        "minimal and are usually synthetic. \n",
        "\n",
        "**Minimal fixtures** conform to the schema of the actual data that the system\n",
        "requires. These fixtures will be as small as possible while capturing all known\n",
        "important cases. Keeping the data small maintains a performant test suite and\n",
        "avoids problems associated with large files and git version control.\n",
        "\n",
        "If you have ever encountered a problem in a system that was caused by a\n",
        "problematic record in the data, the aspect of that record that broke your\n",
        "system should absolutely make it into the next version of your minimal test\n",
        "fixture. Writing a test that checks that the codebase can handle such problem\n",
        "records is known as 'regression testing' - safeguarding against old bugs\n",
        "resurfacing when code is refactored or new features are implemented. This\n",
        "scenario commonly occurs when a developer unwittingly violates Chesterton's\n",
        "Principle.\n",
        "\n",
        "\n",
        "<iframe src=\"https://www.youtube.com/embed/qPGbl2gxGqI\" class=\"shaded_box\" title=\"Chesterton's Fence by Sprouts\" style=\"display: block; width: 600px; height: 338px\" frameborder=\"0\">\n",
        "</iframe>\n",
        "\n",
        "Many thanks to my colleague Mat for pointing me towards this useful analogy. A\n",
        "considerate developer would probably include a comment in their code about a\n",
        "specific problem that they've handled (like erecting a sign next to\n",
        "Chesterton's fence). An experienced developer would do the same, and also write\n",
        "a regression test to ensure the problem doesn't re-emerge in the future\n",
        "(monitoring the fence with CCTV...). Discovering these problem cases and\n",
        "employing defensive strategies avoids future pain for yourself and colleagues.\n",
        "\n",
        "As you can imagine, covering all the important cases while keeping the fixture\n",
        "minimal is a compromise. At the outset of the work, it may not be obvious what\n",
        "problematic cases may arise. Packages such as\n",
        "[`hypothesis`](https://hypothesis.readthedocs.io/en/latest/) allow you to\n",
        "generate awkward cases. Non-utf-8 strings anyone? Hypothesis can generate\n",
        "these test cases for you, along with many more interesting edge-cases -\n",
        "*ÄƒÑ£ð” Õ®á»Å¿Ä£ÈŸáŽ¥ð’‹Ç©Ä¾á¸¿êž‘È¯ð˜±ð‘žð—‹ð˜´È¶ðž„ðœˆÏˆð’™ð˜†ðš£* (Non-utf8 strings often cause problems for web apps). \n",
        "\n",
        "**Non-disclosive fixtures** are those that do not expose personally\n",
        "identifiable or commercially-sensitive information. If you are working with\n",
        "this sort of data, it is necessary to produce toy test fixtures that mimic the\n",
        "schema of the real data. Names and addresses can be de-identified to random\n",
        "alphanumeric strings. Location data can be adjusted with noise. The use of\n",
        "dummy variables or categories can mitigate the risk of disclosure by\n",
        "differencing.\n",
        "\n",
        "By adequately anonymising data and testing problem cases, the programmer\n",
        "exhibits upholds duties under the General Data Protection Regulation:\n",
        "\n",
        "> accurately store, process, retain and erase personally-identifiable information.\n",
        "\n",
        "In cases where the system integrates with data available in the public domain,\n",
        "it is may be permissible to include a small sample of the data as a test\n",
        "fixture. Ensure the license that the data is distributed under is compatible\n",
        "with your code's license. If the license is compatible, I recommend including a\n",
        "reference to the fixture, its source and license within a LICENSE.note file.\n",
        "This practice is enforced by Comprehensive R Archive Network. You can read more\n",
        "about this in the\n",
        "[R Packages documentation](https://r-pkgs.org/license.html#sec-how-to-include).\n",
        "\n",
        "## Scoping fixtures\n",
        "\n",
        "`pytest` fixtures have different scopes, meaning that they will be prepared\n",
        "differently dependent on the scope you specify. The available scopes are as\n",
        "follows: \n",
        "\n",
        "| Scope Name  | Teardown after each |\n",
        "| ----------- | ------------------- |\n",
        "| function    | test function       |\n",
        "| class       | test class          |\n",
        "| module      | test module         |\n",
        "| package     | package under test  |\n",
        "| session     | `pytest` session    |\n",
        "\n",
        "Note that the default scope for any fixtures that you define will be\n",
        "'function'. A function-scoped fixture will be set up for every test function\n",
        "that requires it. Once the function has executed, the fixture will then be\n",
        "torn down and all changes to this fixture will be lost. This default behaviour\n",
        "encourages isolation in your test suite. Meaning that the tests have no\n",
        "dependencies upon each other. The test functions could be run in any order\n",
        "without affecting the results of the test. Function-scoped fixtures are the\n",
        "shortest-lived fixtures. Moving down the table above, the persistence of the\n",
        "fixtures increases. Changes to a session-scoped fixture persist for the entire\n",
        "test execution duration, only being torn down once `pytest` has executed all\n",
        "tests.\n",
        "\n",
        "### Scoping for performance\n",
        "***\n",
        "\n",
        "> performance vs isolation\n",
        "\n",
        "By definition, a unit test is completely isolated, meaning that it will have no\n",
        "dependencies other than the code it needs to test. However, there may be a few\n",
        "cases where this would be less desirable. Slow test suites may introduce\n",
        "excessive friction to the software development process. Persistent fixtures can\n",
        "be used to improve the performance of a test suite. \n",
        "\n",
        "For example, here we define some expensive class:\n",
        "\n",
        "```{.python filename=expensive.py}\n",
        "\"\"\"A module containing an expensive class definition.\"\"\"\n",
        "import time\n",
        "from typing import Union\n",
        "\n",
        "\n",
        "class ExpensiveDoodah:\n",
        "    \"\"\"A toy class that represents some costly operation.\n",
        "\n",
        "    This class will sleep for the specified number of seconds on instantiation.\n",
        "\n",
        "    Parameters\n",
        "    ----------\n",
        "    sleep_time : Union[int, float]\n",
        "        Number of seconds to wait on init.\n",
        "\n",
        "    \"\"\"\n",
        "    def __init__(self, sleep_time: Union[int, float] = 2):\n",
        "        print(f\"Sleeping for {sleep_time} seconds\")\n",
        "        time.sleep(sleep_time)\n",
        "        return None\n",
        "\n",
        "```\n",
        "\n",
        "This class will be used to demonstrate the effect of scoping with some costly\n",
        "operation. This example could represent reading in a bulky xlsx file or\n",
        "querying a large database.\n",
        "\n",
        "To serve `ExpensiveDoodah` to our tests, I will define a function-scoped\n",
        "fixture. To do this, we use a `pytest` fixture decorator to return the class\n",
        "instance with a specified sleep time of 2 seconds.\n",
        "\n",
        "```{.python filename=test_expensive.py}\n",
        "import pytest\n",
        "\n",
        "from example_pkg.expensive import ExpensiveDoodah\n",
        "\n",
        "\n",
        "@pytest.fixture(scope=\"function\")\n",
        "def module_doodah():\n",
        "    \"\"\"Function-scoped ExpensiveDoodah.\"\"\"\n",
        "    return ExpensiveDoodah(2)\n",
        "\n",
        "```\n",
        "Now to test `ExpensiveDoodah` we extend our test module to include a test class\n",
        "with 3 separate test functions. The assertions will all be the same for this\n",
        "simple example - that `ExpensiveDoodah` executes without raising any error\n",
        "conditions. Notice we must pass the name of the fixture in each test function's\n",
        "signature.\n",
        "\n",
        "```{.python filename=test_expensive.py}\n",
        "\"\"\"Tests for expensive.py using function-scoped fixture.\"\"\"\n",
        "from contextlib import nullcontext as does_not_raise\n",
        "import pytest\n",
        "\n",
        "from example_pkg.expensive import ExpensiveDoodah\n",
        "\n",
        "\n",
        "@pytest.fixture(scope=\"function\")\n",
        "def doodah_fixture():\n",
        "    \"\"\"Function-scoped ExpensiveDoodah.\"\"\"\n",
        "    return ExpensiveDoodah(2)\n",
        "\n",
        "\n",
        "class TestA:\n",
        "    \"\"\"A test class.\"\"\"\n",
        "\n",
        "    def test_1(self, doodah_fixture):\n",
        "        \"\"\"Test 1.\"\"\"\n",
        "        with does_not_raise():\n",
        "            doodah_fixture\n",
        "\n",
        "    def test_2(self, doodah_fixture):\n",
        "        \"\"\"Test 2.\"\"\"\n",
        "        with does_not_raise():\n",
        "            doodah_fixture\n",
        "\n",
        "    def test_3(self, doodah_fixture):\n",
        "        \"\"\"Test 3.\"\"\"\n",
        "        with does_not_raise():\n",
        "            doodah_fixture\n",
        "\n",
        "```\n",
        "\n",
        "The result of running this test module can be seen below:\n",
        "\n",
        "```\n",
        "collected 3 items\n",
        "\n",
        "./tests/test_expensive_function_scoped.py ...    [100%]\n",
        "\n",
        "============================ 3 passed in 6.04s ================================\n",
        "\n",
        "```\n",
        "\n",
        "Notice that the test module took just over 6 seconds to execute because the\n",
        "function-scoped fixture was set up once for each test function.\n",
        "\n",
        "If instead we had defined `doodah_fixture` with a different scope, it would\n",
        "reduce the time for the test suite to complete by approximately two thirds.\n",
        "This is the sort of benefit that can be gained from considerate use of `pytest`\n",
        "fixtures.\n",
        "\n",
        "```{.python filename=test_expensive.py}\n",
        "@pytest.fixture(scope=\"module\")\n",
        "def doodah_fixture():\n",
        "    \"\"\"Module-scoped ExpensiveDoodah.\"\"\"\n",
        "    return ExpensiveDoodah(2)\n",
        "\n",
        "```\n",
        "\n",
        "```\n",
        "collected 3 items\n",
        "\n",
        "./tests/test_expensive_function_scoped.py ...    [100%]\n",
        "\n",
        "============================ 3 passed in 2.02s ================================\n",
        "\n",
        "```\n",
        "\n",
        "The scoping feature of `pytest` fixtures can be used to optimise a test-suite\n",
        "and avoid lengthy delays while waiting for your test suites to execute.\n",
        "However, any changes to the fixture contents will persist until the fixture is\n",
        "next torn down. Keeping track of the states of differently-scoped fixtures in a\n",
        "complex test suite can be tricky and reduces segmentation overall. Bear this in\n",
        "mind when considering which scope best suits your needs.\n",
        "\n",
        "### Scope persistence\n",
        "***\n",
        "\n",
        "> function < class < module < package < session\n",
        "\n",
        "Using scopes other than 'function' can be useful for end-to-end testing.\n",
        "Perhaps you have a complex analytical pipeline and need to check that the\n",
        "various components work well **together**, rather than in isolation as with a\n",
        "unit test. This sort of test can be extremely useful for developers in a rush.\n",
        "You can test that the so called 'promise' of the codebase is as expected, even\n",
        "though the implementation may change.\n",
        "\n",
        "The analogy here would be that the success criteria of a SatNav is that it gets\n",
        "you to your desired destination whatever the suggested route you selected.\n",
        "Checking that you used the fastest or most fuel efficient option is probably a\n",
        "good idea. But if you don't have time, you'll just have to take the hit if you\n",
        "encounter a toll road. Though it's still worth checking that the postcode you\n",
        "hastily input to the satnav is the correct one.\n",
        "\n",
        "<iframe src=\"https://www.google.com/maps/embed?pb=!1m26!1m12!1m3!1d19867.3453412218!2d-0.12357612910538017!3d51.50554381133014!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!4m11!3e0!4m3!3m2!1d51.5020874!2d-0.0776174!4m5!1s0x48760520cd5b5eb5%3A0xa26abf514d902a7!2sBuckingham%20Palace%2C%20London!3m2!1d51.501363999999995!2d-0.14189!5e0!3m2!1sen!2suk!4v1711782045831!5m2!1sen!2suk\" allowfullscreen=\"\" loading=\"lazy\" referrerpolicy=\"no-referrer-when-downgrade\" class=\"shaded_box\" title=\"Google Maps displaying multiple routes to Buckingham Palace. (c) Google.\" style=\"display: block; width: 600px; height: 338px\">\n",
        "</iframe>\n",
        "<br>\n",
        "Perhaps your success criteria is that you need to write a DataFrame to file. \n",
        "A great end-to-end test would check that the DataFrame produced has the\n",
        "expected number of rows, or even has rows! Of course it's also a good idea to\n",
        "check the DataFrame conforms to the expected table schema, too: number of\n",
        "columns, names of columns, order and data types. This sort of check is often\n",
        "overlooked in favour of pressing on with development. If you've ever\n",
        "encountered a situation where you've updated a codebase and later realised you\n",
        "now have empty tables (I certainly have), this sort of test would be really\n",
        "handy, immediately alerting you to this fact and helping you efficiently locate\n",
        "the source of the bug.\n",
        "\n",
        "#### Define Data\n",
        "\n",
        "In this part, I will explore the scoping of fixtures with DataFrames. Again,\n",
        "I'll use a toy example to demonstrate scope behaviour. Being a child of the\n",
        "'90s (mostly), I'll use a scenario from my childhood. Scooby Doo is still a\n",
        "thing, right?\n",
        "\n",
        "**Enter: The Mystery Machine**\n",
        "\n",
        "<img src=/./www/11-fiddly-bits-of-pytest/mm.avif alt=\"Scooby Doo & the gang in the Mystery Machine\" class=center>\n",
        "</img>\n",
        "\n",
        "The scenario: The passengers of the Mystery Machine van all have the munchies.\n",
        "They stop at a 'drive thru' to get some takeaway. We have a table with a record\n",
        "for each character. We have columns with data about the characters' names,\n",
        "their favourite food, whether they have 'the munchies', and the contents of\n",
        "their stomach."
      ],
      "id": "594728e2"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import pandas as pd\n",
        "mystery_machine = pd.DataFrame(\n",
        "        {\n",
        "            \"name\": [\"Daphne\", \"Fred\", \"Scooby Doo\", \"Shaggy\", \"Velma\"],\n",
        "            \"fave_food\": [\n",
        "                \"carrots\",\n",
        "                \"beans\",\n",
        "                \"scooby snacks\",\n",
        "                \"burgers\",\n",
        "                \"hot dogs\",\n",
        "            ],\n",
        "            \"has_munchies\": [True] * 5, # everyone's hungry\n",
        "            \"stomach_contents\": [\"empty\"] * 5, # all have empty stomachs\n",
        "        }\n",
        "    )\n",
        "mystery_machine"
      ],
      "id": "4675e27b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "To use this simple DataFrame as a fixture, I could go ahead and define it with\n",
        "`@pytest.fixture()` directly within a test file. But if I would like to share\n",
        "it across several test modules\n",
        "([as implemented later](#fixtures-across-multiple-test-modules)), then there\n",
        "are 2 options:\n",
        "\n",
        "1. Write the DataFrame to disk as csv (or whatever format you prefer) and save\n",
        "in a `./tests/data/` folder. At the start of your test modules you can read the\n",
        "data from disk and use it for testing. In this approach you'll likely define\n",
        "the data as a test fixture in each of the test modules that need to work with\n",
        "it.\n",
        "2. Define the fixtures within a special python file called `conftest.py`, which\n",
        "must be located at the root of your project. This file is used to configure\n",
        "your tests. `pytest` will look in this file for any required fixture\n",
        "definitions when executing your test suite. If it finds a fixture with the same\n",
        "name as that required by a test, the fixture code may be run. \n",
        "\n",
        ":::{.callout-caution}\n",
        "Wait! Did you just say '**may** be run'?\n",
        ":::\n",
        "\n",
        "Depending on the scope of your fixture, `pytest` may not need to execute the\n",
        "code for each test. For example, let's say we're working with a session-scoped\n",
        "fixture. This type of fixture will persist for the duration of the entire test\n",
        "suite execution. Imagine test number 1 and 10 both require this test fixture.\n",
        "The fixture definition only gets executed the first time a test requires it.\n",
        "This test fixture will be set up as test 1 executes and will persist until\n",
        "tear down occurs at the end of the `pytest` session. Test 10 will therefore use\n",
        "the same instance of this fixture as test 1 used, meaning any changes to the\n",
        "fixture may be carried forward.\n",
        "\n",
        "#### Define fixtures\n",
        "\n",
        "For our example, we will create a `conftest.py` file and define some fixtures\n",
        "with differing scopes.\n",
        "\n",
        "```{.python filename=conftest.py}\n",
        "\"\"\"Demonstrate scoping fixtures.\"\"\"\n",
        "import pandas as pd\n",
        "import pytest\n",
        "\n",
        "\n",
        "@pytest.fixture(scope=\"session\")\n",
        "def _mystery_machine():\n",
        "    \"\"\"Session-scoped fixture returning pandas DataFrame.\"\"\"\n",
        "    return pd.DataFrame(\n",
        "        {\n",
        "            \"name\": [\"Daphne\", \"Fred\", \"Scooby Doo\", \"Shaggy\", \"Velma\"],\n",
        "            \"fave_food\": [\n",
        "                \"carrots\",\n",
        "                \"beans\",\n",
        "                \"scooby snacks\",\n",
        "                \"burgers\",\n",
        "                \"hot dogs\",\n",
        "            ],\n",
        "            \"has_munchies\": [True] * 5,\n",
        "            \"stomach_contents\": [\"empty\"] * 5,\n",
        "        }\n",
        "    )\n",
        "\n",
        "\n",
        "@pytest.fixture(scope=\"session\")\n",
        "def _mm_session_scoped(_mystery_machine):\n",
        "    \"\"\"Session-scoped fixture returning the _mystery_machine DataFrame.\"\"\"\n",
        "    return _mystery_machine.copy(deep=True)\n",
        "\n",
        "\n",
        "@pytest.fixture(scope=\"module\")\n",
        "def _mm_module_scoped(_mystery_machine):\n",
        "    \"\"\"Module-scoped _mystery_machine DataFrame.\"\"\"\n",
        "    return _mystery_machine.copy(deep=True)\n",
        "\n",
        "\n",
        "@pytest.fixture(scope=\"class\")\n",
        "def _mm_class_scoped(_mystery_machine):\n",
        "    \"\"\"Class-scoped _mystery_machine DataFrame.\"\"\"\n",
        "    return _mystery_machine.copy(deep=True)\n",
        "\n",
        "\n",
        "@pytest.fixture(scope=\"function\")\n",
        "def _mm_function_scoped(_mystery_machine):\n",
        "    \"\"\"Function-scoped _mystery_machine DataFrame.\"\"\"\n",
        "    return _mystery_machine.copy(deep=True)\n",
        "\n",
        "```\n",
        "\n",
        "Fixtures can reference each other, if they're scoped correctly. More on this in\n",
        "[the next section](#scopemismatch-error). This is useful for my toy example as\n",
        "I intend the source functions to update the DataFrames directly, if I wasn't\n",
        "careful about deep copying the fixtures, my functions would update the original\n",
        "`_mystery_machine` fixture's table. Those changes would then be subsequently\n",
        "passed to the other fixtures, meaning I couldn't clearly demonstrate how the\n",
        "different scopes persist.\n",
        "\n",
        "#### Define the source functions\n",
        "\n",
        "Now, let's create a function that will feed characters their favourite food if\n",
        "they have the munchies. \n",
        "\n",
        "```{.python filename=feed_characters.py}\n",
        "\"\"\"Helping learners understand how to work with pytest fixtures.\"\"\"\n",
        "import pandas as pd\n",
        "\n",
        "\n",
        "def serve_food(df: pd.DataFrame) -> pd.DataFrame:\n",
        "    \"\"\"Serve characters their desired food.\n",
        "\n",
        "    Iterates over a df, feeding characters if they have 'the munchies' with\n",
        "    their fave_food. If the character is not Scooby Doo or Shaggy, then update\n",
        "    their has_munchies status to False. The input df is modified inplace.\n",
        "\n",
        "    Parameters\n",
        "    ----------\n",
        "    df : pd.DataFrame\n",
        "        A DataFrame with the following columns: \"name\": str, \"fave_food\": str,\n",
        "        \"has_munchies\": bool, \"stomach_contents\": str.\n",
        "\n",
        "    Returns\n",
        "    -------\n",
        "    pd.DataFrame\n",
        "        Updated DataFrame with new statuses for stomach_contents and\n",
        "        has_munchies.\n",
        "\n",
        "    \"\"\"\n",
        "    for ind, row in df.iterrows():\n",
        "        if row[\"has_munchies\"]:\n",
        "            # if character is hungry then feed them\n",
        "            food = row[\"fave_food\"]\n",
        "            character = row[\"name\"]\n",
        "            print(f\"Feeding {food} to {character}.\")\n",
        "            df.loc[ind, [\"stomach_contents\"]] = food\n",
        "            if character not in [\"Scooby Doo\", \"Shaggy\"]:\n",
        "                # Scooby & Shaggy are always hungry\n",
        "                df.loc[ind, \"has_munchies\"] = False\n",
        "        else:\n",
        "            # if not hungry then do not adjust\n",
        "            pass\n",
        "    return df\n",
        "\n",
        "```\n",
        "\n",
        "Note that it is commonplace to copy a pandas DataFrame so that any operations\n",
        "carried out by the function are confined to the function's scope. To\n",
        "demonstrate changes to the fixtures I will instead choose to edit the DataFrame\n",
        "inplace.\n",
        "\n",
        "#### Fixtures Within a Single Test Module\n",
        "\n",
        "Now to write some tests. To use the fixtures we defined earlier, we simply \n",
        "declare that a test function requires the fixture. `pytest` will notice this \n",
        "dependency on collection, check the fixture scope and execute the fixture code \n",
        "if appropriate. The following test `test_scopes_before_action` checks that the\n",
        "`mystery_machine` fixtures all have the expected `has_munchies` column values\n",
        "at the outset of the test module, i.e. everybody is hungry before our source\n",
        "function takes some action. This type of test doesn't check behaviour of any\n",
        "source code and therefore would be unnecessary for quality assurance purposes.\n",
        "But I include it here to demonstrate the simple use of fixtures and prove to\n",
        "the reader the state of the DataFrame fixtures prior to any source code\n",
        "intervention.\n",
        "\n",
        ":::{.callout-tip collapse=\"true\"}\n",
        "\n",
        "##### **Testing `pandas` DataFrames**\n",
        "\n",
        "You may notice that the assert statements in the tests below requires pulling \n",
        "column values out and casting to lists. The `pandas` package has its own\n",
        "testing module that is super useful for testing all aspects of DataFrames.\n",
        "Check out the\n",
        "[`pandas` testing documentation](https://pandas.pydata.org/docs/reference/testing.html)\n",
        "for more on how to write robust tests for pandas DataFrames and Series.\n",
        "\n",
        ":::\n",
        "\n",
        "```{.python filename=\"test_feed_characters.py\"}\n",
        "\"\"\"Testing pandas operations with test fixtures.\"\"\"\n",
        "from example_pkg.feed_characters import serve_food\n",
        "\n",
        "\n",
        "def test_scopes_before_action(\n",
        "    _mm_session_scoped,\n",
        "    _mm_module_scoped,\n",
        "    _mm_class_scoped,\n",
        "    _mm_function_scoped,\n",
        "):\n",
        "    \"\"\"Assert that all characters have the munchies at the outset.\"\"\"\n",
        "    assert list(_mm_session_scoped[\"has_munchies\"].values) == [True] * 5, (\n",
        "        \"The session-scoped DataFrame 'has_munchies' column was not as \",\n",
        "        \"expected before any action was taken.\",\n",
        "    )\n",
        "    assert list(_mm_module_scoped[\"has_munchies\"].values) == [True] * 5, (\n",
        "        \"The module-scoped DataFrame 'has_munchies' column was not as \",\n",
        "        \"expected before any action was taken.\",\n",
        "    )\n",
        "    assert list(_mm_class_scoped[\"has_munchies\"].values) == [True] * 5, (\n",
        "        \"The class-scoped DataFrame 'has_munchies' column was not as \",\n",
        "        \"expected before any action was taken.\",\n",
        "    )\n",
        "    assert list(_mm_function_scoped[\"has_munchies\"].values) == [True] * 5, (\n",
        "        \"The function-scoped DataFrame 'has_munchies' column was not as \",\n",
        "        \"expected before any action was taken.\",\n",
        "    )\n",
        "\n",
        "```\n",
        "\n",
        "Now to test the `serve_food()` function operates as expected. We can define\n",
        "a test class that will house all tests for `serve_food()`. Within that class\n",
        "let's define our first test that simply checks that the value of the\n",
        "`has_munchies` column has been updated as we would expect after using the\n",
        "`serve_food()` function.\n",
        "\n",
        "```{.python filename=\"test_feed_characters.py\"}\n",
        "class TestServeFood:\n",
        "    \"\"\"Tests that serve_food() updates the 'has_munchies' column.\"\"\"\n",
        "\n",
        "    def test_serve_food_updates_df(\n",
        "        self,\n",
        "        _mm_session_scoped,\n",
        "        _mm_module_scoped,\n",
        "        _mm_class_scoped,\n",
        "        _mm_function_scoped,\n",
        "    ):\n",
        "        \"\"\"Test serve_food updates the has_munchies columns as expected.\n",
        "\n",
        "        This function will update each fixture in the same way, providing each\n",
        "        character with their favourite_food and updating the contents of their\n",
        "        stomach. The column we will assert against will be has_munchies, which\n",
        "        should be updated to False after feeding in all cases except for Scooby\n",
        "        Doo and Shaggy, who always have the munchies.\n",
        "        \"\"\"\n",
        "        # first lets check that the session-scoped dataframe gets updates\n",
        "        assert list(serve_food(_mm_session_scoped)[\"has_munchies\"].values) == [\n",
        "            False,\n",
        "            False,\n",
        "            True,\n",
        "            True,\n",
        "            False,\n",
        "        ], (\n",
        "            \"The `serve_food()` has not updated the session-scoped df\",\n",
        "            \" 'has_munchies' column as expected.\",\n",
        "        )\n",
        "        # next check the same for the module-scoped fixture\n",
        "        assert list(serve_food(_mm_module_scoped)[\"has_munchies\"].values) == [\n",
        "            False,\n",
        "            False,\n",
        "            True,\n",
        "            True,\n",
        "            False,\n",
        "        ], (\n",
        "            \"The `serve_food()` has not updated the module-scoped df\",\n",
        "            \" 'has_munchies' column as expected.\",\n",
        "        )\n",
        "        # Next check class-scoped fixture updates\n",
        "        assert list(serve_food(_mm_class_scoped)[\"has_munchies\"].values) == [\n",
        "            False,\n",
        "            False,\n",
        "            True,\n",
        "            True,\n",
        "            False,\n",
        "        ], (\n",
        "            \"The `serve_food()` has not updated the class-scoped df\",\n",
        "            \" 'has_munchies' column as expected.\",\n",
        "        )\n",
        "        # Finally check the function-scoped df does the same...\n",
        "        assert list(\n",
        "            serve_food(_mm_function_scoped)[\"has_munchies\"].values\n",
        "        ) == [\n",
        "            False,\n",
        "            False,\n",
        "            True,\n",
        "            True,\n",
        "            False,\n",
        "        ], (\n",
        "            \"The `serve_food()` has not updated the function-scoped df\",\n",
        "            \" 'has_munchies' column as expected.\",\n",
        "        )\n",
        "\n",
        "```\n",
        "\n",
        "Notice that the test makes exactly the same assertion for every differently\n",
        "scoped fixture? In every instance, we have fed the characters in the mystery\n",
        "machine DataFrame and therefore everyone's `has_munchies` status (apart from\n",
        "Scooby Doo and Shaggy's) gets updated to `False`.\n",
        "\n",
        ":::{.callout-tip collapse=\"true\"}\n",
        "\n",
        "##### **Parametrized Tests**\n",
        "\n",
        "Writing the test out this way makes things explicit and easy to follow.\n",
        "However, you could make this test smaller by using a neat feature of the\n",
        "`pytest` package called **parametrized** tests. This is basically like applying\n",
        "conditions to your tests in a `for` loop. Perhaps you have a bunch of\n",
        "conditions to check, multiple DataFrames or whatever. These can be\n",
        "programmatically served with\n",
        "[parametrized tests](https://docs.pytest.org/en/7.1.x/how-to/parametrize.html).\n",
        "While outside of the scope of this article, I intend to write a blog on this in\n",
        "the future.\n",
        ":::\n",
        "\n",
        "Next, we can add to the test class, including a new test that checks the state\n",
        "of the fixtures. At this point, we will start to see some differences due to\n",
        "scoping. The new `test_expected_states_within_same_class()` will assert that\n",
        "the changes to the fixtures brought about in the previous test\n",
        "`test_serve_food_updates_df()` will persist, except for the the case of\n",
        "`_mm_function_scoped` which will go through teardown at the end of every test\n",
        "function.\n",
        "\n",
        "```{.python filename=\"test_feed_characters.py\"}\n",
        "class TestServeFood:\n",
        "    \"\"\"Tests that serve_food() updates the 'has_munchies' column.\"\"\"\n",
        "    # ... (test_serve_food_updates_df)\n",
        "\n",
        "    def test_expected_states_within_same_class(\n",
        "        self,\n",
        "        _mm_session_scoped,\n",
        "        _mm_module_scoped,\n",
        "        _mm_class_scoped,\n",
        "        _mm_function_scoped,\n",
        "    ):\n",
        "        \"\"\"Test to ensure fixture states are as expected.\"\"\"\n",
        "        # Firstly, session-scoped changes should persist, only Scooby Doo &\n",
        "        # Shaggy should still have the munchies...\n",
        "        assert list(_mm_session_scoped[\"has_munchies\"].values) == [\n",
        "            False,\n",
        "            False,\n",
        "            True,\n",
        "            True,\n",
        "            False,\n",
        "        ], (\n",
        "            \"The changes to the session-scoped df 'has_munchies' column have\",\n",
        "            \" not persisted as expected.\",\n",
        "        )\n",
        "        # Secondly, module-scoped changes should persist, as was the case for\n",
        "        # the session-scope test above\n",
        "        assert list(_mm_module_scoped[\"has_munchies\"].values) == [\n",
        "            False,\n",
        "            False,\n",
        "            True,\n",
        "            True,\n",
        "            False,\n",
        "        ], (\n",
        "            \"The changes to the module-scoped df 'has_munchies' column have\",\n",
        "            \" not persisted as expected.\",\n",
        "        )\n",
        "        # Next, class-scoped changes should persist just the same\n",
        "        assert list(_mm_class_scoped[\"has_munchies\"].values) == [\n",
        "            False,\n",
        "            False,\n",
        "            True,\n",
        "            True,\n",
        "            False,\n",
        "        ], (\n",
        "            \"The changes to the class-scoped df 'has_munchies' column have\",\n",
        "            \" not persisted as expected.\",\n",
        "        )\n",
        "        # Finally, demonstrate that function-scoped fixture starts from scratch\n",
        "        # Therefore all characters should have the munchies all over again.\n",
        "        assert (\n",
        "            list(_mm_function_scoped[\"has_munchies\"].values) == [True] * 5\n",
        "        ), (\n",
        "            \"The function_scoped df 'has_munchies' column is not as expected.\",\n",
        "        )\n",
        "\n",
        "```\n",
        "\n",
        "In the above test, we assert that the function-scoped fixture values have\n",
        "the original fixture's values. The function-scoped fixture goes through set-up\n",
        "again as `test_expected_states_within_same_class` is executed, ensuring a\n",
        "'fresh', unchanged version of the fixture DataFrame is provided. \n",
        "\n",
        "Within the same test module, we can add some other test class and make\n",
        "assertions about the fixtures. This new test will check whether the\n",
        "`stomach_contents` column of the module and class-scoped fixtures have been\n",
        "updated. Recall that the characters start out with `\"empty\"` stomach contents.\n",
        "\n",
        "```{.python filename=\"test_feed_characters.py\"}\n",
        "\n",
        "# ... (TestServeFood)\n",
        "    # (test_serve_food_updates_df)\n",
        "    # (test_expected_states_within_same_class) ...\n",
        "\n",
        "class TestSomeOtherTestClass:\n",
        "    \"\"\"Demonstrate persistence of changes to class-scoped fixture.\"\"\"\n",
        "\n",
        "    def test_whether_changes_to_stomach_contents_persist(\n",
        "        self, _mm_class_scoped, _mm_module_scoped\n",
        "    ):\n",
        "        \"\"\"Check the stomach_contents column.\"\"\"\n",
        "        assert list(_mm_module_scoped[\"stomach_contents\"].values) == [\n",
        "            \"carrots\",\n",
        "            \"beans\",\n",
        "            \"scooby snacks\",\n",
        "            \"burgers\",\n",
        "            \"hot dogs\",\n",
        "        ], \"Changes to module-scoped fixture have not propagated as expected.\"\n",
        "        assert (\n",
        "            list(_mm_class_scoped[\"stomach_contents\"].values) == [\"empty\"] * 5\n",
        "        ), \"Values in class-scoped fixture are not as expected\"\n",
        "```\n",
        "\n",
        "In this example, it is demonstrated that changes to the class-scoped fixture \n",
        "have been discarded. As `test_whether_changes_to_stomach_contents_persist()`\n",
        "exists within a new class called `TestSomeOtherTestClass`, the code for\n",
        "`_mm_class_scoped` has been executed again, providing the original DataFrame\n",
        "values.\n",
        "\n",
        "##### **Balancing Isolation & Persistence**\n",
        "***\n",
        "\n",
        "While the persistence of fixtures may be useful for end to end tests, this\n",
        "approach reduces isolation in the test suite. Be aware that this may introduce\n",
        "a bit of friction to your `pytest` development process. For example, it can be\n",
        "commonplace to develop a new test and to check that it passes by invoking\n",
        "`pytest` with the keyword `-k` flag to run that single test\n",
        "(or subset of tests) only. This approach is useful if you have a costly test\n",
        "suite and you just want to examine changes in a single unit.\n",
        "\n",
        "At the current state of the test module, executing the entire test module by\n",
        "running `pytest ./tests/test_feed_characters.py` will pass. However, running\n",
        "`pytest -k \"TestSomeOtherTestClass\"` will fail. This is because the assertions\n",
        "in `TestSomeOtherTestClass` rely on code being executed within the preceding\n",
        "test class. Tests in `TestSomeOtherTestClass` rely on changes elsewhere in your\n",
        "test suite and by definition are no longer unit tests. For those developers who\n",
        "work with [pytest-randomly](https://pypi.org/project/pytest-randomly/) to help\n",
        "sniff out poorly-isolated tests, this approach could cause a bit of a headache.\n",
        "\n",
        "A good compromise would be to ensure that the use of fixture scopes other than\n",
        "`function` are isolated and clearly documented within a test suite. Thoughtful\n",
        "grouping of integration tests within test modules or classes can limit grief \n",
        "for collaborating developers. Even better would be to\n",
        "[mark tests](https://docs.pytest.org/en/latest/how-to/mark.html) according to\n",
        "their scoped dependencies. This approach allows tests to be grouped and\n",
        "executed separately, though the implementation of this is beyond the scope of\n",
        "this article. \n",
        "\n",
        "#### Fixtures Across Multiple Test Modules\n",
        "\n",
        "Finally in this section, we will explore fixture behaviour across more than one\n",
        "test module. Below I define a new source module with a function used to update\n",
        "the `mystery_machine` DataFrame. This function will update the `fave_food`\n",
        "column for a character if it has already eaten. This is meant to represent a\n",
        "character's preference for a dessert following a main course. Once more, this\n",
        "function will not deep copy the input DataFrame but will allow inplace\n",
        "adjustment.\n",
        "\n",
        "<img class=\"center shaded_box\" alt=\"Delicious ice cream\" title=\"Delicious ice cream by Prompart https://pixexid.com/profile/@prompart\" src=\"/./www/11-fiddly-bits-of-pytest/sunday.jpg\">\n",
        "\n",
        "```{.python filename=\"update_food.py\"}\n",
        "\"\"\"Helping learners understand how to work with pytest fixtures.\"\"\"\n",
        "import pandas as pd\n",
        "\n",
        "\n",
        "def fancy_dessert(\n",
        "    df: pd.DataFrame,\n",
        "    fave_desserts: dict = {\n",
        "        \"Daphne\": \"brownie\",\n",
        "        \"Fred\": \"ice cream\",\n",
        "        \"Scooby Doo\": \"apple crumble\",\n",
        "        \"Shaggy\": \"pudding\",\n",
        "        \"Velma\": \"banana bread\",\n",
        "    },\n",
        ") -> pd.DataFrame:\n",
        "    \"\"\"Update a characters favourite_food to a dessert if they have eaten.\n",
        "\n",
        "    Iterates over a df, updating the fave_food value for a character if the\n",
        "    stomach_contents are not 'empty'.\n",
        "\n",
        "    Parameters\n",
        "    ----------\n",
        "    df : pd.DataFrame\n",
        "        A dataframe with the following columns: \"name\": str, \"fave_food\": str,\n",
        "        \"has_munchies\": bool, \"stomach_contents\": str.\n",
        "    fave_desserts : dict, optional\n",
        "        A mapping of \"name\" to a replacement favourite_food, by default\n",
        "        { \"Daphne\": \"brownie\", \"Fred\": \"ice cream\",\n",
        "        \"Scooby Doo\": \"apple crumble\", \"Shaggy\": \"pudding\",\n",
        "        \"Velma\": \"banana bread\", }\n",
        "\n",
        "    Returns\n",
        "    -------\n",
        "    pd.DataFrame\n",
        "        Dataframe with updated fave_food values.\n",
        "\n",
        "    \"\"\"\n",
        "    for ind, row in df.iterrows():\n",
        "        if row[\"stomach_contents\"] != \"empty\":\n",
        "            # character has eaten, now they should prefer a dessert\n",
        "            character = row[\"name\"]\n",
        "            dessert = fave_desserts[character]\n",
        "            print(f\"{character} now wants {dessert}.\")\n",
        "            df.loc[ind, \"fave_food\"] = dessert\n",
        "        else:\n",
        "            # if not eaten, do not adjust\n",
        "            pass\n",
        "    return df\n",
        "\n",
        "```\n",
        "Note that the condition required for `fancy_dessert()` to take action is that\n",
        "the contents of the character's `stomach_contents` should be not equal to\n",
        "\"empty\". Now to test this new src module, we create a new test module. We will\n",
        "run assertions of the `fave_food` columns against the differently-scoped\n",
        "fixtures. \n",
        "\n",
        "```{.python filename=\"test_update_food.py\"}\n",
        "\"\"\"Testing pandas operations with test fixtures.\"\"\"\n",
        "from example_pkg.update_food import fancy_dessert\n",
        "\n",
        "\n",
        "class TestFancyDessert:\n",
        "    \"\"\"Tests for fancy_dessert().\"\"\"\n",
        "\n",
        "    def test_fancy_dessert_updates_fixtures_as_expected(\n",
        "        self,\n",
        "        _mm_session_scoped,\n",
        "        _mm_module_scoped,\n",
        "        _mm_class_scoped,\n",
        "        _mm_function_scoped,\n",
        "    ):\n",
        "        \"\"\"Test fancy_dessert() changes favourite_food values to dessert.\n",
        "\n",
        "        These assertions depend on the current state of the scoped fixtures. If\n",
        "        changes performed in\n",
        "        test_feed_characters::TestServeFood::test_serve_food_updates_df()\n",
        "        persist, then characters will not have empty stomach_contents,\n",
        "        resulting in a switch of their favourite_food to dessert.\n",
        "        \"\"\"\n",
        "        # first, check update_food() with the session-scoped fixture.\n",
        "        assert list(fancy_dessert(_mm_session_scoped)[\"fave_food\"].values) == [\n",
        "            \"brownie\",\n",
        "            \"ice cream\",\n",
        "            \"apple crumble\",\n",
        "            \"pudding\",\n",
        "            \"banana bread\",\n",
        "        ], (\n",
        "            \"The changes to the session-scoped df 'stomach_contents' column\",\n",
        "            \" have not persisted as expected.\",\n",
        "        )\n",
        "        # next, check update_food() with the module-scoped fixture.\n",
        "        assert list(fancy_dessert(_mm_module_scoped)[\"fave_food\"].values) == [\n",
        "            \"carrots\",\n",
        "            \"beans\",\n",
        "            \"scooby snacks\",\n",
        "            \"burgers\",\n",
        "            \"hot dogs\",\n",
        "        ], (\n",
        "            \"The module-scoped df 'stomach_contents' column was not as\",\n",
        "            \" expected\",\n",
        "        )\n",
        "        # now, check update_food() with the class-scoped fixture. Note that we\n",
        "        # are now making assertions about changes from a different class.\n",
        "        assert list(fancy_dessert(_mm_class_scoped)[\"fave_food\"].values) == [\n",
        "            \"carrots\",\n",
        "            \"beans\",\n",
        "            \"scooby snacks\",\n",
        "            \"burgers\",\n",
        "            \"hot dogs\",\n",
        "        ], (\n",
        "            \"The class-scoped df 'stomach_contents' column was not as\",\n",
        "            \" expected\",\n",
        "        )\n",
        "        # Finally, check update_food() with the function-scoped fixture. As\n",
        "        # in TestServeFood::test_expected_states_within_same_class(), the\n",
        "        # function-scoped fixture starts from scratch.\n",
        "        assert list(\n",
        "            fancy_dessert(_mm_function_scoped)[\"fave_food\"].values\n",
        "        ) == [\"carrots\", \"beans\", \"scooby snacks\", \"burgers\", \"hot dogs\"], (\n",
        "            \"The function-scoped df 'stomach_contents' column was not as\",\n",
        "            \" expected\",\n",
        "        )\n",
        "\n",
        "```\n",
        "Note that the only fixture expected to have been adjusted by `update_food()` is\n",
        "`_mm_session_scoped`. When running the `pytest` command, changes from executing\n",
        "the first test module `test_feed_characters.py` propagate for this fixture\n",
        "only. All other fixture scopes used  will go through teardown and then setup\n",
        "once more on execution of the second test module.\n",
        "\n",
        "This arrangement is highly dependent on the order of which the test modules are\n",
        "collected. `pytest` collects tests in alphabetical ordering by default, and as\n",
        "such `test_update_food.py` can be expected to be executed after\n",
        "`test_feed_characters.py`. This test module is highly dependent upon the order\n",
        "of the `pytest` execution. This makes the tests less portable and means that\n",
        "running the test module  with `pytest tests/test_update_food.py` in isolation\n",
        "would fail. I would once more suggest using\n",
        "[`pytest` marks](https://docs.pytest.org/en/latest/how-to/mark.html) to group\n",
        "these types of tests and execute them separately to the rest of the test suite.\n",
        "\n",
        "## `ScopeMismatch` Error\n",
        "\n",
        "When working with `pytest` fixtures, occasionally you will encounter a\n",
        "`ScopeMismatch` exception. This may happen when attempting to use certain\n",
        "`pytest` plug-ins or perhaps if trying to use temporary directory fixtures like\n",
        "`tmp_path` with fixtures that are scoped differently to function-scope.\n",
        "Occasionally, you may encounter this exception when attempting to reference\n",
        "your own fixture in other fixtures, as was done with the\n",
        "[`mystery_machine` fixture above](#define-fixtures). \n",
        "\n",
        "The reason for `ScopeMismatch` is straightforward. Fixture scopes have a\n",
        "hierarchy, based on their persistence:\n",
        "\n",
        "> function < class < module < package < session\n",
        "\n",
        "Fixtures with a greater scope in the hierarchy are not permitted to reference\n",
        "those lower in the hierarchy. The way I remember this rule is that:\n",
        "\n",
        "> Fixtures must only reference equal or greater scopes.\n",
        "\n",
        "It is unclear why this rule has been implemented other than to reduce\n",
        "complexity (which is reason enough in my book). There was talk about\n",
        "implementing `scope=\"any\"` some time ago, but it looks like this idea was\n",
        "abandoned. To reproduce the error:\n",
        "\n",
        "```{.python filename=\"test_bad_scoping.py\"}\n",
        "\"\"\"Demomstrate ScopeMismatch error.\"\"\"\n",
        "\n",
        "import pytest\n",
        "\n",
        "@pytest.fixture(scope=\"function\")\n",
        "def _fix_a():\n",
        "    return 1\n",
        "\n",
        "@pytest.fixture(scope=\"class\")\n",
        "def _fix_b(_fix_a):\n",
        "    return _fix_a + _fix_a\n",
        "\n",
        "\n",
        "def test__fix_b_return_val(_fix_b):\n",
        "    assert _fix_b == 2\n",
        "\n",
        "```\n",
        "Executing this test module results in:\n",
        "```\n",
        "================================= ERRORS ======================================\n",
        "________________ ERROR at setup of test__fix_b_return_val _____________________\n",
        "ScopeMismatch: You tried to access the function scoped fixture _fix_a with a\n",
        "class scoped request object, involved factories:\n",
        "tests/test_bad_scoping.py:9:  def _fix_b(_fix_a)\n",
        "tests/test_bad_scoping.py:5:  def _fix_a()\n",
        "========================== short test summary info ============================\n",
        "ERROR tests/test_bad_scoping.py::test__fix_b_return_val - Failed:\n",
        "ScopeMismatch: You tried to access the function scoped fixture _fix_a with a\n",
        "class scoped request object, involved factories:\n",
        "=========================== 1 error in 0.01s ==================================\n",
        "```\n",
        "\n",
        "This error can be avoided by adjusting the fixture scopes to adhere to the\n",
        "hierarchy rule, so updating `_fix_a` to use a class scope or greater would\n",
        "result in a passing test.\n",
        "\n",
        "## Summary\n",
        "\n",
        "Hopefully by now you feel comfortable in when and how to use fixtures for\n",
        "`pytest`. We've covered quite a bit, including:\n",
        "\n",
        "* What fixtures are\n",
        "* Use-cases\n",
        "* Where to store them\n",
        "* How to reference them\n",
        "* How to scope them\n",
        "* How changes to fixtures persist or not\n",
        "* Handling scope errors \n",
        "\n",
        "If you spot an error with this article, or have  suggested improvement then\n",
        "feel free to\n",
        "[raise an issue on GitHub](https://github.com/r-leyshon/blogging/issues).  \n",
        "\n",
        "Happy testing!\n",
        "\n",
        "## Acknowledgements\n",
        "\n",
        "To past and present colleagues who have helped to discuss pros and cons,\n",
        "establishing practice and firming-up some opinions. Particularly:\n",
        "\n",
        "* Clara\n",
        "* Dan C\n",
        "* Dan S\n",
        "* Edward\n",
        "* Ethan\n",
        "* Henry\n",
        "* Ian\n",
        "* Iva\n",
        "* Jay\n",
        "* Mark\n",
        "* Martin R\n",
        "* Martin W\n",
        "* Mat\n",
        "* Sergio\n",
        "\n",
        "<p id=fin><i>fin!</i></p>"
      ],
      "id": "0231cb57"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "pytest-env",
      "language": "python",
      "display_name": "pytest-env"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}