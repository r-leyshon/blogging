---
title: "Cycling Network Routing with r<sup>5</sup>py"
author: "Rich Leyshon"
date: "February 03 2024"
description: "Using r<sup>5</sup>py to analyse service coverage in the London's Boris Bike network."
categories:         # delete categories as appropriate. using https://diataxis.fr/ documentation definitions.
    - Tutorial
    - Transport Modelling
    - REST API
    - Web data
    - Geospatial
image: "https://images.pixexid.com/a-dynamic-image-of-a-cyclist-her-face-focused-and-determined-captured-mid-peda-cpglmien.jpeg?h=699&amp;q=70"
image-alt: "A dynamic image of a cyclist, her face focused and determined, captured mid-pedal against the backdrop of a bustling city by [Ralph](https://pixexid.com/profile/cjxrsxsl7000008s6h21jecoe)"
toc: true
jupyter: 
  kernelspec:
    name: "conda-env-cycling-env-py"
    language: "python"
    display_name: "blog-cycling-env"
---

<figure class=center>
  <img class="shaded_box" width="400px" src="https://images.pixexid.com/a-dynamic-image-of-a-cyclist-her-face-focused-and-determined-captured-mid-peda-cpglmien.jpeg?h=699&amp;q=70"></img>
  <figcaption style="text-align:center;">Creative commons license, created by [Ralph](https://pixexid.com/profile/cjxrsxsl7000008s6h21jecoe)</figcaption>
</figure>

## Introduction

[r<sup>5</sup>py is a relatively new transport modelling package](https://r5py.readthedocs.io/en/stable/)
available on PyPI. It provides convenient wrappers to
[Conveyal's r<sup>5</sup> Java library](https://github.com/conveyal/r5), a
performant routing engine originating from the ubiquitous Open Trip Planner
(OTP). Whereas r<sup>5</sup>py may not be as feature-rich as OTP, its unique
strength is in the production of origin:destination matrices at scale. This is
important if the intention is to produce stable statistics based on routing
algorithms, where the idiosyncracies of local transport service availability
means that departure times can have a significant impact upon overall journey
duration.

In summary, r<sup>5</sup>py achieves stable statistics by calculating travel
times over multiple journeys within a time window, returning insightful
summaries such as the median duration required to travel from point A to B.

:::{.callout-caution collapse="true"}

### A Note on the Purpose

This tutorial aims to familiarise the reader with r<sup>5</sup>py and how it
integrates with the python geospatial ecosystem of packages. This article is
not to be used to attempt to infer service quality outcomes or to inform policy
decisions. Limitations of this analysis and suggested improvements will be
discussed throughout.

:::

### Intended Audience

Experienced python practitioners familiar a robust working knowledge of the
typical python GIS stack, eg geopandas, shapely, fiona and folium. Familiarity
with r<sup>5</sup>py and routing operations is not required.

### Outcomes

* Ingest London bike charging station locations.
* Visualise charging stations in an interactive hex map.
* Create a naive point plane of destinations.
* Check that the point plane is large enough to accommodate station locations.
* Calculate origin:destination travel time matrix, by cycling modality and 
with a maximum journey time of 30 minutes.
* Engineer features to help analyse the cycling network accessibility.
* Visualise the cycling network coverage and the most remote points within that
area.

<iframe src="../outputs/hex_layer.html" style="display: block; margin-left: auto; margin-right: auto; width: 100%;" title="Interactive map of London cycle station location density"></iframe>

### What You'll Need:

- [ ] Conda or miniconda
- [ ] pip package manager
- [ ] Ability to install Java Development Kit
- [ ] Ability to request from Transport for London api
- [ ] Tutorial compatible with macos. `subprocess` calls may require adaptation
for other operating systems.

```{.python filename=requirements.txt eval=false}
contextily
geopandas
folium
mapclassify
matplotlib
pydeck
pyprojroot
r5py
requests
scikit-learn

```
### Getting Started

It is required to configure a Java Virtual Machine for this tutorial. The
transport routing depends on this. Please consult the r<sup>5</sup>py
installation documentation @r5pyInstallation for guidance.

## London Cycle Station Service Coverage

Start by loading the required packages.

```{python}
import datetime
import os
import subprocess
import tempfile 

import contextily as ctx
import geopandas as gpd
import matplotlib.pyplot as plt
import pandas as pd
import pydeck as pdk
import pyproj
from pyprojroot import here
import r5py
import requests
from sklearn import preprocessing
from shapely.geometry import Polygon, Point

```

### Ingest the Street Network Data

Firstly, we must acquire information about the transport network. There are
a few sources of this, but we shall use the
[BBBikes](https://download.bbbike.org/osm/bbbike/) website to ingest
London-specific open street map extracts. The required data should be in
protocolbuffer (.pbf) format.

#### Exercise 1

Find the appropriate url that points to the london.osm.pbf file. Ingest the
data and store at an appropriate location.

::: {.panel-tabset}

##### Hint

::: {.callout-tip collapse="true"}
## Click to expand hint
Either using python requests or subprocess with the `curl` command, request
the url of the pbf file and output the response to a data folder.

:::

##### Solution

```{python}
#| code-fold: true
#| code-summary: "Show the code"

osm_pth = here("data/london.osm.pbf")
# tmp = tempfile.TemporaryDirectory()
# subprocess.run(
#     [
#         "curl",
#         "https://download.bbbike.org/osm/bbbike/London/London.osm.pbf",
#         "-o",
#         os.path.join(tmp.name, "london.osm.pbf"),
#     ]
# )
# temp write to file to avoid repeat ingests

if not os.path.exists(osm_pth):
  subprocess.run(
      [
          "curl",
          "https://download.bbbike.org/osm/bbbike/London/London.osm.pbf",
          "-o",
          osm_pth,
      ]
  )

```

:::

### Ingest the Bike Charging Station Locations

#### Exercise 2

To get data about the bike charging stations in London, we will query
[Transport for London's BikePoint API](https://api.tfl.gov.uk/).

* Explore the site and find the correct endpoint to query. 
* The tutorial requires the following fields: station ID, the human-readable
name, latitude and longitude for each available station.
* Store the data in a geopandas geodataframe with the appropriate coordinate
reference system.
* Inspect the head of the geodataframe.

::: {.panel-tabset}

##### Hint

::: {.callout-tip collapse="true"}
## Click to expand hint

1. Using the resuests package, send a get request to the endpoint.
2. Store the required fields in a list: "id", "commonName", "lat", "lon".
3. Check that the response returned HTTP status 200. If True, get the content
in JSON format.
4. Create an empty list to store the station data.
5. Iterate through the content dictionaries. If a key is present within the
required fields, store the key and value within a temporary dictionary.
6. Append the dictionary of required fields and their values to the list of
stations.
7. Convert the list of dictionaries to a pandas dataframe. Then convert this
to a geopandas geodataframe, using the coordinate reference system "EPSG:4326".
As we have lat and lon in seperate columns, use geopandas `points_from_xy()`,
ensuring you pass values in the order of longitude, latitude.
8. Print out the head of the stations gdf.

:::

##### Solution

```{python}
#| code-fold: true
#| code-summary: "Show the code"

stations_pth = here("data/stations.pkl")

if not os.path.exists(stations_pth):
  ENDPOINT = "https://api.tfl.gov.uk/BikePoint/"
  resp = requests.get(ENDPOINT)
  if resp.ok:
      content = resp.json()
  else:
      raise requests.exceptions.HTTPError(
          f"{resp.status_code}: {resp.reason}"
      )

  needed_keys = ["id", "commonName", "lat", "lon"]
  all_stations = list()
  for i in content:
      node_dict = dict()
      for k, v in i.items():
          if k in needed_keys:
              node_dict[k] = v
      all_stations.append(node_dict)

  stations = pd.DataFrame(all_stations)
  station_gdf = gpd.GeoDataFrame(
      stations,
      geometry=gpd.points_from_xy(stations["lon"], stations["lat"]),
      crs=4326,
  )
  station_gdf.to_pickle(stations_pth)
else:
  stations = pd.read_pickle(stations_pth)
  station_gdf = gpd.GeoDataFrame(stations, crs=4326)

station_gdf.head()

```

:::

That's all the external data needed for this tutorial. Let's now examine the
station locations. 

### Visualise the Station Density

As the stations are densely located in and around central London, a standard
matplotlib point map would suffer from overplotting. A better way is to present
some aggregeated statistic on a map, such as density. 

#### Exercise 3

Plot the density of cycle station locations on a map. The solution will use
[pydeck](https://deckgl.readthedocs.io/en/latest/index.html), but any
visualisation library that can handle geospatial data would be fine.

::: {.panel-tabset}

##### Hint

::: {.callout-tip collapse="true"}
## Click to expand hint

1. Create a pydeck hexagon layer based on the `station_gdf`. The hexagon layer
should be configured as below:
* extruded
* position from lon and lat columns
* elevation scale is 100
* elevation range from 0 through 100
* coverage is 1
* radius of hexagons is 250 metres

2. Create a pydeck view state object to control the initial position of the
camera. Configure this as you see fit.
3. (Optional) Add a custom tooltip, clarifying that the hexagon elevation is
equal to the count of stations within that area. You may wish to consult the
[deck.gl](https://deck.gl/docs) documentation to help implement this.
4. Create a pydeck deck with the hexagon layer, custom view state, tooltip and
a map style of your choosing.

:::

##### Solution

```{python}
#| code-fold: true
#| code-summary: "Show the code"

# pydeck visuals - concentration of charging stations by r250m hex
layer = pdk.Layer(
    "HexagonLayer",
    station_gdf,
    pickable=True,
    extruded=True,
    get_position=["lon", "lat"],
    auto_highlight=True,
    elevation_scale=100,
    elevation_range=[0, 100],
    coverage=1,
    radius=250,  # in metres, default is 1km
    colorRange=[
        [255, 255, 178, 130],
        [254, 217, 118, 130],
        [254, 178, 76, 130],
        [253, 141, 60, 130],
        [240, 59, 32, 130],
        [189, 0, 38, 130],
    ], # optionally added rgba values to spec transparency
)
view_state = pdk.ViewState(
    longitude=-0.110,
    latitude=51.518,
    zoom=11,
    min_zoom=5,
    max_zoom=15,
    pitch=40.5,
    bearing=-27.36,
)
tooltip = {"html": "<b>n Stations:</b> {elevationValue}"}
r = pdk.Deck(
    layers=[layer],
    initial_view_state=view_state,
    tooltip=tooltip, # prettier than default tooltip
    map_style=pdk.map_styles.LIGHT,
)
r

```

:::

### Generate Destination Locations

We can use the bike stations as journey origins. To compute travel times, we
need to generate destination locations. This tutorial uses a simple approach
to generating equally spaced points within a user-defined bounding box. 

:::{.callout-caution}
#### Limitation

Generating a point plane is a fast way to get a travel time matrix. However,
this is naive to locations that the riders would prefer to start or finish
their journeys. A more robust approach would be to use locations of retail or
residential features. The European Commission's Global Human Settlement Layer
@GHSL data would provide centroids to every populated grid cell down to a
10m<sup>2</sup> resolution.
:::

#### Exercise 4

Write a function called `create_point_grid()` that will take the following
parameters:

* `bbox_list` expecting a [bounding box](https://boundingbox.klokantech.com/)
list in [xmin, ymin, xmax, ymax] format with epsg:4326 longitude & latitude
values.
* `stepsize` expecting a positive integer, specifying the spacing of the grid
points in metres.

`create_point_grid()` should return a geopandas geodataframe of equally spaced
point locations - the point grid. The grid point locations should be in
epsg:4326 projection. The geodataframe requires a `geometry` column and an `id`
column equal to the index of the dataframe (required for r<sup>5</sup>py
origin:destination matrix calculation).

Once you are happy with the function, use it to produce an example geodataframe
and `explore()` a folium map of the point grid.

::: {.panel-tabset}

##### Hint

::: {.callout-tip collapse="true"}
## Click to expand hint

Note that epsg:4326 is a geodetic projection, unsuitable for measuring distance
between points in the point plane. Ensure that the crs is re-projected to an
appropriate planar crs for distance calculation.

1. Store the South-West and North-East coordinates as `shapely.geometry.Point`
objects.
2. Use `pyproj.Transformer.from_crs()` to create 2 transformers, one from
geodetic to planar, and the other back from planar to geodetic.
3. Use the transformers to convert the SW and NE points from geodetic to
planar.
4. Use nested loops to iterate over the area between the corner points.
Store the point location as a `shapely.geometry.Point` object, using a
transformer to convert back to epsg:4326. Append the point to a list of grid
points.
5. Increment the x and y values by the provided `stepsize` and continue to
append points in this fashion until xmin has reached the xmax value, likewise
until ymin has met the ymax value.
6. Create a pandas dataframe with the geometry column using the appended point
locations and an `id` column that uses the `range()` function to generate a
unique integer value for each row. 
7. Use the defined function with a sample bounding box and explore the
resulting geodataframe with an interactive folium map.

:::

##### Solution

```{python}
#| code-fold: true
#| code-summary: "Show the code"

def create_point_grid(bbox_list: list, stepsize: int) -> gpd.GeoDataFrame:
    """Create a metric point plane for a given bounding box.

    Return a geodataframe of evenly spaced points for a specified bounding box.
    Distance between points is controlled by stepsize in metres.  As
    an intermediate step requires transformation to epsg:27700, the calculation
    of points is suitable for GB only.

    Parameters
    ----------
    bbox_list : list
        A list in xmin, ymin, xmax, ymax order. Expected to be in epsg:4326.
        Use https://boundingbox.klokantech.com/ or similar to export a bbox.
    stepsize : int
        Spacing of grid points in metres. Must be larger than zero.

    Returns
    -------
    gpd.GeoDataFrame
        GeoDataFrame in epsg:4326 of the point locations.

    Raises
    ------
    TypeError
        bbox_list is not type list.
        Coordinates in bbox_list are not type float.
        step_size is not type int.
    ValueError
        bbox_list is not length 4.
        xmin is greater than or equal to xmax.
        ymin is greater than or equal to ymax.
        step_size is not a positive integer.

    """
    # defensive checks
    if not isinstance(bbox_list, list):
        raise TypeError(f"bbox_list expects a list. Found {type(bbox_list)}")
    if not len(bbox_list) == 4:
        raise ValueError(f"bbox_list expects 4 values. Found {len(bbox_list)}")
    for coord in bbox_list:
        if not isinstance(coord, float):
            raise TypeError(
                f"Coords must be float. Found {coord}: {type(coord)}"
            )
    # check points are ordered correctly
    xmin, ymin, xmax, ymax = bbox_list
    if xmin >= xmax:
        raise ValueError(
            "bbox_list value at pos 0 should be smaller than value at pos 2."
        )
    if ymin >= ymax:
        raise ValueError(
            "bbox_list value at pos 1 should be smaller than value at pos 3."
        )
    if not isinstance(stepsize, int):
        raise TypeError(f"stepsize expects int. Found {type(stepsize)}")
    if stepsize <= 0:
        raise ValueError("stepsize must be a positive integer.")

    # Set up crs transformers. Need a planar crs for work in metres - use BNG
    planar_transformer = pyproj.Transformer.from_crs(4326, 27700)
    geodetic_transformer = pyproj.Transformer.from_crs(27700, 4326)
    # bbox corners
    sw = Point((xmin, ymin))
    ne = Point((xmax, ymax))
    # Project corners to planar
    planar_sw = planar_transformer.transform(sw.x, sw.y)
    planar_ne = planar_transformer.transform(ne.x, ne.y)
    # Iterate over metric plane
    points = []
    x = planar_sw[0]
    while x < planar_ne[0]:
        y = planar_sw[1]
        while y < planar_ne[1]:
            p = Point(geodetic_transformer.transform(x, y))
            points.append(p)
            y += stepsize
        x += stepsize
    df = pd.DataFrame({"geometry": points, "id": range(0, len(points))})
    gdf = gpd.GeoDataFrame(df, crs=4326)
    return gdf

create_point_grid(
  bbox_list=[-0.5917,51.2086,0.367,51.7575], stepsize=5000).explore(min_zoom=9)

```

:::


```{python}
# Tidy up
# tmp.cleanup()

```

### Tips

* The packages used in this tutorial expect the sequence of coordinates to be
long, lat. If you select an alternative method for mapping visuals, remember to
check that this is consistent. If you are getting empty interactive map
visuals, pan out and check that an incorrect coordinate specification has
resulted in your points being rendered off the East coast of Africa.

## Conclusion


#### Exercise Example

Some txt

::: {.panel-tabset}

##### Hint

::: {.callout-tip collapse="true"}
## Click to expand hint
Some hint

:::

##### Solution

```{python}
#| code-fold: true
#| code-summary: "Show the code"

# Some solution

```

:::

<p id=fin><i>fin!</i></p>
