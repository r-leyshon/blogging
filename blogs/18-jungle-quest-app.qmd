---
title: "Choose Your Own Adventure with ChatGPT"
author: "Rich Leyshon"
date: "September 21 2024"
description: "Iteratively Building an LLM-Powered Shiny Application."
categories:
    - Tutorial
    - Python Shiny
    - LLMs
    - Large Language Models
    - GenAI
    - Generative AI
    - Front End Dev
    - OpenAI
image: https://i.imgur.com/z9Xm9Lf.jpeg
image-alt: "Adventurer reading a large book within a mysterious jungle temple."
toc: true
css: /./www/17-quarto-comments/styles.css
code-annotations: select
---

<figure class=center>
 <img class=shaded_box src=https://i.imgur.com/z9Xm9Lf.jpeg alt="Adventurer reading within a jungle temple." width=120%>
</figure>

> "ChatGPT amplifies human potential, turning thoughts into creation. It
reminds us that imagination, when paired with technology, can shape the
future." ChatGPT on the creative potential of ChatGPT.

## Introduction

This article will guide you through the process of building a Choose Your
Own Adventure game using ChatGPT and Python Shiny. We'll walk through the
entire journey, from concept to deployment, with a focus on the iterative
development process and the use of ChatGPT for generating storylines.

Choose Your Own Adventure is a classic storytelling format where the reader
is presented with a series of choices that guide the story in different
directions. The game is interactive, allowing the reader to make decisions
that affect the outcome of the story. They were popular in the 1980s and
early 1990s, widely available as graphic novels and comics with a fantasy
or adventure theme.

The aim of this project is to produce an interactive application that will
put the OpenAI GPT-3.5-turbo model to work. The model will generate the
branching outcomes depending on the choices made by the user. We will
provide the user with an introduction to the theme and we will provide the
model with the rules for the game. Each game will play out differently
depending on the creative interplay between the user and the model.

::: {.callout-note collapse=true}

### Inspiration for This Blog (Click to expand)

The application concept was heavily influenced by the YouTube video by 
Tech with Tim called
<a href="https://www.youtube.com/watch?v=nhYcTh6vw9A" target="_blank">Python AI Choose Your Own Adventure Game - Tutorial</a>.
This tutorial uses a more complicated stack behind the scenes and resulted
in a game that solved itself - essentially the model would also generate
'imagined' user responses through to completion. The tutorial was published
only 11 months ago at the time of writing, though the code would not run
without significant wiggling, due to a raft of breaking changes within
langchain.

I was inspired by the playful use of generative AI but could see that a few
things could be done to improve the reproducibility of the code. Also, by 
simplifying the stack required to generate the game responses, it is hoped
that the risk of deprecation and breaking changes will be reduced,
increasing the longevity of the code. Finally, an application would be
needed in order to allow the human player and model to take turns in
playing the game. I have opted to use 
<a href="https://shiny.posit.co/py/" target="_blank">Shiny for Python</a>
in order to achieve this, though the same functionality could be achieved
with many other dashboarding solutions.

:::

### Intended Audience

Python programmers who are curious about building LLM-enabled applications.
Some familiarity with Shiny may be assumed. For an overview and intro to
building Shiny apps with Python, chack out my other blogs:

- [The State of Python Shiny](/blogs/01-state-of-pyshiny.qmd)
- [Let's Build a Basic Python Shiny App](/blogs/02-getting-started-pyshiny.qmd)

### What You'll Need

- [ ] Command line access
- [ ] Python know-how
  - [ ] Configure a virtual environment
  - [ ] Dependency management
- [ ] Basic knowledge of Python Shiny
- [ ] An OpenAI API key

```{.abc filename=requirements.txt}
openai==1.30.4
shiny==1.1.0
shinyswatch==0.7.0

```

:::{.callout collapse="true"}

### A Note on the Purpose (Click to expand)

This article intends to discuss clearly. It doesn't aim to be clever or
impressive. Its aim is to extend understanding without overwhelming the
reader. The code may not always be optimal, favouring a simplistic approach
wherever possible. The application may not be to your liking. The purpose
is to introduce a simple AI-driven applications rather than a masterpiece.
If you have ideas for improvements to the app or blog, please feel free to
leave a comment at then end of the article.

:::

The final application is presented below, hosted with
<a href="https://www.shinyapps.io/" target="_blank">shinyapps.io</a>.
Please note, this is not configured for high traffic. Let me know if the
app fails to launch for you by leaving a comment at the end of the blog.
You will need an OpenAI API key in order to prompt the model. The app has a
link to the sign up page if you would like to give it a try. If you would
prefer to read the source code for the application before proceeding with
the article, then please click on the GitHub icon at the top-right of the
application. If you would rather interact with the application in a
full-sized window, then visit the
<a href="https://richleysh84.shinyapps.io/choose-adventure/" target="_blank">Jungle Quest app on shinyapps.io</a>.
This app is set up to query the gpt-3.5-turbo model, but as you proceed
through the tutorial, feel free to experiment with other available models
(they can behave quite differently).

<div style="text-align:center;padding-left:10%;">
  <iframe class=iframey src="https://richleysh84.shinyapps.io/choose-adventure/" style="overflow:hidden;margin:0;padding:0;width:100%;height:50rem"></iframe>
</div>

## Setting up the Development Environment

I'd recommend using VSCode with the
<a href="https://marketplace.visualstudio.com/items?itemName=Posit.shiny" target="_blank">Shiny extension</a>
to help run and debug the app. It has a super handy utility for launching
your app within the VSCode interface or expanding it to full screen in your
default browser. This is priceless when testing your User Interface's (UI)
appearance on different browsers.

You'll need to create and activate a virtual environment of your choice, I
have used python 3.12 in the examples without any issues. install the
dependencies listed in the `requirements.txt` file, and finally ensure that
VSCode is configured to
<a href="https://code.visualstudio.com/docs/python/environments" target="_blank">use the virtual environment</a>.

## Iterative Development

::: {.callout-caution}

Take care with your OpenAI APi credentials. I demonstrate hard-coding these
credentials within python scripts for simplicity. I'd advise storing them
in a git-ignored secrets file or using the
<a href=https://pypi.org/project/python-dotenv/ target="_blank">`python-dotenv`</a>
package to handle keeping them safe. Take care not to accidentally commit
these credentials and expose them on GitHub. Leakage of OpenAI credentials
is the fastest-growing type of secret leak, according to
<a href=https://www.gitguardian.com/state-of-secrets-sprawl-report-2024 target="_blank">Git Guardian's State of Secret Sprawl 2024</a>.

:::

::: {.callout-tip}

### Code Annotations

By clicking on the numbered points within the code blocks, you should see
tooltips with additional explanations as to what the code is doing.

:::

::: {.panel-tabset #iterations}

### Iteration 1

In this early prototype, we will focus on using the openai python client
to send a basic prompt to the gpt-3.5-turbo model. 

```{.python filename=app.py}
"""Iteration 1: How to query the OpenAI API."""
import openai

API_KEY = "<INSERT_YOUR_KEY_HERE>"                                    # <1>


def query_openai(prompt: str, api_key: str) -> str:
    """Query the chat completions endpoint.

    Parameters
    ----------
    prompt: str
        The prompt to query the chat completions endpoint with.
    api_key: str
        The API key to use to query the chat completions endpoint.

    Returns
    -------
    str
        The response from the chat completions endpoint.
    """

    client = openai.OpenAI(api_key=api_key)                           # <2>
    # need to handle cases where queries go wrong.
    try:                                                              # <3>
        response = client.chat.completions.create(
            model="gpt-3.5-turbo",
            messages=[                                                # <4>
                {"role": "user", "content": prompt}                   # <4>
            ]                                                         # <4>
        )
        return response.choices[0].message.content
    # in cases where the API key is invalid.
    except openai.AuthenticationError as e:
        raise ValueError(f"Is your API key valid?:\n {e}")



model_response = query_openai(
  prompt="What is the capital of the moon?", api_key=API_KEY
  )

```
1. Insert your API key into the API_KEY variable. Note - it's not advisable
to include your secret credentials in your python scripts like this, but
for simplicity's sake, I'm showing that here. I'd advise storing them in a
git-ignored secrets file or using the `python-dotenv` package to handle
keeping them safe. Take care not to accidentally commit these
credentials and expose them on GitHub.
2. Create a new OpenAI client with the api_key.
3. This will only pass if the key provided is valid.
4. Note the format of the messages - a list of dictionaries. The value for
role can be "user", "system" or "assistant".

The model responds with:

> The moon does not have a capital as it is not a sovereign nation or
political entity.

Let's summarise the process with a diagram:

![Process diagram for iteration 1](https://i.imgur.com/t15T2J3.png)

So far we have a basic `query_openai()` function that we can feed in a
prompt and our api key. We then receive a response back from the openai
model with the expected content.

Although this is an extremely simple process, it's great to start off with
the fundamentals. Understanding the structure of what's being sent and
received is useful when we begin embedding this logic into our Shiny app.

### Iteration 2

In this iteration, we are going to introduce a system message to help
guide the behaviour of the model - we will want it to act as the guide on
an adventure. We'll also need it to follow a few rules such as how to
indicate the game is over.

```{.python filename=app.py}
"""Iteration 2: Add system & welcome prompts."""
import openai

API_KEY = "<INSERT_YOUR_KEY_HERE>"
_SYSTEM_MSG = """
You are the guide of a 'choose your own adventure'- style game: a mystical
journey through the Amazon Rainforest. Your job is to create compelling
outcomes that correspond with the player's choices. You must navigate the
player through challenges, providing choices, and consequences, dynamically
adapting the tale based on the player's inputs. Your goal is to create a
branching narrative experience where each of the player's choices leads to
a new path, ultimately determining their fate. The player's goal is to find
the lost crown of Quetzalcoatl.

Here are some rules to follow:
1. Always wait for the player to respond with their input before providing  # <1>
any choices. Never provide the player's input yourself. This is most        # <1>
important.                                                                  # <1>
2. Ask the player to provide a name, gender and race.
3. Ask the player to choose from a selection of weapons that will be used
later in the game.
4. Have a few paths that lead to success. 
5. Have some paths that lead to death.
6. Whether or not the game results in success or death, the response must   # <2>
include the text "The End...", I will search for this text to end the game. # <2>
"""

WELCOME_MSG = """
Welcome to the Amazon Rainforest, adventurer! Your mission is to find the   # <3>
lost Crown of Quetzalcoatl.                                                 # <3>
However, many challenges stand in your way. Are you brave enough, strong    # <3>
enough and clever enough to overcome the perils of the jungle and secure    # <3>
the crown?                                                                  # <3>
                                                                            # <3>
Before we begin our journey, choose your name, gender and race. Choose a    # <3>
weapon to bring with you. Choose wisely, as the way ahead is filled with    # <3>
many dangers.                                                               # <3>
"""                                                                         # <3>


def query_openai(
        prompt: str,
        api_key: str,
        sys_prompt:str = _SYSTEM_MSG,
        start_prompt:str = WELCOME_MSG,
        ) -> str:
    """Query the chat completions endpoint.

    Parameters
    ----------
    prompt: str
        The prompt to query the chat completions endpoint with.
    api_key: str
        The API key to use to query the chat completions endpoint.
    sys_prompt: str
        The system prompt to help guide the model behaviour. By default,
        the system prompt is set to _SYSTEM_MSG.
    start_prompt: str
        The start prompt which will be presented to the user as the app
        begins. By default, the start prompt is set to WELCOME_MSG.

    Returns
    -------
    str
        The response from the chat completions endpoint.
    """

    client = openai.OpenAI(api_key=api_key)
    # need to handle cases where queries go wrong.
    try:
        response = client.chat.completions.create(
            model="gpt-3.5-turbo",
            messages=[                                                      # <4>
                {"role": "system", "content": sys_prompt},                  # <4>
                {"role": "assistant", "content": start_prompt},             # <4>
                {"role": "user", "content": prompt},                        # <4>
            ]                                                               # <4>
        )
        return response.choices[0].message.content
    # in cases where the API key is invalid.
    except openai.AuthenticationError as e:
        raise ValueError(f"Is your API key valid?:\n {e}")


model_response = query_openai(
    prompt="What is the capital of the moon?",
    api_key=API_KEY
    )

```
1. Certain models can get a bit over-zealous and start providing imagined
user input, ultimately playing the game thorugh to completion on their own.
As games go, that's not that fun, so let's try to safeguard against that
behaviour with these explicit instructions.
2. The gpt-3.5-turbo model seems to be pretty reliable at ending the game
with the required pattern "The end...". We'll later search for this pattern
to exit the app and return a message indicating game over. Interestingly, 
I found gpt-4 models to be fairly unreliable in following this instruction.
All of the models can be configured to stream their responses too, in which
case they rarely gave the specified game over pattern. I'd be interested in
others' opinions as to why this may be the case. Please feel free to leave
a comment at the end of the article if you have an opinion.
3. This welcome message will be used to introduce the game context for our
users when the app launches. We will append this into the message stream
and simulate our LLM greeting our user. We will also include this message
when querying the model, where it will serve as what's known as a one-shot
prompt to help guide the model's behaviour. A one-shot prompt is an example
of how you'd like the model to behave.
4. We now update the messages stream with our hard-coded prompt. This helps
to guide both the model and the user, setting context and modelling the
desired behaviour.

Thanks to the guidance in the hard-coded prompts, our model now behaves a
bit differently:

> I'm afraid the Moon doesn't have a capital city like countries on Earth
do! Let's focus on our adventure in the Amazon Rainforest. To begin, please
choose your name, gender, and race. Additionally, select a weapon to arm
yourself with on this mystical journey. The fate of finding the lost Crown
of Quetzalcoatl awaits your choices!

Notice that the model still answers the question, but guides the user back
to the purpose of the app. In a later iteration, we will see how to
introduce moderations as a safeguard against the user passing inappropriate
content.

Finally, updating our process diagram to include the additional prompts, I
have emphasised the changes implemented within this iteration. As we
proceed, the diagram's complexity will increase and therefore I'll try to
emphasise the changes implemented over the previous iteration only:

![Process diagram for iteration 2](https://i.imgur.com/6vuOSp5.png)

### Iteration 3

In this iteration, we'll put together the basic UI for the app. The UI
needs a text field to pass the user's API key and the chat component. Let's
update the app script to include the shiny UI.

```{.python filename="app.py"}
"""Iteration 3: A basic user interface with no server logic."""
import openai
from shiny import App, ui

_SYSTEM_MSG = """
You are the guide of a 'choose your own adventure'- style game: a mystical
journey through the Amazon Rainforest. Your job is to create compelling
outcomes that correspond with the player's choices. You must navigate the
player through challenges, providing choices, and consequences, dynamically
adapting the tale based on the player's inputs. Your goal is to create a
branching narrative experience where each of the player's choices leads to
a new path, ultimately determining their fate. The player's goal is to find
the lost crown of Quetzalcoatl.

Here are some rules to follow:
1. Always wait for the player to respond with their input before providing
any choices. Never provide the player's input yourself. This is most
important.
2. Ask the player to provide a name, gender and race.
3. Ask the player to choose from a selection of weapons that will be used
later in the game.
4. Have a few paths that lead to success. 
5. Have some paths that lead to death.
6. Whether or not the game results in success or death, the response must
include the text "The End...", I will search for this text to end the game.
"""

WELCOME_MSG = """
Welcome to the Amazon Rainforest, adventurer! Your mission is to find the
lost Crown of Quetzalcoatl.
However, many challenges stand in your way. Are you brave enough, strong
enough and clever enough to overcome the perils of the jungle and secure
the crown?

Before we begin our journey, choose your name, gender and race. Choose a
weapon to bring with you. Choose wisely, as the way ahead is filled with
many dangers.
"""


def query_openai(
        prompt: str,
        api_key: str,
        sys_prompt:str = _SYSTEM_MSG,
        start_prompt:str = WELCOME_MSG,
        ) -> str:
    """Query the chat completions endpoint.

    Parameters
    ----------
    prompt: str
        The prompt to query the chat completions endpoint with.
    api_key: str
        The API key to use to query the chat completions endpoint.
    sys_prompt: str
        The system prompt to help guide the model behaviour. By default,
        the system prompt is set to _SYSTEM_MSG.
    start_prompt: str
        The start prompt which will be presented to the user as the app
        begins. By default, the start prompt is set to WELCOME_MSG.

    Returns
    -------
    str
        The response from the chat completions endpoint.
    """

    client = openai.OpenAI(api_key=api_key)
    # need to handle cases where queries go wrong.
    try:
        response = client.chat.completions.create(
            model="gpt-3.5-turbo",
            messages=[
                {"role": "system", "content": sys_prompt},
                {"role": "assistant", "content": start_prompt},
                {"role": "user", "content": prompt},
            ]
        )
        return response.choices[0].message.content
    # in cases where the API key is invalid.
    except openai.AuthenticationError as e:
        raise ValueError(f"Is your API key valid?:\n {e}")


# Shiny User Interface ----------------------------------------------------

app_ui = ui.page_fillable(                                                  # <1>
    ui.panel_title("Choose Your Own Adventure: Jungle Quest!"),
    ui.accordion(                                                           # <2>
    ui.accordion_panel("Step 1: Your OpenAI API Key",
        ui.input_text(id="key_input", label="Enter your openai api key"),   # <3>
    ), id="acc", multiple=False),
    ui.chat_ui(id="chat"),                                                  
    fillable_mobile=True,
)

app = App(app_ui, server=None)                                              # <4>
```
1. `ui.page_fillable()` Works well with a chat component, increasing the
height of your app to accommodate a growing chat log.
2. The `ui.accordion()` component will present a collapsible panel. This
will be useful for the key input panel - we can minimise this portion of
our app and focus on the chat.
3. In `shiny` UI elements, the first argument is usually the `id`. If you
know CSS and HTML, then it's the same `id` you'd target for styling an
element. It's really important in `shiny` as the server logic we'll write
later will communicate data to the UI via these `id` values. Make sure the
`id` values are unique and do not include hyphens - use underscores
instead. Shiny will raise the following error if you attempt to use
`id="row-1"` for example:
`ValueError: The string 'row-1' is not a valid id; only letters, numbers, and underscore are permitted` 
4. In this final step, we need to combine our UI with server logic to make
things work. As we haven't written any server logic yet, we can just pass
`None`. This means our UI won't do anything in its current state.

Feel free to play around with the code and re-run the app using the play
icon in the top-right corner of `app.py`. This interface uses the
<a href="https://shinylive.io/py/examples/" target="_blank">shinylive service</a>
which is useful for sharing simple shiny apps without any need for python
installations.

<iframe src=https://shinylive.io/py/editor/#code=NobwRAdghgtgpmAXGKAHVA6VBPMAaMAYwHsIAXOcpMAMwCdiYACAZwAsBLCbJjmVYnTJMAgujxMArhwA6EOWlQB9aUwC8UjligBzOEpocANkagAjI3AAUcpnc3aIcI0rIcylm2ADCbYsRY4JgBNYkk6JgB5AHcIUQATADdKMnC4RCYAKUkIHUsmAEVJOBYyAEIZMABKPFt7aQwoQhI6eI5SGzj6rSaWttIlVCgnIy8AZQpUJgBGDNDwqNRKEQBJUQAFNYBpOGxK2q77bowuVEkyVzgADzIrDni1SoBrXaVT8-2mUzNnR7AAUXIcAi2DCEWIS2gHCYaGhLz21QORxqvAelV6nxgkiMblQljUADEoEZAjU6nYGoQ2FALtI7miiNSyJUyYcmIYTOZLEoYMQzMY4GoACp0YoHKpyBTodSidBWRQqDgSQJ0ZJ0NQAOVIcAlEDAAF8ALpAA class=iframey style="overflow:hidden;margin:0;padding:0;width:100%;height:30rem"></iframe>

The process diagram for our app so far looks like this:

![Process diagram for iteration 2](https://i.imgur.com/ToBp4iQ.png)

Our logic for talking to the OpenAI model has not yet been coupled with our
UI. We'll fold that logic into our shiny server in the next iteration.

### Iteration 4

### Iteration 5

### Iteration 6

### Iteration 7

### Iteration 8

### Iteration 9


:::

[Click to return to the start of iteration tabsets](#iterations)

### Iteration 1

- Query openai with python client

- Initial prompt

- System prompt

- Basic App: iteration1: Basic UI - chat interface.

- Iteration 2: Server appends stream.

- Iteration 3: Add accordion for collapsible manu for key entry.

- Iteration 4: Add a submit button & message.

- Iteration 5: Add utility for checking API key validity.

- Iteration 6: Add moderations utility.

- Iteration 7: Instructions & styling.


## 8. Final Touches and Deployment
- **Polishing the app**
  - Any last steps before deploying: Testing, UI tweaks, refining the game logic.
- **Deploying the App**
  - Link to deployment file and backlink t deploying to shinyapps.io blog.

## Conclusion
- Recap the journey of building the app, from idea to deployment.
- Mention potential future improvements (e.g., adding more complex storylines, user authentication, etc.).
- Invite readers to try out the app or explore the code on GitHub.

## Call to Action
- **GitHub Link**: Provide a link to the source code repository.
- **Demo Link**: If applicable, include a link to a live version of the app.
- **Invitation for Feedback**: Encourage readers to share their thoughts or improvements in the comments.

If you spot an error with this article, or have a suggested improvement then
feel free to leave a comment (GitHub login required) or
[raise an issue on GitHub](https://github.com/r-leyshon/blogging/issues).  

<p id=fin><i>fin!</i></p>
