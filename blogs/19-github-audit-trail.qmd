---
title: "GitHub Keeps Your Commit History Readable."
author: "Rich Leyshon"
date: "September 28 2024"
description: "Let GitHub Nudge You Towards a Better Audit Trail."
categories:
    - Explanation
    - GitHub
    - Git
    - Version Control
    - Software Development
image: https://i.imgur.com/iwVPwPG.png
image-alt: "A cute cat-like character inspects code with a magnifying glass."
toc: true
css: /./www/17-quarto-comments/styles.css
---

 <img class=shaded_box src=https://i.imgur.com/iwVPwPG.png alt="A cute cat-like character inspects code with a magnifying glass." style="display:block;margin-left:auto;margin-right:auto;width:60%;border:none;">

> "You don't need version control any more than a trapese [sic] artist
needs a safety net." Mark Cidade, <a href=https://stackoverflow.com/posts/250991/revisions target="_blank">Stack Overflow</a>

## Introduction

Most developers spend time reading other people's code - for Pull
Reviews (PRs) or to learn more about an Application Programming Interface
(API), for example. Every so often, a developer may need to review an
entire repository and possibly even its commit history. This can happen
when publishing a mature codebase.

Making sennse of other peoples' commit histories can be challenging,
especially if that work is exploratory. Understanding the myriad reasons
for any single change after the fact is reliant upon whether the developer
had time to document their reasons for their implementation. Even if you work alone, perhaps that other developer
will be yourself at times. Needing to pick through your code's commit
history in order to find a bug-free version. 

The good news is that there are a few tools that GitHub can provide us, and
one or two easy habits that will greatly assist your colleagues' in
comprehending your Git activity. In fact, the GitHub User Interface (UI) is
designed in subtle ways, to nudge you towards some of these behaviours. The
sort of things that are not required but are incredibly helpful to others - 
including your future self. 

<iframe src="https://giphy.com/embed/TtlYafuP93f5FxemDU" style="display:block;margin-left:auto;margin-right:auto;width:60%;height:16rem;border:none;" class="iframey shaded_box" allowFullScreen></iframe>
<br>
In my opinion, Jerry really should have included "...your future self..."
in there, too. Read on for more on how to be kind to yourself, and those
poor souls who need to read your work - GitHub has your back.

:::{.callout-note collapsed="true"}

### Acknowledgements (click to expand)

Every Git user has their own way of doing things. Many experts on the
matter have diverging opinions on pretty much everything Git has to offer.
In this article, I am offering a medley of advice from colleagues, trial,
error and pain incurred. I'd bet that not all the advice here will chime
with you. If you're able to properly consider, compare and discard any of
these suggested practices

:::

### Intended Audience

Programmers who use GitHub to share code. The kind of Porgrammers who:

- may not have used GitHhub to collaborate in teams (previously me).
- pride themselves on knowing 'just enough Git to survive' (me).
- have been using GitHub for a few years and wonder if their views are becoming entrenched (future me).

This article will include a fair amount of opinion & appreciation for how
GitHub helps promote sustainable behaviours. You are most welcome to disagree
and share your own opinions. There is a comments section at the bottom of
the page to facilitate that.


## Commit Messages

One of the most 'freeing' style guide rules an organisation can institute
are rules for what it considers to be good commit messages. Having enough
rules to help take the pondering out of writing your message content will
help get you back onto the development work quicker. 

Having well-structured commit messages also helps others to quickly understand 
the types of changes that have been implemented in a pull request (PR).
Some of my previous colleagues took the time to put together a
<a href=https://datasciencecampus.github.io/coding-standards/version-control.html target="_blank">style guide</a>
with a specific pattern for commit messages:

> "
> `<type>: <subject>`
> 
> type
> 
> Must be one of the following:
> 
> * feat: A new feature
> * fix: A bug fix
> * doc: Documentation only changes
> * style: Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc)
> * refactor: A code change that neither fixes a bug or adds a feature
> * perf: A code change that improves performance
> * test: Adding missing tests
> * chore: Changes to the build process or auxiliary tools and libraries such as documentation generation
> Do not capitalise the first letter.
> 
> subject
> 
> The subject contains succinct description of the change:
> 
> * use the imperative, present tense: “Change” not “Changed” nor “Changes”
> * do capitalise first letter
> * no dot (.) at the end"

Many thanks to those unmet colleagues who took the time to write this
guidance.

This has been super useful for 99% of my commit messages that are one-liners.
On the odd occasion I've felt a multi-line message was required, having the
guidance for that written down has been a priceless time-saver. Using a
commit type has also helped in moving backwards through the version
history - helping my future self to target specific refactoring diffs
or taking a rummage through a feature that introduced some newly discovered
bug. 

Considering the commit subject, I would subscribe to
<a href=https://best-practice-and-impact.github.io/qa-of-code-guidance/version_control.html#write-short-and-informative-commits target="_blank">ONS Duck Book's advice</a> - aspire to short and informative messages. 

## Link PRs with Issues

To those poor souls who have jobs that involve reading through commit logs 
- we salute you.

Oftentimes understanding the **reason** for a commit can become a mystery.
Trying to understand the purpose of some contextless diff can become a real
chore. By ensuring that each PR is linked with an issue (or issues), we can
help provide the context needed to anyone who needs to pick through or pick
apart our code. 

The GitHub UI helps to nudge us in the right direction. Below I create a
new issue in the repo for this blog:

![Creating an issue in GitHub](https://i.imgur.com/kvkwrW0.png)

Notice that there is an option on the right hand side, under `Development`
to `Create a branch` for this issue. Click this and GitHub will create
a branch with a naming convention that links the branch to the issue.

<img src=https://i.imgur.com/2EOE623.png alt="Creating a new branch from an issue in GitHub" style="display:block;margin-left:auto;margin-right:auto;" width=400rem>

Once finished with the branch, we raise a PR. To link the PR with the issue,
ensure to use one of <a href=https://docs.github.com/en/get-started/writing-on-github/working-with-advanced-formatting/using-keywords-in-issues-and-pull-requests#linking-a-pull-request-to-an-issue target="_blank">GitHub's keywords</a>
to automatically close the issue on merge. In this example, including the
line `Fixes #71` in a comment within the PR will link the issue. Several
issues can be linked in this way, eg `Fixes #71, Resolves #72` and so on.

If you have a GitHub project set up with automation rules, that ticket is
moved from the column it previously lived in to the 'Done' column.

## Consider Your Merge Strategy 

When merging a PR in the GitHub UI, 3 options are presented:

![](INSERT IMG)

These options are a little involved and I would recommend reading
[GitHub's merge docs](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/incorporating-changes-from-a-pull-request/about-pull-request-merges)
on the matter for a more detailed breakdown. A brief summary can be seen
in the table below.

| **Merge Type**       | **What Happens** | **How It Looks** | **Best For**     | **Downside**     |
|----------------------|------------------|------------------|------------------|------------------|
| **Merge Commit**     | A new commit is created to merge the PR, keeping all individual commits intact. | A merge commit is added, and you can see all the individual commits from the PR.| Keeping a detailed history with all commits preserved. | Can clutter the commit history with many small or trivial commits. |
| **Squash and Merge** | All commits in the PR are combined into one single commit before merging. | Only one commit appears in the history, representing all changes from the PR. | Keeping the commit history clean and concise. | Loses the individual commit details from the PR. |
| **Rebase and Merge** | The commits from the PR are applied directly on top of the main branch, maintaining their original structure but without a merge commit. | The history looks linear, with the PR commits applied after the latest main branch commit, with no merge commit in between. | Keeping a linear, clean commit history without merge commits. | Can be tricky with conflicts, especially for complex histories. |

To help visualise the differences in these approaches, here is a ghelpful
diagram:

![Source: https://matt-rickard.com/squash-merge-or-rebase](https://matt-rickard.com/static/image/squash-merge-or-rebase/1.webp)

In the following scenarios, I will walk through commit history following
the three different merges. In all examples, I will refer to the target
branch receiving the commits as `main` and the topic branch containing the
commits as `feature`.

### Rebase Merge

When a rebase merge is used, new commits that mirror those in the
feature branch are created in the main branch. You keep every commit and
maintain a linear commit history. In the diagram below, I compare commits
in a repository with an example rebase merge,
[code available here](https://github.com/r-leyshon/rebase-merge-example).
Note that there are 2 commits with content from the feature branch with
commit messages like "FEATURE: ...". The new commits to main contain all
the file edits in the feature branch but the commits have different hashes.

![Comparing `main` and `feature` following rebase merge.](https://i.imgur.com/M7ZMT4i.png)

### Squash and Merge

On selecting "Squash and merge" in the GitHub UI, A new "summary commit"
is created in the main branch. This condenses all of the file changes
within `feature` branch into a single, new commit. You can see that even in
the trivial example
[squash merge repository](https://github.com/r-leyshon/squash-commit-example),
the outcome is that `main` branch will be much more succinct than in the
other merge strategies. 

![Comparing `main` and `feature` following a squash merge.](https://i.imgur.com/NbfJjZD.png)

Inspecting the automated squash merge commit message demonstrates how
GitHub summarises the activity in `feature` branch.

![Squash commit generated commit message.](https://i.imgur.com/KBznXhf.png)

The squash merge strategy is a good candidate for busy projects with many
contributors. It's also a neat way to avoid noise in your version history,
such as experimental 'cruft' or benign changes that you'd rather summarise.
It is important to note that once merged to `main`, you should go ahead and
delete the `feature` branch. If you continue to work in `feature`, there is
a likelihood of diverging with `main`, ending up in merge conflicts to
resolve.

### Merge Commit

Finally, we consider the dedfault merge behaviour - the
[merge commit](https://github.com/r-leyshon/merge-commit-example). This
behaviour will create a new commit in `main` that introduces the changes
in `feature`. Notice that in this scenario, the commits in `main` and
`feature` share the same content and commit hashes, as opposed to a rebase
merge which "pretends" those commits happened in `main`. 

![Comparing `main` and `feature` following a merge commit.](https://i.imgur.com/BiuYZAv.png)

This is perhaps the noisiest merge strategy, as the commits of each feature
branch are all merged to main, plus an additional commit that marks the
merge. Use this scenario if you consider it really important to be able to
revisit  the commit history. 

### Selecting a Merge Strategy

Understanding which strategy is for the best depends on the context in
which you're working. Your 2 options for maintining a full commit history
are either merge commit or rebase and merge. If you would rather summarise
the commit history, then squash commit is the right approach. If I'm
working on a solo project, I tend to merge commit. If I'm working in a
team, I tend to squash commit in order to keep the version history
manageable. 

Some people bemoan the squash commit approach, with 2 main complaints that
I've encountered:

1. The full commit history is not preserved.
2. It decreases their apparent GitHub activity.

My responses follow:

1. Deleted branches can be restored.
2. GitHub activity is a poor proxy for impact.



## Bonus: Tips for Auditing 

### Assign BLAME

### Grep FTW

### Comparing Commits

## Summary


<p id=fin><i>fin!</i></p>
